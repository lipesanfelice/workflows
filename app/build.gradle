plugins {
    id 'java'
    id 'application'
    id 'jacoco'
    id "org.sonarqube" version "6.2.0.5505"
    id 'org.springframework.boot' version '3.3.2'
    id 'io.spring.dependency-management' version '1.1.5'
}

import org.gradle.testing.jacoco.plugins.JacocoTaskExtension
import java.util.regex.Pattern
import java.util.regex.PatternSyntaxException

repositories {
    mavenCentral()
}

/* ‚úÖ garanta que as configs existem antes de us√°-las */
configurations {
    usuarioImplementation.extendsFrom implementation
    usuarioRuntimeOnly.extendsFrom runtimeOnly
    usuarioTestImplementation.extendsFrom testImplementation
    usuarioTestRuntimeOnly.extendsFrom testRuntimeOnly

    // Agente do JaCoCo para -javaagent (correto = classifier runtime@jar)
    jacocoAgentRuntime
}

/** üö´ Kill switch para renomear produ√ß√£o (default: false) */
def ALLOW_RENAME = providers.provider { (System.getenv("ALLOW_RENAME") ?: "false").equalsIgnoreCase("true") }

dependencies {
    // ===== App / Main =====
    implementation libs.guava
    implementation 'org.json:json:20240303'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.17.1'
    implementation 'commons-io:commons-io:2.16.1'
    implementation 'com.squareup.okhttp3:okhttp:4.12.0'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-validation'

    // ===== Teste padr√£o =====
    testImplementation platform('org.junit:junit-bom:5.10.2')
    testImplementation 'org.junit.jupiter:junit-jupiter'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.mockito:mockito-core:5.13.0'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    testRuntimeOnly 'org.junit.platform:junit-platform-console-standalone:1.10.2'

    // ===== usuarioTest (herda de cima via extendsFrom, mas garantimos engine) =====
    usuarioTestRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'

    // ===== JaCoCo agent correto =====
    jacocoAgentRuntime "org.jacoco:org.jacoco.agent:0.8.12:runtime@jar"

    // ===== libs resolvidas dinamicamente do usu√°rio =====
    usuarioImplementation fileTree('entrada-usuario/libs') { include '*.jar' }
}

java {
    toolchain { languageVersion = JavaLanguageVersion.of(21) }
}

application {
    mainClass = 'org.example.web.WebApplication'
}

springBoot {
    mainClass = 'org.example.web.WebApplication'
}

sonar {
    properties {
        property "sonar.projectKey", "lipesanfelice_workflows"
        property "sonar.organization", "lipesanfelice"
        property "sonar.host.url", "https://sonarcloud.io"
        property "sonar.token", System.getenv("SONAR_TOKEN")

        // üëá fontes analisadas = APENAS a pasta entrada-usuario
        property "sonar.sources", "entrada-usuario"
        property "sonar.inclusions", "entrada-usuario/**/*.java"

        property "sonar.tests", "src/test/java"
        property "sonar.java.binaries", "build/classes/java/main"
        property "sonar.junit.reportPaths", "build/test-results/test"
        property "sonar.coverage.jacoco.xmlReportPaths", "build/reports/jacoco/test/jacocoTestReport.xml"
    }
}

tasks.register('salvarRelatorioSonar', JavaExec) {
    group = 'sonar'
    mainClass = 'org.example.util.SonarRelatorioCli'
    classpath = sourceSets.main.runtimeClasspath
    args "lipesanfelice_workflows", System.getenv('SONAR_TOKEN') ?: '', "$projectDir/entrada-usuario/relatorio-sonar.json"
}

tasks.register('gerarTestesIa', JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'org.example.web.cli.GerarTestesCli'
}

// === NOVA TASK CLI p/ AJUSTE DE TESTES (Groq) ===
tasks.register('ajustarTestesIa', JavaExec) {
    group = "verification"
    description = "Pede √† Groq patches de testes, salva em entrada-usuario/testes_ai_patches"
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'org.example.web.ia.AjustarTestesCli'
    // par√¢metros padr√£o (podem ser sobrescritos no CI)
    args "--modelo=${System.getenv('GROQ_MODELO') ?: 'llama-3.1-8b-instant'}"
    environment "GROQ_API_KEY", System.getenv("GROQ_API_KEY") ?: ""
}

/* ====================== Caminhos e diret√≥rios ====================== */
def dirEntrada        = file('entrada-usuario')
def dirTestsIA        = file('entrada-usuario/testes_explica√ß√µes/tests')
def dirTestsUsuario   = file('entrada-usuario/testes')
// üëá patches que a IA cria a cada tentativa
def dirTestsAIPatches = file('entrada-usuario/testes_ai_patches')

def dirWork    = layout.buildDirectory.dir('usuario-src').get().asFile
def dirMain    = new File(dirWork, 'src/main/java')
def dirTestRaw = new File(dirWork, 'src/test_raw/java')
def dirTestStage = new File(dirWork, 'src/test/java')

/* ================== Mapa heur√≠stico de imports ‚Üí coord. Maven ================== */
def mapaImports = [
    'org.apache.commons.lang3': 'org.apache.commons:commons-lang3:3.14.0',
    'org.apache.commons.io': 'commons-io:commons-io:2.16.1',
    'org.apache.commons.text': 'org.apache.commons:commons-text:1.11.0',
    'org.apache.commons.collections4': 'org.apache.commons:commons-collections4:4.4',
    'org.apache.commons.csv': 'org.apache.commons:commons-csv:1.10.0',
    'org.apache.commons.codec': 'commons-codec:commons-codec:1.16.1',
    'org.apache.commons.compress': 'org.apache.commons:commons-compress:1.26.2',
    'org.apache.commons.math3': 'org.apache.commons:commons-math3:3.6.1',
    'org.apache.commons.beanutils': 'commons-beanutils:commons-beanutils:1.9.4',
    'org.apache.commons.validator': 'commons-validator:1.9.0',
    'com.google.common': 'com.google.guava:guava:33.2.1-jre',
    'com.google.gson': 'com.google.code.gson:gson:2.11.0',
    'com.google.protobuf': 'com.google.protobuf:protobuf-java:3.25.3',
    'com.google.truth': 'com.google.truth:truth:1.4.2',
    'org.yaml.snakeyaml': 'org.yaml:snakeyaml:2.2',
    'com.fasterxml.jackson.core': 'com.fasterxml.jackson.core:jackson-core:2.17.1',
    'com.fasterxml.jackson.annotation': 'com.fasterxml.jackson.core:jackson-annotations:2.17.1',
    'com.fasterxml.jackson.databind': 'com.fasterxml.jackson.core:jackson-databind:2.17.1',
    'com.fasterxml.jackson.dataformat': 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.17.1',
    'com.fasterxml.jackson.datatype': 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.17.1',
    'org.slf4j': 'org.slf4j:slf4j-api:2.0.13',
    'org.slf4j.simple': 'org.slf4j:slf4j-simple:2.0.13',
    'ch.qos.logback': 'ch.qos.logback-classic:1.5.6',
    'org.apache.logging.log4j': 'org.apache.logging.log4j:log4j-api:2.23.1',
    'org.apache.logging.log4j.core': 'org.apache.logging.log4j:log4j-core:2.23.1',
    'org.apache.http': 'org.apache.httpcomponents.client5:httpclient5:5.3.1',
    'org.apache.http.client': 'org.apache.httpcomponents:httpclient:4.5.14',
    'okhttp3': 'com.squareup.okhttp3:okhttp:4.12.0',
    'retrofit2': 'com.squareup.retrofit2:retrofit:2.11.0',
    'okio': 'com.squareup.okio:okio:3.9.0',
    'org.jsoup': 'org.jsoup:jsoup:1.18.1',
    'org.xerial.sqlitejdbc': 'org.xerial:sqlite-jdbc:3.45.3.0',
    'com.h2database': 'com.h2database:h2:2.2.224',
    'org.postgresql': 'org.postgresql:postgresql:42.7.3',
    'com.mysql': 'com.mysql:mysql-connector-j:8.3.0',
    'org.hibernate': 'org.hibernate.orm:hibernate-core:6.5.3.Final',
    'jakarta.persistence': 'jakarta.persistence:jakarta.persistence-api:3.1.0',
    'jakarta.validation': 'jakarta.validation:jakarta.validation-api:3.0.2',
    'jakarta.xml.bind': 'jakarta.xml.bind:jakarta.xml.bind-api:4.0.2',
    'org.apache.poi': 'org.apache.poi:poi-ooxml:5.2.5',
    'com.opencsv': 'com.opencsv:opencsv:5.9',
    'org.jose4j': 'org.bitbucket_b_c:jose4j:0.9.6',
    'org.mindrot.jbcrypt': 'org.mindrot:jbcrypt:0.4',
    'org.mapstruct': 'org.mapstruct:mapstruct:1.5.5.Final',
    'org.modelmapper': 'org.modelmapper:modelmapper:3.2.0',
    'org.jetbrains.annotations': 'org.jetbrains:annotations:24.1.0',
    'org.junit.jupiter': 'org.junit.jupiter:junit-jupiter:5.10.2',
    'org.junit.platform': 'org.junit.platform:junit-platform-launcher:1.10.2',
    'org.mockito': 'org.mockito:mockito-core:5.13.0',
    'org.hamcrest': 'org.hamcrest:hamcrest:2.2',
    'org.assertj': 'org.assertj:assertj-core:3.26.0',
    'org.json': 'org.json:json:20240303',
    'org.joda.time': 'joda-time:joda-time:2.12.7',
    'javax.annotation': 'com.google.code.findbugs:jsr305:3.0.2',
]

/* ================== JACOCO ‚ÄúIMUNE‚Äù A S√çMBOLOS/CHARSET ================== */
tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.debug = true
    options.debugOptions.debugLevel = 'source,lines,vars'
}
tasks.withType(Test).configureEach {
    systemProperty "file.encoding", "UTF-8"
}
/* ====================================================================== */

/* ======================== resolverDepsUsuario ======================== */
tasks.register('resolverDepsUsuario') {
    inputs.files(fileTree(dirEntrada) { include '**/*.java' })
    inputs.files(provider {
        def f = file('entrada-usuario/deps.txt')
        f.exists() ? [f] : []
    })
    inputs.files(provider {
        def v = file('entrada-usuario/vendor')
        v.exists() ? fileTree(v) { include '*.jar' } : []
    })
    outputs.dir(file('entrada-usuario/libs'))

    doLast {
        def libsDir = file('entrada-usuario/libs'); libsDir.mkdirs()

        // 1) JARs locais do usu√°rio
        def vendorDir = file('entrada-usuario/vendor')
        if (vendorDir.exists()) {
            copy { from(vendorDir); include '*.jar'; into libsDir }
        }

        // 2) deps.txt
        def coords = [] as Set
        def depsTxt = file('entrada-usuario/deps.txt')
        if (depsTxt.exists()) {
            depsTxt.readLines('UTF-8').each { line ->
                def s = line.trim(); if (s && !s.startsWith('#')) coords << s
            }
        }

        // 3) Heur√≠stica por imports
        def imports = [] as Set
        fileTree(dirEntrada) { include '**/*.java' }.each { f ->
            f.eachLine('UTF-8') { l ->
                def m = (l =~ /^\s*import\s+([a-zA-Z0-9_.]+)\./)
                if (m.find()) imports << m.group(1)
            }
        }
        imports.each { pkg ->
            mapaImports.findAll { k, v -> pkg.startsWith(k) }.each { k, v -> coords << v }
        }

        // 4) Resolve e copia jars
        if (!coords.isEmpty()) {
            def depObjs = coords.collect { dependencies.create(it) } as org.gradle.api.artifacts.Dependency[]
            def conf = configurations.detachedConfiguration(depObjs); conf.setTransitive(true)
            def filesResolved = conf.resolve()
            copy { from filesResolved; into libsDir }
        }

        new File(libsDir, 'RESOLVIDO.txt').setText((coords.join('\n') + '\n'), 'UTF-8')
        println "resolverDepsUsuario ‚Üí libs geradas em ${libsDir} (${coords.size()} coords)"
    }
}

/* ========================== organizarUsuario ========================== */
tasks.register('organizarUsuario') {
    inputs.files(fileTree(dirEntrada) { include '**/*.java' })
    inputs.files(fileTree(dirTestsIA) { include '**/*.java' })
    inputs.files(fileTree(dirTestsUsuario) { include '**/*.java' })
    inputs.files(fileTree(dirTestsAIPatches) { include '**/*.java' })
    outputs.dir(dirWork)

    doLast {
        if (dirWork.exists()) dirWork.deleteDir()
        dirMain.mkdirs(); dirTestRaw.mkdirs(); dirTestStage.mkdirs()

        def extrairPacote = { String src ->
            def m = (src =~ /(?m)^\s*package\s+([a-zA-Z0-9_.]+)\s*;/)
            m.find() ? m.group(1) : ''
        }
        def extrairNomePublico = { String src ->
            def m = (src =~ /(?m)^\s*public\s+(?:class|interface|enum|record)\s+([A-Za-z_][A-Za-z0-9_]*)\b/)
            m.find() ? m.group(1) : null
        }
        def classesReferenciadasEmTestes = { String src ->
            def ignora = [
                'Assertions','Assert','System','Math','Objects','List','ArrayList','Arrays',
                'Collections','Stream','Optional','Files','Paths','Mockito','Matchers','Pattern','Matcher'
            ] as Set
            def nomes = [] as Set
            def pat = ~/(?m)([A-Z][A-Za-z0-9_]*)\s*\.\s*[A-Za-z_][A-Za-z0-9_]*\s*\(/
            def matcher = pat.matcher(src)
            while (matcher.find()) { def c = matcher.group(1); if (!ignora.contains(c)) nomes << c }
            nomes
        }
        def sanitizeJavaTest = { String s ->
            if (s == null) return s
            s = s.replaceAll('(?m)^```\\w*\\s*\\r?\\n?', '')
            s = s.replaceAll('(?m)^```\\s*$', '')
            s = s.replace('\uFEFF', '')
            def lines = s.readLines()
            def isValidStart = { String ln ->
                (ln ==~ /\s*/) || (ln ==~ /\s*package\s+.*/) || (ln ==~ /\s*import\s+.*/) ||
                (ln ==~ /\s*@.*/) || (ln ==~ /\s*(public\s+)?(class|interface|enum|record)\b.*/) ||
                (ln ==~ /\s*\/\/.*/) || (ln ==~ /\s*\/\*.*/) || (ln ==~ /\s*\*.*/)
            }
            def fileNameOnly = Pattern.compile('^[A-Za-z0-9_.\\/\\-]+\\.java$')
            while (!lines.isEmpty() && !isValidStart(lines[0])) {
                def head = lines[0].trim()
                if (fileNameOnly.matcher(head).matches()) { lines.remove(0); continue }
                lines.remove(0)
            }
            lines.join('\n')
        }

        def lerTests = { File raiz ->
            def res = []
            if (raiz.exists()) fileTree(raiz) { include '**/*.java' }.each { f -> res << [file: f, text: f.getText('UTF-8')] }
            res
        }
        def testesUser      = lerTests(dirTestsUsuario)
        def testesAIPatches = lerTests(dirTestsAIPatches)
        def testesIAExp     = lerTests(dirTestsIA)

        def nomePublicoTeste = { String s ->
            def m = (s =~ /(?m)^\s*public\s+(?:class|interface|enum|record)\s+([A-Za-z_]\w*)\b/)
            m.find() ? m.group(1) : null
        }
        def porNome = [:]
        [testesIAExp, testesAIPatches, testesUser].each { lista ->
            lista.each { t -> def n = nomePublicoTeste(t.text) ?: ("Anon_" + t.file.name); porNome[n] = t }
        }
        def testesIA = porNome.values().toList()
        println "organizarUsuario ‚Üí testes recebidos (raw):  ${testesIA.size()}"

        // fontes do usu√°rio (produ√ß√£o)
        def fontesUsuario = []
        fileTree(dirEntrada) {
            include '**/*.java'
            exclude 'testes/**', 'testes_explica√ß√µes/**', 'testes_ai_patches/**'
        }.each { f -> fontesUsuario << [file: f, text: f.getText('UTF-8')] }

        // autocorre√ß√£o de chamadas est√°ticas nos testes (Levenshtein)
        def extrairMetodosPublicosEstaticos = { String src ->
            def met = [] as Set
            def m = (src =~ /(?m)^\s*public\s+static\s+[A-Za-z0-9_<>\[\]\.?]+\s+([A-Za-z_]\w*)\s*\(/)
            while (m.find()) met << m.group(1)
            met
        }
        def extrairNomeClassePublica = { String src ->
            def m = (src =~ /(?m)^\s*public\s+(?:class|record|interface)\s+([A-Za-z_]\w*)\b/)
            m.find() ? m.group(1) : null
        }
        def chamadasEstaticas = ~/([A-Z][A-Za-z0-9_]*)\s*\.\s*([A-Za-z_]\w*)\s*\(/
        def mapaClasseMetodos = [:].withDefault { [] as Set }
        fontesUsuario.each { f ->
            def cls = extrairNomeClassePublica(f.text)
            if (cls) { mapaClasseMetodos[cls] += extrairMetodosPublicosEstaticos(f.text) }
        }
        def lev = { String a, String b ->
            if (a == b) return 0
            if (!a?.length()) return b.length()
            if (!b?.length()) return a.length()
            def d = new int[a.length()+1][b.length()+1]
            for (int i=0;i<=a.length();i++) d[i][0]=i
            for (int j=0;j<=b.length();j++) d[0][j]=j
            for (int i=1;i<=a.length();i++)
                for (int j=1;j<=b.length();j++) {
                    int cost = (a.charAt(i-1)==b.charAt(j-1)) ? 0 : 1
                    d[i][j] = Math.min(Math.min(d[i-1][j]+1, d[i][j-1]+1), d[i-1][j-1]+cost)
                }
            d[a.length()][b.length()]
        }
        def substituicoesConhecidas = [ 'kilmetroParaMetro':'kilometroParaMetro', 'quilometroParaMetro':'kilometroParaMetro' ]
        testesIA = testesIA.collect { ti ->
            String t = ti.text
            substituicoesConhecidas.each { de, para -> t = t.replaceAll("\\b" + java.util.regex.Pattern.quote(de) + "\\b", para) }
            def m = chamadasEstaticas.matcher(t)
            def sb = new StringBuffer()
            while (m.find()) {
                def cls = m.group(1); def met = m.group(2)
                def candidatos = (mapaClasseMetodos[cls] as Set) ?: [] as Set
                if (candidatos && !candidatos.contains(met)) {
                    def melhor = null; def dist = Integer.MAX_VALUE
                    candidatos.each { c -> def d = lev(met, c); if (d < dist) { dist = d; melhor = c } }
                    if (melhor != null && dist <= 2) { m.appendReplacement(sb, java.util.regex.Matcher.quoteReplacement("${cls}.${melhor}(")); continue }
                }
                m.appendReplacement(sb, java.util.regex.Matcher.quoteReplacement(m.group(0)))
            }
            m.appendTail(sb)
            [file: ti.file, text: sb.toString()]
        }

        // pacote & rename opcional (com ponte), protegido por ALLOW_RENAME
        def pacotesUsuario = fontesUsuario.collect { extrairPacote(it.text) }.toSet()
        String pacoteUsuario = (pacotesUsuario.size() == 1) ? pacotesUsuario.first() : ''
        def nomesPublicosUsuario = fontesUsuario.collect { extrairNomePublico(it.text) }.findAll { it }
        def nomesReferenciadosTestes = classesReferenciadasEmTestes(testesIA.collect { it.text }.join("\n"))
        String nomePublico = (nomesPublicosUsuario ?: [null]).first()
        String nomeEsperado = (nomesReferenciadosTestes ?: [null]).first()
        boolean deveRenomear = (nomePublico && nomeEsperado && nomePublico != nomeEsperado &&
                                nomesPublicosUsuario.size()==1 && nomesReferenciadosTestes.size()==1)
        if (ALLOW_RENAME.get() && deveRenomear) {
            fontesUsuario = fontesUsuario.collect { f ->
                if (extrairNomePublico(f.text) == nomePublico) {
                    def novoTexto = f.text
                        .replaceFirst(
                            /(?m)(^\s*public\s+(?:class|interface|enum|record)\s+)${java.util.regex.Pattern.quote(nomePublico)}\b/,
                            "\$1${nomeEsperado}"
                        )
                        .replaceAll(
                            "(?m)(^\\s*public\\s+)${java.util.regex.Pattern.quote(nomePublico)}\\s*\\(",
                            "\$1${nomeEsperado}("
                        )
                    def pacote = extrairPacote(novoTexto)
                    def caminhoPacote = pacote ? pacote.replace('.', File.separator) : ''
                    def repoDir = new File(dirEntrada, caminhoPacote); repoDir.mkdirs()
                    new File(repoDir, "${nomeEsperado}.java").setText(novoTexto, 'UTF-8')
                    def antigo = new File(repoDir, "${nomePublico}.java"); if (antigo.exists()) antigo.delete()
                    [file: f.file, text: novoTexto]
                } else { f }
            }
            println "organizarUsuario ‚Üí renomeado classe p√∫blica '${nomePublico}' ‚Üí '${nomeEsperado}'"
            testesIA = testesIA.collect { ti -> [file: ti.file, text: ti.text?.replaceAll("\\b${java.util.regex.Pattern.quote(nomePublico)}\\b", nomeEsperado)] }
            boolean precisaBridge = false
            String pacoteDoUsuario = pacoteUsuario ?: ''
            fontesUsuario.each { fu ->
                def t = fu.text
                def mClass = (t =~ /(?m)^\s*public\s+(?:class)\s+${java.util.regex.Pattern.quote(nomeEsperado)}\b/)
                def mFinal = (t =~ /(?m)^\s*public\s+final\s+class\s+${java.util.regex.Pattern.quote(nomeEsperado)}\b/)
                if (mClass.find() && !mFinal.find()) precisaBridge = true
            }
            if (precisaBridge) {
                File baseDestino = dirMain
                if (pacoteDoUsuario) { baseDestino = new File(dirMain, pacoteDoUsuario.replace('.', File.separator)); baseDestino.mkdirs() }
                File bridge = new File(baseDestino, "${nomePublico}.java")
                if (!bridge.exists()) {
                    def headerPkg = pacoteDoUsuario ? "package ${pacoteDoUsuario};\n" : ""
                    bridge.setText(
                        """${headerPkg}
/** Classe-ponte para compat com testes antigos. */
public class ${nomePublico} extends ${nomeEsperado} {
    public ${nomePublico}() { super(); }
}
""".stripIndent(), "UTF-8")
                    println "organizarUsuario ‚Üí compat: criada classe-ponte '${nomePublico}' ‚Üí '${nomeEsperado}'."
                }
            }
        } else if (deveRenomear) {
            println "organizarUsuario ‚Üí ‚ö†Ô∏è rename autom√°tico desligado. Ajuste os TESTES para referenciar '${nomePublico}'."
        }

        def ajustarTesteParaPacoteUsuario = { String texto ->
            String pkgTeste = extrairPacote(texto)
            if (pacoteUsuario == '') {
                texto = texto.replaceFirst(/(?m)^\s*package\s+[^;]+;\s*/, '')
            } else {
                if (pkgTeste == '') {
                    texto = "package ${pacoteUsuario};\n" + texto
                    pkgTeste = pacoteUsuario
                } else if (!texto.contains("import ${pacoteUsuario}.")) {
                    texto = texto.replaceFirst(/(?m)^(package\s+[^;]+;\s*)/, "\$1\nimport ${pacoteUsuario}.*;\n")
                }
            }

            def candidatos = [
                [sym:'Random', fqcn:'java.util.Random'], [sym:'Scanner', fqcn:'java.util.Scanner'],
                [sym:'Arrays', fqcn:'java.util.Arrays'], [sym:'List', fqcn:'java.util.List'],
                [sym:'ArrayList', fqcn:'java.util.ArrayList'], [sym:'LinkedList', fqcn:'java.util.LinkedList'],
                [sym:'Deque', fqcn:'java.util.Deque'], [sym:'ArrayDeque', fqcn:'java.util.ArrayDeque'],
                [sym:'Queue', fqcn:'java.util.Queue'], [sym:'Set', fqcn:'java.util.Set'],
                [sym:'HashSet', fqcn:'java.util.HashSet'], [sym:'TreeSet', fqcn:'java.util.TreeSet'],
                [sym:'Map', fqcn:'java.util.Map'], [sym:'HashMap', fqcn:'java.util.HashMap'],
                [sym:'LinkedHashMap', fqcn:'java.util.LinkedHashMap'], [sym:'TreeMap', fqcn:'java.util.TreeMap'],
                [sym:'Collections', fqcn:'java.util.Collections'], [sym:'Optional', fqcn:'java.util.Optional'],
                [sym:'Comparator', fqcn:'java.util.Comparator'], [sym:'UUID', fqcn:'java.util.UUID'],
                [sym:'Properties', fqcn:'java.util.Properties'], [sym:'BitSet', fqcn:'java.util.BitSet'],
                [sym:'Stream', fqcn:'java.util.stream.Stream'], [sym:'IntStream', fqcn:'java.util.stream.IntStream'],
                [sym:'LongStream', fqcn:'java.util.stream.LongStream'], [sym:'DoubleStream', fqcn:'java.util.stream.DoubleStream'],
                [sym:'Instant', fqcn:'java.time.Instant'], [sym:'Duration', fqcn:'java.time.Duration'],
                [sym:'Period', fqcn:'java.time.Period'], [sym:'LocalDate', fqcn:'java.time.LocalDate'],
                [sym:'LocalTime', fqcn:'java.time.LocalTime'], [sym:'LocalDateTime', fqcn:'java.time.LocalDateTime'],
                [sym:'ZonedDateTime', fqcn:'java.time.ZonedDateTime'], [sym:'OffsetDateTime', fqcn:'java.time.OffsetDateTime'],
                [sym:'ZoneId', fqcn:'java.time.ZoneId'], [sym:'DateTimeFormatter', fqcn:'java.time.format.DateTimeFormatter'],
                [sym:'Path', fqcn:'java.nio.file.Path'], [sym:'Paths', fqcn:'java.nio.file.Paths'],
                [sym:'Files', fqcn:'java.nio.file.Files'], [sym:'StandardOpenOption', fqcn:'java.nio.file.StandardOpenOption'],
                [sym:'Charset', fqcn:'java.nio.charset.Charset'], [sym:'StandardCharsets', fqcn:'java.nio.charset.StandardCharsets'],
                [sym:'File', fqcn:'java.io.File'], [sym:'IOException', fqcn:'java.io.IOException'],
                [sym:'InputStream', fqcn:'java.io.InputStream'], [sym:'OutputStream', fqcn:'java.io.OutputStream'],
                [sym:'FileInputStream', fqcn:'java.io.FileInputStream'], [sym:'FileOutputStream', fqcn:'java.io.FileOutputStream'],
                [sym:'Reader', fqcn:'java.io.Reader'], [sym:'Writer', fqcn:'java.io.Writer'],
                [sym:'BufferedReader', fqcn:'java.io.BufferedReader'], [sym:'BufferedWriter', fqcn:'java.io.BufferedWriter'],
                [sym:'InputStreamReader', fqcn:'java.io.InputStreamReader'], [sym:'OutputStreamWriter', fqcn:'java.io.OutputStreamWriter'],
                [sym:'FileReader', fqcn:'java.io.FileReader'], [sym:'FileWriter', fqcn:'java.io.FileWriter'],
                [sym:'PrintWriter', fqcn:'java.io.PrintWriter'], [sym:'BigDecimal', fqcn:'java.math.BigDecimal'],
                [sym:'BigInteger', fqcn:'java.math.BigInteger'], [sym:'RoundingMode', fqcn:'java.math.RoundingMode'],
                [sym:'Pattern', fqcn:'java.util.regex.Pattern'], [sym:'Matcher', fqcn:'java.util.regex.Matcher'],
                [sym:'URI', fqcn:'java.net.URI'], [sym:'URL', fqcn:'java.net.URL'],
                [sym:'URLEncoder', fqcn:'java.net.URLEncoder'], [sym:'URLDecoder', fqcn:'java.net.URLDecoder'],
                [sym:'HttpClient', fqcn:'java.net.http.HttpClient'], [sym:'HttpRequest', fqcn:'java.net.http.HttpRequest'],
                [sym:'HttpResponse', fqcn:'java.net.http.HttpResponse'], [sym:'Objects', fqcn:'java.util.Objects'],
                [sym:'StringJoiner', fqcn:'java.util.StringJoiner'], [sym:'Spliterator', fqcn:'java.util.Spliterator'],
            ]
            def importados = [] as Set
            def impMatcher = (texto =~ /(?m)^\s*import\s+([a-zA-Z0-9_.]+)\s*;/)
            while (impMatcher.find()) importados << impMatcher.group(1)
            def paraInserir = []
            candidatos.each { c ->
                def usaSimbolo = (texto =~ /\b${c.sym}\b/).find()
                def jaTemImportDireto = importados.contains(c.fqcn)
                def jaTemWildcard = importados.any { it == c.fqcn.replaceAll(/\.[^.]+$/, '.*') }
                def jaUsaQualificado = (texto =~ /\b${java.util.regex.Pattern.quote(c.fqcn)}\b/).find()
                if (usaSimbolo && !jaTemImportDireto && !jaTemWildcard && !jaUsaQualificado) {
                    paraInserir << "import ${c.fqcn}"; importados << c.fqcn
                }
            }
            if (!paraInserir.isEmpty()) {
                if ((texto =~ /(?m)^\s*package\s+[^;]+;\s*$/).find()) {
                    texto = texto.replaceFirst(/(?m)^(package\s+[^;]+;\s*)/, "\$1\n" + paraInserir.join(";\n") + ";\n")
                } else {
                    texto = paraInserir.join(";\n") + ";\n" + texto
                }
            }
            texto
        }
        def espelharParaRepo = { String texto ->
            String pacote = extrairPacote(texto)
            String caminhoPacote = pacote ? pacote.replace('.', File.separator) : ''
            File repoDir = caminhoPacote ? new File(dirEntrada, caminhoPacote) : dirEntrada
            repoDir.mkdirs()
            String nomePublicoLocal = extrairNomePublico(texto)
            String nomeArquivo = nomePublicoLocal ? "${nomePublicoLocal}.java" : "Arquivo_${System.nanoTime()}.java"
            new File(repoDir, nomeArquivo).setText(texto, 'UTF-8')
        }
        def injetarStubLoginAttempt = {
            String pacote = pacoteUsuario ?: ''
            String header = pacote ? "package ${pacote};\n" : ""
            def destinoDir = pacote ? new File(dirTestStage, pacote.replace('.', File.separator)) : dirTestStage
            destinoDir.mkdirs()
            new File(destinoDir, "LoginAttempt.java").setText(
                """${header}
public class LoginAttempt {
    public String user;
    public boolean success;
    public long timestamp;
    public LoginAttempt() {}
    public LoginAttempt(String user, boolean success, long ts){
        this.user = user; this.success = success; this.timestamp = ts;
    }
}
""".stripIndent(), "UTF-8")
            println "organizarUsuario ‚Üí stub LoginAttempt injetado em testes (stage)"
        }
        def injetarTestHooks = {
            String pacote = pacoteUsuario ?: ''
            String header = pacote ? "package ${pacote};\n" : ""
            def destinoDir = pacote ? new File(dirTestStage, pacote.replace('.', File.separator)) : dirTestStage
            destinoDir.mkdirs()
            new File(destinoDir, "TestHooks.java").setText(
                """${header}
import java.lang.reflect.Field;
import java.util.Map;
public final class TestHooks {
    private TestHooks() {}
    @SuppressWarnings("unchecked")
    public static void setActive(Object ums, String username, boolean active) {
        try {
            Class<?> cls = ums.getClass();
            Field fUsers = cls.getDeclaredField("users");
            fUsers.setAccessible(true);
            Object mapObj = fUsers.get(ums);
            Object userObj = ((Map<String, ?>) mapObj).get(username);
            if (userObj == null) return;
            Field fActive = userObj.getClass().getDeclaredField("isActive");
            fActive.setAccessible(true);
            fActive.setBoolean(userObj, active);
        } catch (Exception e) {
            throw new RuntimeException("TestHooks.setActive falhou", e);
        }
    }
}
""".stripIndent(), "UTF-8")
            println "organizarUsuario ‚Üí TestHooks injetado em testes (stage)"
        }
        def gravar = { String texto, boolean isTeste ->
            if (isTeste) { texto = sanitizeJavaTest(texto); texto = ajustarTesteParaPacoteUsuario(texto) }
            String pacote = extrairPacote(texto)
            String caminhoPacote = pacote ? pacote.replace('.', File.separator) : ''
            File baseDestino = isTeste ? dirTestRaw : dirMain
            File destinoDir = caminhoPacote ? new File(baseDestino, caminhoPacote) : baseDestino
            destinoDir.mkdirs()
            String nomePublicoLocal = extrairNomePublico(texto)
            String nomeArquivo = nomePublicoLocal ? "${nomePublicoLocal}.java" : "Arquivo_${System.nanoTime()}.java"
            new File(destinoDir, nomeArquivo).setText(texto, 'UTF-8')
            if (!isTeste) espelharParaRepo(texto)
        }

        testesIA = testesIA.collect { ti ->
            String t = sanitizeJavaTest(ti.text)
            String patched = t.replaceAll(
                /(\\b[A-Za-z_][A-Za-z0-9_]*)\\.users\\.get\\(([^)]+)\\)\\.isActive\\s*=\\s*(true|false)\\s*;/,
                'TestHooks.setActive($1, $2, $3);'
            )
            if (patched.contains("LoginAttempt")) injetarStubLoginAttempt()
            if (!patched.equals(t) || patched.contains("TestHooks.setActive(")) injetarTestHooks()
            [file: ti.file, text: patched]
        }

        // sanitize main robusto
        def sanitizeJavaMain = { String s ->
            if (s == null) return s
            s = s.replace('\uFEFF','').replaceAll('(?m)^```\\w*\\s*\\r?\\n?', '').replaceAll('(?m)^```\\s*$', '')
            def lines = s.readLines()
            def inicioValido = { String ln ->
                ln ==~ /\s*/ || ln ==~ /\s*package\s+.*/ || ln ==~ /\s*import\s+.*/ ||
                ln ==~ /\s*@.*/ || ln ==~ /\s*(public\s+)?(class|interface|enum|record)\b.*/ ||
                ln ==~ /\s*\/\/.*/ || ln ==~ /\s*\/\*.*/ || ln ==~ /\s*\*.*/
            }
            while (!lines.isEmpty() && !inicioValido(lines[0])) lines.remove(0)
            s = lines.join('\n')
            def m = (s =~ /(?m)^\s*public\s+(?:class|interface|enum|record)\s+[A-Za-z_]\w*\b/)
            if (!m.find()) return s
            int declStart = m.start()
            int braceOpen = s.indexOf('{', declStart)
            if (braceOpen == -1) return s
            int depth = 0, endIdx = -1
            for (int i = braceOpen; i < s.length(); i++) {
                char c = s.charAt(i)
                if (c == '{') depth++
                else if (c == '}') depth--
                if (depth == 0) { endIdx = i; break }
            }
            if (endIdx != -1) s = s.substring(0, endIdx + 1)
            else s = s + ("\n" + ("}" * depth) + "\n")
            s
        }
        def fontesUsuarioSan = fontesUsuario.collect { f -> [file: f.file, text: sanitizeJavaMain(f.text)] }
        fontesUsuario = fontesUsuarioSan

        fontesUsuario.each { gravar(it.text, false) }
        def testesIALista = testesIA.collect { gravar(it.text, true); it }

        // stubs condicional em org.example.model
        def modeloPkgPath = new File(dirMain, "org/example/model")
        def modeloJaExiste = { String nome ->
            def f1 = new File(modeloPkgPath, "${nome}.java")
            if (f1.exists()) return true
            return fileTree(dirEntrada) { include "**/${nome}.java" }.any { it.text.contains("package org.example.model") }
        }
        def allText = (fontesUsuario.collect{it.text} + testesIALista.collect{it.text}).join("\n")
        def precisaRel   = allText.contains("RelatorioCobertura") && !modeloJaExiste("RelatorioCobertura")
        def precisaClasse= allText.contains("ClasseCoberta")      && !modeloJaExiste("ClasseCoberta")
        def precisaMetodo= allText.contains("MetodoCoberto")      && !modeloJaExiste("MetodoCoberto")
        if (precisaRel || precisaClasse || precisaMetodo) {
            modeloPkgPath.mkdirs()
            if (precisaMetodo) new File(modeloPkgPath, "MetodoCoberto.java").setText(
                "package org.example.model;\npublic record MetodoCoberto(String nome, int linhaInicio, int linhaFim, double cobertura) {}\n", "UTF-8")
            if (precisaClasse) new File(modeloPkgPath, "ClasseCoberta.java").setText(
                "package org.example.model;\nimport java.util.List;\npublic record ClasseCoberta(String nome, String caminho, List<MetodoCoberto> metodos) {}\n", "UTF-8")
            if (precisaRel) new File(modeloPkgPath, "RelatorioCobertura.java").setText(
                """package org.example.model;
import java.util.List;
public final class RelatorioCobertura {
    public enum Ferramenta { JACOCO, OUTRA }
    private final String caminhoRelatorio;
    private final List<ClasseCoberta> classes;
    private final Ferramenta ferramenta;
    public RelatorioCobertura(String caminhoRelatorio, List<ClasseCoberta> classes, Ferramenta ferramenta) {
        this.caminhoRelatorio = caminhoRelatorio; this.classes = classes; this.ferramenta = ferramenta;
    }
    public String caminhoRelatorio() { return caminhoRelatorio; }
    public List<ClasseCoberta> classes() { return classes; }
    public Ferramenta ferramenta() { return ferramenta; }
}
""".stripIndent(), "UTF-8")
            println "organizarUsuario ‚Üí stubs injetados em org.example.model"
        }

        // meta para a IA
        def metaDir = file("$projectDir/entrada-usuario/meta"); metaDir.mkdirs()
        def meta = new File(metaDir, "nome_classe.env")
        meta.text = """USUARIO_PACKAGE=${pacoteUsuario ?: ""}
USUARIO_PUBLIC_CLASS=${nomePublico ?: ""}
""".stripIndent()

        println "organizarUsuario ‚Üí copiado para main: ${dirMain.absolutePath}"
        println "organizarUsuario ‚Üí copiado para test_raw: ${dirTestRaw.absolutePath}"
        println "organizarUsuario ‚Üí fontes recebidos: ${fontesUsuario.size()}"
        println "organizarUsuario ‚Üí testes recebidos (raw):  ${testesIA.size()}"
        if (nomePublico)  println "organizarUsuario ‚Üí nome p√∫blico (usuario): ${nomePublico}"
        if (nomeEsperado) println "organizarUsuario ‚Üí nome esperado (testes): ${nomeEsperado}"
        if (pacoteUsuario) println "organizarUsuario ‚Üí pacote do usu√°rio detectado: ${pacoteUsuario}"
    }
}

/* ==================== Sanear testes (RAW) ==================== */
tasks.register('sanearTestesUsuario') {
    group = 'verification'
    description = 'Limpa testes: remove marcas, ajusta imports JUnit e fecha chaves faltantes'
    dependsOn 'organizarUsuario'
    inputs.dir("$buildDir/usuario-src/src/test_raw/java")
    outputs.dir("$buildDir/usuario-src/src/test_raw/java")
    outputs.upToDateWhen { false }
    mustRunAfter 'organizarUsuario'

    doLast {
        File baseTest = file("$buildDir/usuario-src/src/test_raw/java")
        if (!baseTest.exists()) return

        final Pattern PAT_FILEHEADER     = Pattern.compile('(?m)^[A-Za-z0-9_.\\\\/\\-]+\\.java$')
        final Pattern PAT_IMPORT_TEST    = Pattern.compile('(?m)^\\s*import\\s+org\\.junit\\.jupiter\\.api\\.Test\\s*;')
        final Pattern PAT_IMPORT_ASSERT  = Pattern.compile('(?m)^\\s*import\\s+static\\s+org\\.junit\\.jupiter\\.api\\.Assertions\\.\\*\\s*;')
        final Pattern PAT_HAS_TEST_ANN   = Pattern.compile('@Test')
        final Pattern PAT_HAS_ASSERTCALL = Pattern.compile('\\bassert\\w*\\s*\\(')

        baseTest.eachFileRecurse { File f ->
            if (!(f.isFile() && f.name.endsWith('.java'))) return
            String src = f.getText('UTF-8')
            src = src
                .replace('\uFEFF','')
                .replaceAll('(?m)^```\\w*\\s*\\r?\\n?', '')
                .replaceAll('(?m)^```\\s*$', '')
                .replaceAll('(?m)^====+.*$', '')
                .replaceAll(PAT_FILEHEADER, '')
                .trim()

            boolean temTest = PAT_HAS_TEST_ANN.matcher(src).find()
            boolean usaAssertions = PAT_HAS_ASSERTCALL.matcher(src).find()
            if (temTest && !PAT_IMPORT_TEST.matcher(src).find()) {
                if ((src =~ /(?m)^\s*package\s+[^;]+;\s*$/).find()) {
                    src = src.replaceFirst(/(?m)^(\s*package\s+[^;]+;\s*)/, "\$1\nimport org.junit.jupiter.api.Test;\n")
                } else { src = "import org.junit.jupiter.api.Test;\n" + src }
            }
            if (usaAssertions && !PAT_IMPORT_ASSERT.matcher(src).find()) {
                if ((src =~ /(?m)^\s*package\s+[^;]+;\s*$/).find()) {
                    src = src.replaceFirst(/(?m)^(\s*package\s+[^;]+;\s*)/, "\$1\nimport static org.junit.jupiter.api.Assertions.*;\n")
                } else { src = "import static org.junit.jupiter.api.Assertions.*;\n" + src }
            }

            def out = new StringBuilder()
            def patSemipadrao = java.util.regex.Pattern.compile(
                '^\\s*(?:@\\w+(?:\\([^)]*\\))?\\s+)*' +
                '(?:(?:public|private|protected|static|final|abstract|transient|volatile|synchronized)\\s+)*' +
                '([A-Za-z_][\\w.<>\\[\\]]*)\\s+([A-Za-z_]\\w*)\\s*$'
            )
            src.readLines().each { ln ->
                String t = ln.trim()
                boolean comentario = t.startsWith('//') || t.startsWith('/*') || t.startsWith('*')
                boolean ehAssinatura = t.contains('(') || t.endsWith('{')
                boolean precisaPV = !(comentario || ehAssinatura || t.endsWith(';') || t.endsWith('}')) && patSemipadrao.matcher(t).matches()
                out.append(precisaPV ? (ln + ';') : ln).append('\n')
            }
            src = out.toString()

            int abre = 0, fecha = 0
            for (int i = 0; i < src.length(); i++) { char c = src.charAt(i); if (c == '{') abre++; else if (c == '}') fecha++ }
            if (abre > fecha) src = src + ("\n" + ("}" * (abre - fecha)) + "\n")

            f.setText(src, 'UTF-8')
        }
        println "sanearTestesUsuario ‚Üí testes (raw) higienizados."
    }
}

/* ======================= sourceSets usuario ======================= */
sourceSets {
    usuario {
        java { srcDirs = [dirMain] }
        resources.srcDirs = []
    }
    usuarioTest {
        java {
            srcDirs = [dirTestStage]
            exclude '**/*.java.skip'
        }
        resources.srcDirs = []
        compileClasspath += sourceSets.usuario.output
        runtimeClasspath  += sourceSets.usuario.output
    }
}

/* ====================== Pr√©-flight + NoOp ====================== */
def entradaUsuario = "${projectDir}/entrada-usuario"

tasks.register("prepUsuarioDirs") {
    doLast {
        file("${entradaUsuario}/testes_ai_patches").mkdirs()
        file("${entradaUsuario}/testes").mkdirs()
    }
}

tasks.register("preflightUsuarioTests") {
    dependsOn("organizarUsuario", "prepUsuarioDirs")

    inputs.dir("$buildDir/usuario-src/src/test_raw/java")
    inputs.dir("$projectDir/entrada-usuario/testes_ai_patches")
    inputs.dir("$projectDir/entrada-usuario/testes")

    doLast {
        Pattern ASSERT_THROWS_BAN
        try {
            ASSERT_THROWS_BAN = Pattern.compile(
                "(?s)assertThrows\\s*\\(\\s*(?:ArithmeticException|IllegalArgumentException|NullPointerException)\\s*\\.class"
            )
        } catch (PatternSyntaxException e) {
            logger.warn("preflightUsuarioTests: regex inv√°lido; verifica√ß√£o ignorada: ${e.message}")
            ASSERT_THROWS_BAN = null
        }

        def roots = [
            file("$buildDir/usuario-src/src/test_raw/java"),
            file("$projectDir/entrada-usuario/testes_ai_patches"),
            file("$projectDir/entrada-usuario/testes")
        ].findAll { it.exists() }

        def offenders = []
        if (ASSERT_THROWS_BAN != null) {
            roots.each { root ->
                fileTree(root).include("**/*.java").files.each { f ->
                    def txt = f.getText("UTF-8")
                    if (ASSERT_THROWS_BAN.matcher(txt).find()) offenders << f
                }
            }
        }

        if (!offenders.isEmpty()) {
            throw new GradleException(
                "Testes cont√™m assertThrows para exce√ß√µes proibidas (Arithmetic/IllegalArgument/NullPointer): " +
                offenders*.name.join(", ")
            )
        }
        logger.lifecycle("preflightUsuarioTests: OK (sem padr√µes proibidos).")
    }
}

tasks.register('injectNoOpTestIfNeeded') {
    group = 'verification'
    description = 'Cria um teste NoOp se nenhum teste v√°lido sobrar.'
    dependsOn 'preflightUsuarioTests'
    doLast {
        File base = dirTestStage
        if (!base.exists()) return
        def anyJava = fileTree(base) { include '**/*.java'; exclude '**/*.java.skip' }.files.any()
        if (anyJava) return

        String pkg = ''
        def srcMain = dirMain
        def anyMain = fileTree(srcMain) { include '**/*.java' }.files.find { it.text =~ /(?m)^\s*package\s+[a-zA-Z0-9_.]+\s*;/ }
        if (anyMain) {
            def m = (anyMain.text =~ /(?m)^\s*package\s+([a-zA-Z0-9_.]+)\s*;/)
            if (m.find()) pkg = m.group(1)
        }

        File dir = pkg ? new File(base, pkg.replace('.', File.separator)) : base
        dir.mkdirs()
        new File(dir, "NoOpTest.java").text = (pkg ? "package ${pkg};\n" : "") + """
            import org.junit.jupiter.api.Test;
            import static org.junit.jupiter.api.Assertions.*;
            class NoOpTest { @Test void ok() { assertTrue(true); } }
        """.stripIndent()
        println "injectNoOpTestIfNeeded ‚Üí injetado NoOpTest (para garantir .exec)."
    }
}

/* =============== Compila√ß√µes amarradas aos stages corretos =============== */
tasks.named(sourceSets.usuario.compileJavaTaskName) {
    dependsOn 'organizarUsuario', 'resolverDepsUsuario'
}
tasks.named(sourceSets.usuarioTest.compileJavaTaskName) {
    dependsOn 'organizarUsuario', 'sanearTestesUsuario', 'resolverDepsUsuario', tasks.named(sourceSets.usuario.classesTaskName)
    dependsOn 'preflightUsuarioTests', 'injectNoOpTestIfNeeded'
    options.encoding = 'UTF-8'
    options.incremental = false
    outputs.upToDateWhen { false }
}

/* ===================== Runner Test padr√£o (n√£o usado no loop) ===================== */
tasks.register('testUsuario', Test) {
    dependsOn tasks.named(sourceSets.usuario.classesTaskName),
              tasks.named(sourceSets.usuarioTest.classesTaskName)

    testClassesDirs = sourceSets.usuarioTest.output.classesDirs
    classpath       = sourceSets.usuarioTest.runtimeClasspath
    useJUnitPlatform()
    ignoreFailures = true

    jacoco { destinationFile = layout.buildDirectory.file("jacoco/testUsuario.exec").get().asFile }

    afterSuite { desc, result ->
        if (!desc.parent) {
            println "Resumo testUsuario -> total: ${result.testCount}, passaram: ${result.successfulTestCount}, falharam: ${result.failedTestCount}, skipped: ${result.skippedTestCount}"
        }
    }
    finalizedBy('jacocoRelatorioUsuario')
}

/* ==================== JaCoCo (runner padr√£o) ==================== */
jacoco { toolVersion = "0.8.12" }

tasks.register("jacocoRelatorioUsuario", JacocoReport) {
    dependsOn "testUsuario", tasks.named(sourceSets.usuario.classesTaskName)
    doFirst { executionData.from(file("$buildDir/jacoco/testUsuario.exec")) }

    sourceDirectories.from = files(
        sourceSets.main.allSource.srcDirs,
        (sourceSets.findByName("usuario")?.allSource?.srcDirs ?: []),
        file("$projectDir/entrada-usuario")
    )
    classDirectories.from = files(
        fileTree(dir: "$buildDir/classes/java/usuario", exclude: ['**/*$*']),
        fileTree(dir: "$buildDir/classes/java/main",    exclude: ['**/*$*'])
    )
    reports {
        xml.required = true; html.required = true; csv.required = false
        xml.outputLocation = file("$projectDir/entrada-usuario/jacoco-relatorio/jacoco.xml")
        html.outputLocation = file("$projectDir/entrada-usuario/jacoco-relatorio/html")
    }
    doFirst { file("$projectDir/entrada-usuario/jacoco-relatorio/html").mkdirs() }
}

tasks.register("coberturaMinimaUsuario") {
    dependsOn "jacocoRelatorioUsuarioConsole"
    doLast {
        def thr = (project.findProperty("coverageMinUsuario") ?: System.getenv("MIN_COVERAGE") ?: "0.60") as BigDecimal
        def enforce = (project.findProperty("enforceCoverage") ?: System.getenv("ENFORCE_COVERAGE") ?: "false")
                .toString().equalsIgnoreCase("true")

        def xml = file("$projectDir/entrada-usuario/jacoco-relatorio/jacoco.xml")
        if (!xml.exists() || xml.length() == 0) {
            logger.warn("coberturaMinimaUsuario ‚Üí jacoco.xml n√£o encontrado ou vazio; pulando verifica√ß√£o.")
            return
        }

        String xmlText = xml.getText("UTF-8").replaceAll("(?is)<!DOCTYPE[^>]*>", "")
        def sl = new groovy.xml.XmlSlurper(false, false).parseText(xmlText)

        long missed = 0, covered = 0
        sl.'**'.findAll { it.name() == 'counter' && it.@type?.text() == 'LINE' }.each { c ->
            missed += (c.@missed.text() as long); covered += (c.@covered.text() as long)
        }
        long total = missed + covered
        if (total == 0) { logger.warn("coberturaMinimaUsuario ‚Üí relat√≥rio sem linhas contadas; pulando verifica√ß√£o."); return }

        BigDecimal pct = (covered as BigDecimal) / (total as BigDecimal)
        def pctFmt = String.format(java.util.Locale.US, "%.2f", pct * 100)
        def thrFmt = String.format(java.util.Locale.US, "%.0f", (thr * 100))
        println "coberturaMinimaUsuario ‚Üí Cobertura de linhas: ${pctFmt}%  (threshold: ${thrFmt}%)"

        if (pct < thr) {
            if (enforce) throw new GradleException("Cobertura (${pctFmt}%) abaixo do m√≠nimo (${thrFmt}%).")
            else logger.warn("Cobertura (${pctFmt}%) abaixo do m√≠nimo (${thrFmt}%). Sinalizando apenas (n√£o-fatal).")
        }
    }
}

/* ===================== Fluxo ConsoleLauncher + JaCoCo ===================== */
tasks.register("testUsuarioConsole", JavaExec) {
    group = "verification"
    description = "Roda os testes do sourceSet usuarioTest via JUnit ConsoleLauncher (com JaCoCo)."

    dependsOn 'organizarUsuario', 'resolverDepsUsuario',
              tasks.named(sourceSets.usuario.classesTaskName),
              tasks.named(sourceSets.usuarioTest.classesTaskName)

    mainClass = 'org.junit.platform.console.ConsoleLauncher'
    classpath = sourceSets.usuarioTest.runtimeClasspath

    args '--scan-class-path'
    args '--include-engine', 'junit-jupiter'
    args '--details', 'summary'
    ignoreExitValue = true
    jvmArgs '-Dfile.encoding=UTF-8'

    doFirst {
        file("$buildDir/jacoco").mkdirs()
        try {
            def agent = configurations.jacocoAgentRuntime.singleFile
            if (agent == null || !agent.exists()) {
                logger.lifecycle("testUsuarioConsole ‚Üí agente JaCoCo n√£o encontrado; rodando sem cobertura.")
            } else {
                def dest  = file("$buildDir/jacoco/testUsuarioConsole.exec").absolutePath
                jvmArgs "-javaagent:${agent.absolutePath}=destfile=${dest},append=true,output=file,inclnolocationclasses=false,includes=*"
            }
        } catch (Throwable t) {
            logger.lifecycle("testUsuarioConsole ‚Üí falha ao injetar JaCoCo: ${t.class.simpleName}: ${t.message}. Seguindo sem cobertura.")
        }
    }
    doLast {
        def exec = file("$buildDir/jacoco/testUsuarioConsole.exec")
        println "testUsuarioConsole ‚Üí exec: ${exec.exists() ? exec.length() + ' bytes' : 'n√£o gerado'}"
    }
    standardInput = System.in
}

tasks.register("jacocoRelatorioUsuarioConsole", JacocoReport) {
    group = "verification"
    description = "Gera relat√≥rio JaCoCo para a execu√ß√£o do ConsoleLauncher."
    dependsOn "testUsuarioConsole"
    mustRunAfter "testUsuarioConsole"

    executionData.from(file("$buildDir/jacoco/testUsuarioConsole.exec"))

    doFirst {
        def exec = file("$buildDir/jacoco/testUsuarioConsole.exec")
        if (!exec.exists() || exec.length()==0) {
            logger.lifecycle("jacocoRelatorioUsuarioConsole ‚Üí sem execution data; relat√≥rio pode ficar vazio.")
        }
        file("$projectDir/entrada-usuario/jacoco-relatorio/html").mkdirs()
    }

    sourceDirectories.from = files(
        sourceSets.main.allSource.srcDirs,
        (sourceSets.findByName("usuario")?.allSource?.srcDirs ?: []),
        file("$projectDir/entrada-usuario")
    )
    classDirectories.from = files(
        fileTree(dir: "$buildDir/classes/java/usuario", exclude: ['**/*$*']),
        fileTree(dir: "$buildDir/classes/java/main",    exclude: ['**/*$*'])
    )
    reports {
        xml.required = true; html.required = true; csv.required = false
        xml.outputLocation = file("$projectDir/entrada-usuario/jacoco-relatorio/jacoco.xml")
        html.outputLocation = file("$projectDir/entrada-usuario/jacoco-relatorio/html")
    }
}

tasks.register("jacocoXmlGarantido") {
    doLast {
        def xml = file("$projectDir/entrada-usuario/jacoco-relatorio/jacoco.xml")
        if (!xml.exists() || xml.length() == 0) {
            xml.parentFile.mkdirs()
            xml.text = '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<report name="empty">
  <sessioninfo id="none" start="0" dump="0"/>
  <counter type="INSTRUCTION" missed="0" covered="0"/>
  <counter type="LINE" missed="0" covered="0"/>
  <counter type="COMPLEXITY" missed="0" covered="0"/>
  <counter type="METHOD" missed="0" covered="0"/>
  <counter type="CLASS" missed="0" covered="0"/>
</report>
'''
            println "jacocoXmlGarantido ‚Üí jacoco.xml vazio (sem exec) ‚Äî fallback para Codecov."
        }
    }
}

/* ---------------- Helper: roda uma task Gradle isolada sem derrubar build ---------------- */
ext.runGradleOnce = { String taskName, Object... args ->
    def out = new ByteArrayOutputStream()
    def err = new ByteArrayOutputStream()
    def cmd = ["./gradlew", taskName] + (args as List<String>)
    def res = project.exec {
        workingDir project.rootDir
        commandLine cmd
        ignoreExitValue = true
        standardOutput = out
        errorOutput    = err
    }
    def diagDir = file("$projectDir/entrada-usuario/diagnosticos"); diagDir.mkdirs()
    def safe = taskName.replace(':','_')
    new File(diagDir, "${safe}.log").text = out.toString("UTF-8") + err.toString("UTF-8")
    return res.exitValue == 0
}

/* ---------------- üöÄ covUsuario: 1 rodada completa ---------------- */
tasks.register("covUsuario") {
    doLast {
        if (!runGradleOnce(":app:organizarUsuario")) throw new GradleException("Falha em organizarUsuario")
        if (!runGradleOnce(":app:resolverDepsUsuario")) throw new GradleException("Falha em resolverDepsUsuario")

        def ok = runGradleOnce(":app:compileUsuarioJava")
        if (!ok) {
            file("$projectDir/entrada-usuario/diagnosticos").mkdirs()
            runGradleOnce(":app:ajustarTestesIa", "--modo=fix_main")
            ok = runGradleOnce(":app:compileUsuarioJava")
            if (!ok) throw new GradleException("Falha ao compilar c√≥digo do usu√°rio mesmo ap√≥s fix_main.")
        }

        if (!runGradleOnce(":app:sanearTestesUsuario")) throw new GradleException("Falha em sanearTestesUsuario")
        if (!runGradleOnce(":app:preflightUsuarioTests")) throw new GradleException("Falha em preflightUsuarioTests")
        runGradleOnce(":app:injectNoOpTestIfNeeded")
        if (!runGradleOnce(":app:compileUsuarioTestJava")) throw new GradleException("Falha em compileUsuarioTestJava")

        runGradleOnce(":app:testUsuarioConsole")
        runGradleOnce(":app:jacocoRelatorioUsuarioConsole")
        runGradleOnce(":app:jacocoXmlGarantido")
    }
    finalizedBy "jacocoXmlGarantido"
}

/// ===== Loop resiliente: para ao gerar jacoco != empty (e opcionalmente cobre >= MIN_COVERAGE) =====
tasks.register("covUsuarioLoop") {
    group = "verification"
    description = "Tenta at√© gerar jacoco.xml com cobertura > 0; para na 1¬™ vez que conseguir."

    doLast {
        int maxTentativas = (System.getenv("COV_MAX_ATTEMPTS") ?: "5") as int
        BigDecimal thr = (System.getenv("MIN_COVERAGE") ?: "0.00") as BigDecimal  // 0.00 = s√≥ precisa ter algo
        boolean enforce = (System.getenv("ENFORCE_COVERAGE") ?: "false").toString().equalsIgnoreCase("true")

        File xml = file("$projectDir/entrada-usuario/jacoco-relatorio/jacoco.xml")

        for (int i = 1; i <= maxTentativas; i++) {
            println "== Tentativa ${i}/${maxTentativas} =="

            // 1) organiza/resolve/compila/roda testes instrumentados + gera relat√≥rio
            exec {
                commandLine "./gradlew", ":app:covUsuario"
                ignoreExitValue = true   // <<<<<<<<<< AQUI (corrigido)
            }

            boolean temContagem = false
            BigDecimal pct = 0.0

            if (xml.exists() && xml.length() > 0) {
                String xmlText = xml.getText("UTF-8").replaceAll("(?is)<!DOCTYPE[^>]*>", "")
                def sl = new groovy.xml.XmlSlurper(false, false).parseText(xmlText)
                long missed = 0, covered = 0
                sl.'**'.findAll { it.name() == 'counter' && it.@type?.text() == 'LINE' }.each { c ->
                    missed += (c.@missed.text() as long)
                    covered += (c.@covered.text() as long)
                }
                long total = missed + covered
                temContagem = (total > 0 && covered > 0)
                if (total > 0) pct = (covered as BigDecimal) / (total as BigDecimal)
            }

            if (temContagem) {
                String pctFmt = String.format(java.util.Locale.US, "%.2f", pct * 100)
                println "‚úÖ Cobertura gerada: ${pctFmt}%"
                if (pct >= thr || !enforce) {
                    println "üèÅ Parando o loop (crit√©rio satisfeito)."
                    return
                } else {
                    println "‚ö†Ô∏è Abaixo do m√≠nimo (${thr*100}%). Tentando melhorar com patches‚Ä¶"
                }
            } else {
                println "‚ùå Relat√≥rio vazio/sem linhas cobertas. Pedindo patches‚Ä¶"
            }

            // 2) pedir patches para IA (tolerante a erro/429)
            try {
                exec {
                    commandLine "./gradlew", ":app:ajustarTestesIa"
                    ignoreExitValue = true   // <<<<<<<<<< E AQUI (corrigido)
                }
            } catch (Throwable t) {
                println "IA falhou (${t.class.simpleName}): seguindo para pr√≥xima tentativa."
            }
        }

        println "üîö Loop esgotado; se ainda n√£o h√° cobertura suficiente, verifique logs/patches em 'entrada-usuario/testes_ai_patches/'."
    }
}


/* ===================== Relat√≥rio geral (merge) ===================== */
def _configJacocoRelatorioGeral = { JacocoReport t ->
    t.dependsOn(tasks.findByName("test"), tasks.findByName("testUsuario"))
    t.executionData fileTree(projectDir) { include "**/build/jacoco/*.exec", "**/jacoco/*.exec" }
    t.sourceDirectories.from = files(
        sourceSets.main.allSource.srcDirs,
        (sourceSets.findByName("usuario")?.allSource?.srcDirs ?: []),
        file("$projectDir/entrada-usuario")
    )
    t.classDirectories.from = files(
        fileTree(dir: "$buildDir/classes/java/main"),
        fileTree(dir: "$buildDir/classes/java/usuario")
    )
    t.reports {
        xml.required = true; html.required = true; csv.required = false
        html.outputLocation = layout.buildDirectory.dir("reports/jacoco/geral").get().asFile
    }
}
if (tasks.findByName("jacocoRelatorioGeral") != null) {
    tasks.named("jacocoRelatorioGeral", JacocoReport).configure { _configJacocoRelatorioGeral(it) }
} else {
    tasks.register("jacocoRelatorioGeral", JacocoReport) { _configJacocoRelatorioGeral(it) }
}
tasks.named("jacocoRelatorioUsuario") { finalizedBy("jacocoRelatorioGeral") }
tasks.named("jacocoRelatorioUsuarioConsole") { finalizedBy("coberturaMinimaUsuario") }

tasks.register('usuarioCobertura') { dependsOn 'testUsuario' }

tasks.withType(Test).configureEach {
    useJUnitPlatform()
    testLogging {
        events "passed","skipped","failed"
        showStandardStreams = false
        exceptionFormat "short"
    }
}

tasks.withType(JavaExec).configureEach {
    environment 'JAVA_TOOL_OPTIONS', '-Dfile.encoding=UTF-8'
}

tasks.named('test') { useJUnitPlatform() }

/* ========= EXTRA: pacote zip com payload p/ IA ========= */
tasks.register("gerarPacoteParaIA", Zip) {
    group = "verification"
    description = "Empacota fontes/testes/relat√≥rios para a IA ajustar testes."
    dependsOn "jacocoRelatorioUsuarioConsole"

    archiveBaseName.set("payload-ia")
    destinationDirectory.set(layout.buildDirectory.dir("ia_payload"))

    from("$buildDir/usuario-src/src/main/java") { into("src_main_staged") }
    from("$buildDir/usuario-src/src/test_raw/java") { into("tests_raw_stage") }
    from("$buildDir/usuario-src/src/test/java") { into("tests_stage") }

    from("$projectDir/entrada-usuario") {
        include '**/*.java', '**/*.txt'
        into("entrada_usuario_raw")
    }
    from("$projectDir/entrada-usuario/testes_ai_patches") { into("tests_ai_patches") }
    from("$projectDir/entrada-usuario/testes_explica√ß√µes") { into("tests_ia_explicacoes") }
    from("$projectDir/entrada-usuario/jacoco-relatorio") { include 'jacoco.xml', 'html/**'; into("jacoco") }
    from("$buildDir/reports/problems") { include 'problems-report.html'; into("problems") }
}
tasks.register("covUsuarioComPayload") { dependsOn "covUsuario", "gerarPacoteParaIA" }

/* --- Orquestra√ß√£o final entre organizarUsuario e resolverDepsUsuario --- */
tasks.named('organizarUsuario') {
    dependsOn 'resolverDepsUsuario'
    inputs.dir("$projectDir/entrada-usuario/libs")
    notCompatibleWithConfigurationCache("Organiza fontes dinamicamente e l√™ sa√≠das de outras tasks")
}
tasks.named('resolverDepsUsuario') {
    notCompatibleWithConfigurationCache("Cria detachedConfiguration em tempo de execu√ß√£o")
}
