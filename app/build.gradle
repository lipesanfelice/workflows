plugins {
    id 'java'
    id 'application'
    id 'jacoco'
    id "org.sonarqube" version "6.2.0.5505"
    id 'org.springframework.boot' version '3.3.2'
    id 'io.spring.dependency-management' version '1.1.5'
}

import org.gradle.testing.jacoco.plugins.JacocoTaskExtension
repositories {
    mavenCentral()
}

dependencies {
    // Testes
    testImplementation libs.junit.jupiter
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    // Utilitários
    implementation libs.guava
    implementation 'org.json:json:20240303'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.17.1'
    implementation 'commons-io:commons-io:2.16.1'

    // Spring Boot Web
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-validation'

    // Testes Spring Boot
    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    testImplementation platform('org.junit:junit-bom:5.10.2')
    testImplementation 'org.junit.jupiter:junit-jupiter'
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

application {
    mainClass = 'org.example.web.WebApplication'
}

springBoot {
    mainClass = 'org.example.web.WebApplication' 
}


sonar {
    properties {
        property "sonar.projectKey", "lipesanfelice_workflows"
        property "sonar.organization", "lipesanfelice"
        property "sonar.host.url", "https://sonarcloud.io"
        property "sonar.token", System.getenv("SONAR_TOKEN")

        // 👇 fontes analisadas = APENAS a pasta entrada-usuario
        property "sonar.sources", "entrada-usuario"
        property "sonar.inclusions", "entrada-usuario/**/*.java"

        property "sonar.tests", "src/test/java"
        property "sonar.java.binaries", "build/classes/java/main"
        property "sonar.junit.reportPaths", "build/test-results/test"
        property "sonar.coverage.jacoco.xmlReportPaths", "build/reports/jacoco/test/jacocoTestReport.xml"
    }
}

tasks.register('salvarRelatorioSonar', JavaExec) {
    group = 'sonar'
    mainClass = 'org.example.util.SonarRelatorioCli'
    classpath = sourceSets.main.runtimeClasspath
    args "lipesanfelice_workflows", System.getenv('SONAR_TOKEN') ?: '', "$projectDir/entrada-usuario/relatorio-sonar.json"
}

// app/build.gradle
tasks.register('gerarTestesIa', JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'org.example.web.cli.GerarTestesCli'
}

configurations {
    usuarioImplementation.extendsFrom implementation
    usuarioRuntimeOnly.extendsFrom runtimeOnly
    usuarioTestImplementation.extendsFrom testImplementation
    usuarioTestRuntimeOnly.extendsFrom testRuntimeOnly
}

def dirEntrada = file('entrada-usuario')
def dirTestsIA = file('entrada-usuario/testes_explicações/tests')
def dirWork = layout.buildDirectory.dir('usuario-src').get().asFile
def dirMain = new File(dirWork, 'src/main/java')
def dirTest = new File(dirWork, 'src/test/java')


// Mapeia imports -> coordenadas Maven padrão (ajuste versões se quiser)
def mapaImports = [
    'org.apache.commons.lang3'         : 'org.apache.commons:commons-lang3:3.14.0',
    'org.apache.commons.io'            : 'commons-io:commons-io:2.16.1',
    'com.google.gson'                  : 'com.google.code.gson:gson:2.11.0',
    'com.google.common'                : 'com.google.guava:guava:33.2.1-jre',
    'org.json'                         : 'org.json:json:20240303',
    'com.fasterxml.jackson.databind'   : 'com.fasterxml.jackson.core:jackson-databind:2.17.1',
    'com.fasterxml.jackson.core'       : 'com.fasterxml.jackson.core:jackson-core:2.17.1',
    'com.fasterxml.jackson.annotation' : 'com.fasterxml.jackson.core:jackson-annotations:2.17.1',
    'org.slf4j'                        : 'org.slf4j:slf4j-api:2.0.13',
    'ch.qos.logback'                   : 'ch.qos.logback:logback-classic:1.5.6',
    'org.apache.http'                  : 'org.apache.httpcomponents.client5:httpclient5:5.3.1',
    'org.jsoup'                        : 'org.jsoup:jsoup:1.18.1',
    'org.hibernate'                    : 'org.hibernate.orm:hibernate-core:6.5.3.Final',
    'jakarta.persistence'              : 'jakarta.persistence:jakarta.persistence-api:3.1.0',
    'jakarta.validation'               : 'jakarta.validation:jakarta.validation-api:3.0.2',
    'org.apache.poi'                   : 'org.apache.poi:poi-ooxml:5.2.5'
]

tasks.register('resolverDepsUsuario') {
    // varre fontes do usuário
    inputs.files(fileTree(dirEntrada) { include '**/*.java' })

    // deps.txt opcional
    inputs.files(provider {
        def f = file('entrada-usuario/deps.txt')
        f.exists() ? [f] : []
    })

    // vendor/*.jar opcional (use files, não dir)
    inputs.files(provider {
        def v = file('entrada-usuario/vendor')
        v.exists() ? fileTree(v) { include '*.jar' } : []
    })

    outputs.dir(file('entrada-usuario/libs'))

    doLast {
        def libsDir = file('entrada-usuario/libs')
        libsDir.mkdirs()

        // 1) JARs locais do usuário
        def vendorDir = file('entrada-usuario/vendor')
        if (vendorDir.exists()) {
            copy {
                from(vendorDir)
                include '*.jar'
                into libsDir
            }
        }

        // 2) deps.txt (coordenadas explícitas)
        def coords = [] as Set
        def depsTxt = file('entrada-usuario/deps.txt')
        if (depsTxt.exists()) {
            depsTxt.readLines('UTF-8').each { line ->
                def s = line.trim()
                if (s && !s.startsWith('#')) coords << s
            }
        }

        // 3) Heurística por imports
        def imports = [] as Set
        fileTree(dirEntrada) { include '**/*.java' }.each { f ->
            f.eachLine('UTF-8') { l ->
                def m = (l =~ /^\s*import\s+([a-zA-Z0-9_.]+)\./)
                if (m.find()) imports << m.group(1)
            }
        }
        imports.each { pkg ->
            mapaImports.findAll { k, v -> pkg.startsWith(k) }.each { k, v -> coords << v }
        }

        // 4) Resolve e copia jars
        if (!coords.isEmpty()) {
            def depObjs = coords.collect { dependencies.create(it) } as org.gradle.api.artifacts.Dependency[]
            def conf = configurations.detachedConfiguration(depObjs)
            conf.setTransitive(true)
            def filesResolved = conf.resolve()
            copy {
                from filesResolved
                into libsDir
            }
        }

        new File(libsDir, 'RESOLVIDO.txt').setText((coords.join('\n') + '\n'), 'UTF-8')
        println "resolverDepsUsuario → libs geradas em ${libsDir} (${coords.size()} coords)"
    }
}

tasks.register('organizarUsuario') {
    inputs.files(fileTree(dirEntrada) { include '**/*.java' })
    inputs.files(fileTree(dirTestsIA) { include '**/*.java' })
    outputs.dir(dirWork)

    doLast {
        if (dirWork.exists()) {
            dirWork.deleteDir()
        }
        dirMain.mkdirs()
        dirTest.mkdirs()

        // helpers
        def extrairPacote = { String src ->
            def m = (src =~ /(?m)^\s*package\s+([a-zA-Z0-9_.]+)\s*;/)
            m.find() ? m.group(1) : ''
        }
        def extrairNomePublico = { String src ->
            def m = (src =~ /(?m)^\s*public\s+(?:class|interface|enum|record)\s+([A-Za-z_][A-Za-z0-9_]*)\b/)
            m.find() ? m.group(1) : null
        }
        def classesReferenciadasEmTestes = { String src ->
            def ignora = [
                'Assertions','Assert','System','Math','Objects','List','ArrayList','Arrays',
                'Collections','Stream','Optional','Files','Paths','Mockito','Matchers','Pattern','Matcher'
            ] as Set
            def nomes = [] as Set
            def pat = ~/(?m)([A-Z][A-Za-z0-9_]*)\s*\.\s*[A-Za-z_][A-Za-z0-9_]*\s*\(/
            def matcher = pat.matcher(src)
            while (matcher.find()) {
                def c = matcher.group(1)
                if (!ignora.contains(c)) nomes << c
            }
            return nomes
        }

        // Carrega tudo
        def fontesUsuario = []
        def testesIA = []
        inputs.files.files.each { File origem ->
            boolean isTeste = origem.toPath().startsWith(dirTestsIA.toPath())
            String texto = origem.getText('UTF-8')
            (isTeste ? testesIA : fontesUsuario) << [file: origem, text: texto]
        }

        // Detecta pacote(s) do usuário
        def pacotesUsuario = fontesUsuario.collect { extrairPacote(it.text) }.toSet()
        String pacoteUsuario = (pacotesUsuario.size() == 1) ? pacotesUsuario.first() : ''  // se múltiplos, tratamos como default

        // Renome de classe pública se teste espera outro nome
        def nomesPublicosUsuario = fontesUsuario.collect { extrairNomePublico(it.text) }.findAll { it }
        def nomesReferenciadosTestes = classesReferenciadasEmTestes(testesIA.collect { it.text }.join("\n"))
        String nomePublico = (nomesPublicosUsuario ?: [null]).first()
        String nomeEsperado = (nomesReferenciadosTestes ?: [null]).first()
        boolean deveRenomear = (nomePublico && nomeEsperado && nomePublico != nomeEsperado &&
                                nomesPublicosUsuario.size()==1 && nomesReferenciadosTestes.size()==1)

        if (deveRenomear) {
            fontesUsuario = fontesUsuario.collect { f ->
                if (extrairNomePublico(f.text) == nomePublico) {
                    def novoTexto = f.text.replaceFirst(
                        /(?m)(^\s*public\s+(?:class|interface|enum|record)\s+)${java.util.regex.Pattern.quote(nomePublico)}\b/,
                        "\$1${nomeEsperado}"
                    )
                    [file: f.file, text: novoTexto]
                } else {
                    f
                }
            }
            println "organizarUsuario → renomeado classe pública '${nomePublico}' → '${nomeEsperado}' para alinhar com os testes"
        }

        // ---- dentro de organizarUsuario { ... } substitua a função ajustarTesteParaPacoteUsuario por esta: ----
        def ajustarTesteParaPacoteUsuario = { String texto ->
            // 1) alinhar pacote
            String pkgTeste = extrairPacote(texto)
            if (pacoteUsuario == '') {
                // Usuário no default package → remover package dos testes
                texto = texto.replaceFirst(/(?m)^\s*package\s+[^;]+;\s*/, '')
            } else {
                if (pkgTeste == '') {
                    // teste sem package → coloca o MESMO package do usuário
                    texto = "package ${pacoteUsuario};\n" + texto
                    pkgTeste = pacoteUsuario
                } else {
                    // teste já tem package → injeta import * se ainda não tiver
                    if (!texto.contains("import ${pacoteUsuario}.")) {
                        texto = texto.replaceFirst(/(?m)^(package\s+[^;]+;\s*)/, "\$1\nimport ${pacoteUsuario}.*;\n")
                    }
                }
            }

            // 2) injetar imports JDK comuns se faltarem
            // símbolos que frequentemente aparecem nos testes gerados
            def candidatos = [
                [sym: 'Random',      fqcn: 'java.util.Random'],
                [sym: 'Arrays',      fqcn: 'java.util.Arrays'],
                [sym: 'List',        fqcn: 'java.util.List'],
                [sym: 'ArrayList',   fqcn: 'java.util.ArrayList'],
                [sym: 'Map',         fqcn: 'java.util.Map'],
                [sym: 'HashMap',     fqcn: 'java.util.HashMap'],
                [sym: 'Set',         fqcn: 'java.util.Set'],
                [sym: 'HashSet',     fqcn: 'java.util.HashSet'],
                [sym: 'Collections', fqcn: 'java.util.Collections'],
                [sym: 'Optional',    fqcn: 'java.util.Optional'],
                // às vezes usam Regex sem import:
                [sym: 'Pattern',     fqcn: 'java.util.regex.Pattern'],
                [sym: 'Matcher',     fqcn: 'java.util.regex.Matcher'],
            ]

            // já importados?
            def importados = [] as Set
            def impMatcher = (texto =~ /(?m)^\s*import\s+([a-zA-Z0-9_.]+)\s*;/)
            while (impMatcher.find()) {
                importados << impMatcher.group(1)
            }


            // montar lista de imports a inserir
            def paraInserir = []
            candidatos.each { c ->
                // se o símbolo aparece “desqualificado” (ex.: Random em vez de java.util.Random)
                def usaSimbolo = (texto =~ /\b${c.sym}\b/).find()
                def jaTemImportDireto = importados.contains(c.fqcn)
                def jaTemWildcard = importados.any { it == c.fqcn.replaceAll(/\.[^.]+$/, '.*') } // ex.: java.util.*
                def jaUsaQualificado = (texto =~ /\b${java.util.regex.Pattern.quote(c.fqcn)}\b/).find()
                if (usaSimbolo && !jaTemImportDireto && !jaTemWildcard && !jaUsaQualificado) {
                    paraInserir << "import ${c.fqcn};"
                    importados << c.fqcn
                }
            }

            if (!paraInserir.isEmpty()) {
                if ((texto =~ /(?m)^\s*package\s+[^;]+;\s*$/).find()) {
                    // há package → insere após o package
                    texto = texto.replaceFirst(/(?m)^(package\s+[^;]+;\s*)/, "\$1\n" + paraInserir.join("\n") + "\n")
                } else {
                    // sem package → insere no topo
                    texto = paraInserir.join("\n") + "\n" + texto
                }
            }

            return texto
        }


        // Gravar arquivos
        def gravar = { String texto, boolean isTeste ->
            if (isTeste) {
                texto = ajustarTesteParaPacoteUsuario(texto)
            }
            String pacote = extrairPacote(texto)
            String caminhoPacote = pacote ? pacote.replace('.', File.separator) : ''
            File baseDestino = isTeste ? dirTest : dirMain
            File destinoDir = caminhoPacote ? new File(baseDestino, caminhoPacote) : baseDestino
            destinoDir.mkdirs()

            String nomePublicoLocal = extrairNomePublico(texto)
            String nomeArquivo = nomePublicoLocal ? "${nomePublicoLocal}.java" : "Arquivo_${System.nanoTime()}.java"
            new File(destinoDir, nomeArquivo).setText(texto, 'UTF-8')
        }

        // Grava tudo
        fontesUsuario.each { gravar(it.text, false) }
        testesIA.each     { gravar(it.text, true)  }

        // --- [INÍCIO: injeção condicional de stubs do modelo] ---
        def modeloPkgPath = new File(dirMain, "org/example/model")
        def modeloJaExiste = { String nome ->
            // existe no build?
            def f1 = new File(modeloPkgPath, "${nome}.java")
            if (f1.exists()) return true
            // existe no código do usuário?
            return fileTree(dirEntrada) {
                include "**/${nome}.java"
            }.any { it.text.contains("package org.example.model") }
        }

        // analisamos somente se usuário/testes referem algo do modelo
        def allText = (fontesUsuario.collect{it.text} + testesIA.collect{it.text}).join("\n")
        def precisaRel   = allText.contains("RelatorioCobertura") && !modeloJaExiste("RelatorioCobertura")
        def precisaClasse= allText.contains("ClasseCoberta")      && !modeloJaExiste("ClasseCoberta")
        def precisaMetodo= allText.contains("MetodoCoberto")      && !modeloJaExiste("MetodoCoberto")

        if (precisaRel || precisaClasse || precisaMetodo) {
            modeloPkgPath.mkdirs()

            if (precisaMetodo) {
                new File(modeloPkgPath, "MetodoCoberto.java").setText("""
                    package org.example.model;
                    public record MetodoCoberto(String nome, int linhaInicio, int linhaFim, double cobertura) {}
                """.stripIndent(), "UTF-8")
            }

            if (precisaClasse) {
                new File(modeloPkgPath, "ClasseCoberta.java").setText("""
                    package org.example.model;
                    import java.util.List;
                    public record ClasseCoberta(String nome, String caminho, List<MetodoCoberto> metodos) {}
                """.stripIndent(), "UTF-8")
            }

            if (precisaRel) {
                new File(modeloPkgPath, "RelatorioCobertura.java").setText("""
                    package org.example.model;
                    import java.util.List;
                    public final class RelatorioCobertura {
                        public enum Ferramenta { JACOCO, OUTRA }
                        private final String caminhoRelatorio;
                        private final List<ClasseCoberta> classes;
                        private final Ferramenta ferramenta;
                        public RelatorioCobertura(String caminhoRelatorio, List<ClasseCoberta> classes, Ferramenta ferramenta) {
                            this.caminhoRelatorio = caminhoRelatorio;
                            this.classes = classes;
                            this.ferramenta = ferramenta;
                        }
                        public String caminhoRelatorio() { return caminhoRelatorio; }
                        public List<ClasseCoberta> classes() { return classes; }
                        public Ferramenta ferramenta() { return ferramenta; }
                    }
                """.stripIndent(), "UTF-8")
            }

            println "organizarUsuario → stubs injetados em org.example.model: " +
                    [(precisaMetodo?'MetodoCoberto':null),(precisaClasse?'ClasseCoberta':null),(precisaRel?'RelatorioCobertura':null)]
                    .findAll{it!=null}.join(", ")
        }
        // --- [FIM: injeção condicional de stubs do modelo] ---

        println "organizarUsuario → copiado para main: ${dirMain.absolutePath}"
        println "organizarUsuario → copiado para test: ${dirTest.absolutePath}"
        println "organizarUsuario → fontes recebidos: ${fontesUsuario.size()}"
        println "organizarUsuario → testes recebidos:  ${testesIA.size()}"
        if (nomePublico)  println "organizarUsuario → nome público (usuario): ${nomePublico}"
        if (nomeEsperado) println "organizarUsuario → nome esperado (testes): ${nomeEsperado}"
        if (pacoteUsuario) println "organizarUsuario → pacote do usuário detectado: ${pacoteUsuario}"
    }
}


sourceSets {
    usuario {
        java {
            srcDirs = [dirMain]
        }
        resources.srcDirs = []
    }
    usuarioTest {
        java {
            srcDirs = [dirTest]
        }
        resources.srcDirs = []
        compileClasspath += sourceSets.usuario.output
        runtimeClasspath  += sourceSets.usuario.output
    }
}

// compila main só depois de organizar e resolver libs
tasks.named(sourceSets.usuario.compileJavaTaskName) {
    dependsOn 'organizarUsuario', 'resolverDepsUsuario'
}

// compila testes só depois de organizar, resolver libs e compilar main
tasks.named(sourceSets.usuarioTest.compileJavaTaskName) {
    dependsOn 'organizarUsuario', 'resolverDepsUsuario', tasks.named(sourceSets.usuario.classesTaskName)
}


tasks.register('testUsuario', Test) {
    dependsOn tasks.named(sourceSets.usuario.classesTaskName),
              tasks.named(sourceSets.usuarioTest.classesTaskName)

    testClassesDirs = sourceSets.usuarioTest.output.classesDirs
    classpath       = sourceSets.usuarioTest.runtimeClasspath
    useJUnitPlatform()

    // NÃO derrubar o build se testes falharem (para o JaCoCo rodar)
    ignoreFailures = true

    // .exec fixo
    jacoco {
        destinationFile = layout.buildDirectory.file("jacoco/testUsuario.exec").get().asFile
    }

    // log resumido
    afterSuite { desc, result ->
        if (!desc.parent) {
            println "Resumo testUsuario -> total: ${result.testCount}, " +
                    "passaram: ${result.successfulTestCount}, " +
                    "falharam: ${result.failedTestCount}, " +
                    "skipped: ${result.skippedTestCount}"
        }
    }

    finalizedBy 'jacocoRelatorioUsuario'
}


jacoco {
    toolVersion = '0.8.12'
}

def jacocoExecProv = layout.buildDirectory.file("jacoco/testUsuario.exec")

tasks.register('jacocoRelatorioUsuario', JacocoReport) {
    dependsOn 'testUsuario'

    // só roda se existir o .exec
    onlyIf { jacocoExecProv.get().asFile.exists() }

    // arquivo .exec do testUsuario
    executionData.setFrom(jacocoExecProv)

    // classes compiladas do sourceSet "usuario"
    classDirectories.setFrom(sourceSets.usuario.output.classesDirs)

    // ⚠️ fontes apontando para o repo para o Codecov mapear corretamente
    sourceDirectories.setFrom(files('entrada-usuario'))

    reports {
        xml.required.set(true)
        html.required.set(true)
        csv.required.set(false)
        html.outputLocation.set(file('entrada-usuario/jacoco-relatorio/html'))
        xml.outputLocation.set(file('entrada-usuario/jacoco-relatorio/jacoco.xml'))
    }

    doFirst {
        file('entrada-usuario/jacoco-relatorio').mkdirs()
        file('entrada-usuario/jacoco-relatorio/html').mkdirs()
    }
}



tasks.register('usuarioCobertura') {
    dependsOn 'testUsuario'
}

tasks.withType(Test).configureEach {
    testLogging {
        events "FAILED", "SKIPPED"
        exceptionFormat "full"
        showStandardStreams = false
    }
}

dependencies {
    usuarioTestImplementation platform('org.junit:junit-bom:5.10.2')
    usuarioTestImplementation 'org.junit.jupiter:junit-jupiter'
    usuarioTestRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    usuarioImplementation fileTree('entrada-usuario/libs') { include '*.jar' }
    testImplementation 'org.mockito:mockito-core:5.13.0'
}

tasks.withType(JavaExec).configureEach {
    environment 'JAVA_TOOL_OPTIONS', '-Dfile.encoding=UTF-8'
}

tasks.named('test') {
    useJUnitPlatform()
}
