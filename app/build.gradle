// plugins {
//     id 'java'
//     id 'application'
//     id 'jacoco'
//     id "org.sonarqube" version "6.2.0.5505"
//     id 'org.springframework.boot' version '3.3.2'
//     id 'io.spring.dependency-management' version '1.1.5'
// }

// import org.gradle.testing.jacoco.plugins.JacocoTaskExtension
// import java.util.regex.Pattern
// repositories {
//     mavenCentral()
// }

// dependencies {
//     // Testes
//     testImplementation libs.junit.jupiter
//     testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

//     // Utilit√°rios
//     implementation libs.guava
//     implementation 'org.json:json:20240303'
//     implementation 'com.fasterxml.jackson.core:jackson-databind:2.17.1'
//     implementation 'commons-io:commons-io:2.16.1'

//     // Spring Boot Web
//     implementation 'org.springframework.boot:spring-boot-starter-web'
//     implementation 'org.springframework.boot:spring-boot-starter-validation'

//     // Testes Spring Boot
//     testImplementation 'org.springframework.boot:spring-boot-starter-test'

//     testImplementation platform('org.junit:junit-bom:5.10.2')
//     testImplementation 'org.junit.jupiter:junit-jupiter'
// }

// tasks.withType(Test).configureEach {
//     useJUnitPlatform()
// }

// java {
//     toolchain {
//         languageVersion = JavaLanguageVersion.of(21)
//     }
// }

// application {
//     mainClass = 'org.example.web.WebApplication'
// }

// springBoot {
//     mainClass = 'org.example.web.WebApplication' 
// }


// sonar {
//     properties {
//         property "sonar.projectKey", "lipesanfelice_workflows"
//         property "sonar.organization", "lipesanfelice"
//         property "sonar.host.url", "https://sonarcloud.io"
//         property "sonar.token", System.getenv("SONAR_TOKEN")

//         // üëá fontes analisadas = APENAS a pasta entrada-usuario
//         property "sonar.sources", "entrada-usuario"
//         property "sonar.inclusions", "entrada-usuario/**/*.java"

//         property "sonar.tests", "src/test/java"
//         property "sonar.java.binaries", "build/classes/java/main"
//         property "sonar.junit.reportPaths", "build/test-results/test"
//         property "sonar.coverage.jacoco.xmlReportPaths", "build/reports/jacoco/test/jacocoTestReport.xml"
//     }
// }

// tasks.register('salvarRelatorioSonar', JavaExec) {
//     group = 'sonar'
//     mainClass = 'org.example.util.SonarRelatorioCli'
//     classpath = sourceSets.main.runtimeClasspath
//     args "lipesanfelice_workflows", System.getenv('SONAR_TOKEN') ?: '', "$projectDir/entrada-usuario/relatorio-sonar.json"
// }

// // app/build.gradle
// tasks.register('gerarTestesIa', JavaExec) {
//     classpath = sourceSets.main.runtimeClasspath
//     mainClass = 'org.example.web.cli.GerarTestesCli'
// }

// configurations {
//     usuarioImplementation.extendsFrom implementation
//     usuarioRuntimeOnly.extendsFrom runtimeOnly
//     usuarioTestImplementation.extendsFrom testImplementation
//     usuarioTestRuntimeOnly.extendsFrom testRuntimeOnly
// }

// def dirEntrada = file('entrada-usuario')
// def dirTestsIA = file('entrada-usuario/testes_explica√ß√µes/tests')
// def dirTestsUsuario = file('entrada-usuario/testes')
// def dirWork = layout.buildDirectory.dir('usuario-src').get().asFile
// def dirMain = new File(dirWork, 'src/main/java')
// def dirTest = new File(dirWork, 'src/test/java')


// // Mapeia imports -> coordenadas Maven padr√£o (vers√µes est√°veis p/ Java 21 / Spring Boot 3.x)
// def mapaImports = [
//     // === Apache Commons ===
//     'org.apache.commons.lang3'         : 'org.apache.commons:commons-lang3:3.14.0',
//     'org.apache.commons.io'            : 'commons-io:commons-io:2.16.1',
//     'org.apache.commons.text'          : 'org.apache.commons:commons-text:1.11.0',
//     'org.apache.commons.collections4'  : 'org.apache.commons:commons-collections4:4.4',
//     'org.apache.commons.csv'           : 'org.apache.commons:commons-csv:1.10.0',
//     'org.apache.commons.codec'         : 'commons-codec:commons-codec:1.16.1',
//     'org.apache.commons.compress'      : 'org.apache.commons:commons-compress:1.26.2',
//     'org.apache.commons.math3'         : 'org.apache.commons:commons-math3:3.6.1',
//     'org.apache.commons.beanutils'     : 'commons-beanutils:commons-beanutils:1.9.4',
//     'org.apache.commons.validator'     : 'commons-validator:commons-validator:1.9.0',

//     // === Google / JSON / Utils ===
//     'com.google.common'                : 'com.google.guava:guava:33.2.1-jre',
//     'com.google.gson'                  : 'com.google.code.gson:gson:2.11.0',
//     'com.google.protobuf'              : 'com.google.protobuf:protobuf-java:3.25.3',
//     'com.google.truth'                 : 'com.google.truth:truth:1.4.2',
//     'org.yaml.snakeyaml'               : 'org.yaml:snakeyaml:2.2',

//     // === Jackson (core + m√≥dulos comuns) ===
//     'com.fasterxml.jackson.core'       : 'com.fasterxml.jackson.core:jackson-core:2.17.1',
//     'com.fasterxml.jackson.annotation' : 'com.fasterxml.jackson.core:jackson-annotations:2.17.1',
//     'com.fasterxml.jackson.databind'   : 'com.fasterxml.jackson.core:jackson-databind:2.17.1',
//     'com.fasterxml.jackson.dataformat' : 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.17.1',
//     'com.fasterxml.jackson.datatype'   : 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.17.1',

//     // === Logging ===
//     'org.slf4j'                        : 'org.slf4j:slf4j-api:2.0.13',
//     'org.slf4j.simple'                 : 'org.slf4j:slf4j-simple:2.0.13',
//     'ch.qos.logback'                   : 'ch.qos.logback:logback-classic:1.5.6',
//     'org.apache.logging.log4j'         : 'org.apache.logging.log4j:log4j-api:2.23.1',
//     'org.apache.logging.log4j.core'    : 'org.apache.logging.log4j:log4j-core:2.23.1',

//     // === HTTP / Cliente Web ===
//     // Cliente Apache 5.x (pacotes org.apache.httpcomponents.client5 / org.apache.hc)
//     'org.apache.http'                  : 'org.apache.httpcomponents.client5:httpclient5:5.3.1',
//     // Cliente Apache 4.x legacy (pacotes org.apache.http.client.* antigos)
//     'org.apache.http.client'           : 'org.apache.httpcomponents:httpclient:4.5.14',
//     // OkHttp & Retrofit
//     'okhttp3'                          : 'com.squareup.okhttp3:okhttp:4.12.0',
//     'retrofit2'                        : 'com.squareup.retrofit2:retrofit:2.11.0',
//     'okio'                             : 'com.squareup.okio:okio:3.9.0',
//     // Jsoup
//     'org.jsoup'                        : 'org.jsoup:jsoup:1.18.1',

//     // === Banco de dados / JDBC (√∫teis pra testes r√°pidos) ===
//     'org.xerial.sqlitejdbc'            : 'org.xerial:sqlite-jdbc:3.45.3.0',
//     'com.h2database'                   : 'com.h2database:h2:2.2.224',
//     'org.postgresql'                   : 'org.postgresql:postgresql:42.7.3',
//     'com.mysql'                        : 'com.mysql:mysql-connector-j:8.3.0',

//     // === ORM / Jakarta ===
//     'org.hibernate'                    : 'org.hibernate.orm:hibernate-core:6.5.3.Final',
//     'jakarta.persistence'              : 'jakarta.persistence:jakarta.persistence-api:3.1.0',
//     'jakarta.validation'               : 'jakarta.validation:jakarta.validation-api:3.0.2',
//     'jakarta.xml.bind'                 : 'jakarta.xml.bind:jakarta.xml.bind-api:4.0.2',

//     // === Arquivos Office / CSV ===
//     'org.apache.poi'                   : 'org.apache.poi:poi-ooxml:5.2.5',
//     'com.opencsv'                      : 'com.opencsv:opencsv:5.9',

//     // === Seguran√ßa / Cripto ===
//     'org.jose4j'                       : 'org.bitbucket.b_c:jose4j:0.9.6',
//     'org.mindrot.jbcrypt'              : 'org.mindrot:jbcrypt:0.4',

//     // === Mapping / Utils extras ===
//     'org.mapstruct'                    : 'org.mapstruct:mapstruct:1.5.5.Final',
//     'org.modelmapper'                  : 'org.modelmapper:modelmapper:3.2.0',
//     'org.jetbrains.annotations'        : 'org.jetbrains:annotations:24.1.0',

//     // === Testes ===
//     'org.junit.jupiter'                : 'org.junit.jupiter:junit-jupiter:5.10.2',
//     'org.junit.platform'               : 'org.junit.platform:junit-platform-launcher:1.10.2',
//     'org.mockito'                      : 'org.mockito:mockito-core:5.13.0',
//     'org.hamcrest'                     : 'org.hamcrest:hamcrest:2.2',
//     'org.assertj'                      : 'org.assertj:assertj-core:3.26.0',

//     // === Outras utilidades ===
//     'org.json'                         : 'org.json:json:20240303',
//     'org.joda.time'                    : 'joda-time:joda-time:2.12.7',
//     'javax.annotation'                 : 'com.google.code.findbugs:jsr305:3.0.2', // s√≥ anota√ß√µes (legado)
// ]


// tasks.register('resolverDepsUsuario') {
//     // varre fontes do usu√°rio
//     inputs.files(fileTree(dirEntrada) { include '**/*.java' })

//     // deps.txt opcional
//     inputs.files(provider {
//         def f = file('entrada-usuario/deps.txt')
//         f.exists() ? [f] : []
//     })

//     // vendor/*.jar opcional (use files, n√£o dir)
//     inputs.files(provider {
//         def v = file('entrada-usuario/vendor')
//         v.exists() ? fileTree(v) { include '*.jar' } : []
//     })

//     outputs.dir(file('entrada-usuario/libs'))

//     doLast {
//         def libsDir = file('entrada-usuario/libs')
//         libsDir.mkdirs()

//         // 1) JARs locais do usu√°rio
//         def vendorDir = file('entrada-usuario/vendor')
//         if (vendorDir.exists()) {
//             copy {
//                 from(vendorDir)
//                 include '*.jar'
//                 into libsDir
//             }
//         }

//         // 2) deps.txt (coordenadas expl√≠citas)
//         def coords = [] as Set
//         def depsTxt = file('entrada-usuario/deps.txt')
//         if (depsTxt.exists()) {
//             depsTxt.readLines('UTF-8').each { line ->
//                 def s = line.trim()
//                 if (s && !s.startsWith('#')) coords << s
//             }
//         }

//         // 3) Heur√≠stica por imports
//         def imports = [] as Set
//         fileTree(dirEntrada) { include '**/*.java' }.each { f ->
//             f.eachLine('UTF-8') { l ->
//                 def m = (l =~ /^\s*import\s+([a-zA-Z0-9_.]+)\./)
//                 if (m.find()) imports << m.group(1)
//             }
//         }
//         imports.each { pkg ->
//             mapaImports.findAll { k, v -> pkg.startsWith(k) }.each { k, v -> coords << v }
//         }

//         // 4) Resolve e copia jars
//         if (!coords.isEmpty()) {
//             def depObjs = coords.collect { dependencies.create(it) } as org.gradle.api.artifacts.Dependency[]
//             def conf = configurations.detachedConfiguration(depObjs)
//             conf.setTransitive(true)
//             def filesResolved = conf.resolve()
//             copy {
//                 from filesResolved
//                 into libsDir
//             }
//         }

//         new File(libsDir, 'RESOLVIDO.txt').setText((coords.join('\n') + '\n'), 'UTF-8')
//         println "resolverDepsUsuario ‚Üí libs geradas em ${libsDir} (${coords.size()} coords)"
//     }
// }

// tasks.register('organizarUsuario') {
//     inputs.files(fileTree(dirEntrada) { include '**/*.java' })
//     inputs.files(fileTree(dirTestsIA) { include '**/*.java' })
//     inputs.files(fileTree(dirTestsUsuario) { include '**/*.java' })
//     outputs.dir(dirWork)

//     doLast {
//         if (dirWork.exists()) {
//             dirWork.deleteDir()
//         }
//         dirMain.mkdirs()
//         dirTest.mkdirs()

//         // helpers
//         def extrairPacote = { String src ->
//             def m = (src =~ /(?m)^\s*package\s+([a-zA-Z0-9_.]+)\s*;/)
//             m.find() ? m.group(1) : ''
//         }
//         def extrairNomePublico = { String src ->
//             def m = (src =~ /(?m)^\s*public\s+(?:class|interface|enum|record)\s+([A-Za-z_][A-Za-z0-9_]*)\b/)
//             m.find() ? m.group(1) : null
//         }
//         def classesReferenciadasEmTestes = { String src ->
//             def ignora = [
//                 'Assertions','Assert','System','Math','Objects','List','ArrayList','Arrays',
//                 'Collections','Stream','Optional','Files','Paths','Mockito','Matchers','Pattern','Matcher'
//             ] as Set
//             def nomes = [] as Set
//             def pat = ~/(?m)([A-Z][A-Za-z0-9_]*)\s*\.\s*[A-Za-z_][A-Za-z0-9_]*\s*\(/
//             def matcher = pat.matcher(src)
//             while (matcher.find()) {
//                 def c = matcher.group(1)
//                 if (!ignora.contains(c)) nomes << c
//             }
//             return nomes
//         }

//         def sanitizeJavaTest = { String s ->
//             if (s == null) return s
//             s = s.replaceAll('(?m)^```\\w*\\s*\\r?\\n?', '')
//             s = s.replaceAll('(?m)^```\\s*$', '')
//             s = s.replace('\uFEFF', '')

//             def lines = s.readLines()

//             def isValidStart = { String ln ->
//                 return (ln ==~ /\s*/) ||                        // vazia
//                     (ln ==~ /\s*package\s+.*/) ||
//                     (ln ==~ /\s*import\s+.*/)  ||
//                     (ln ==~ /\s*@.*/)          ||
//                     (ln ==~ /\s*(public\s+)?(class|interface|enum|record)\b.*/) ||
//                     (ln ==~ /\s*\/\/.*/) || (ln ==~ /\s*\/\*.*/) || (ln ==~ /\s*\*.*/)
//             }

//             // ‚úÖ Regex sem slashy: evita erro do parser
//             def fileNameOnly = Pattern.compile('^[A-Za-z0-9_.\\/\\-]+\\.java$')

//             while (!lines.isEmpty() && !isValidStart(lines[0])) {
//                 def head = lines[0].trim()
//                 if (fileNameOnly.matcher(head).matches()) {  // "Algo.java" sozinho no topo
//                     lines.remove(0)
//                     continue
//                 }
//                 lines.remove(0) // qualquer lixo antes do primeiro token Java v√°lido
//             }
//             return lines.join('\n')
//         }



//         // Carrega tudo
//         def fontesUsuario = []
//         def testesIA = []
//         inputs.files.files.each { File origem ->
//             // boolean isTeste = origem.toPath().startsWith(dirTestsIA.toPath())
//             boolean isTeste = origem.toPath().startsWith(dirTestsIA.toPath()) ||
//                             origem.toPath().startsWith(dirTestsUsuario.toPath())
//             String texto = origem.getText('UTF-8')
//             (isTeste ? testesIA : fontesUsuario) << [file: origem, text: texto]
//         }

//         // Detecta pacote(s) do usu√°rio
//         def pacotesUsuario = fontesUsuario.collect { extrairPacote(it.text) }.toSet()
//         String pacoteUsuario = (pacotesUsuario.size() == 1) ? pacotesUsuario.first() : ''  // se m√∫ltiplos, tratamos como default

//         // Renome de classe p√∫blica se teste espera outro nome
//         def nomesPublicosUsuario = fontesUsuario.collect { extrairNomePublico(it.text) }.findAll { it }
//         def nomesReferenciadosTestes = classesReferenciadasEmTestes(testesIA.collect { it.text }.join("\n"))
//         String nomePublico = (nomesPublicosUsuario ?: [null]).first()
//         String nomeEsperado = (nomesReferenciadosTestes ?: [null]).first()
//         boolean deveRenomear = (nomePublico && nomeEsperado && nomePublico != nomeEsperado &&
//                                 nomesPublicosUsuario.size()==1 && nomesReferenciadosTestes.size()==1)

//         if (deveRenomear) {
//             fontesUsuario = fontesUsuario.collect { f ->
//                 if (extrairNomePublico(f.text) == nomePublico) {
//                     def novoTexto = f.text.replaceFirst(
//                         /(?m)(^\s*public\s+(?:class|interface|enum|record)\s+)${java.util.regex.Pattern.quote(nomePublico)}\b/,
//                         "\$1${nomeEsperado}"
//                     )

//                     def pacote = extrairPacote(novoTexto)
//                     def caminhoPacote = pacote ? pacote.replace('.', File.separator) : ''
//                     def repoDir = new File(dirEntrada, caminhoPacote)
//                     repoDir.mkdirs()
//                     // grava o arquivo renomeado
//                     new File(repoDir, "${nomeEsperado}.java").setText(novoTexto, 'UTF-8')
//                     // (opcional) remove o antigo, se existia
//                     def antigo = new File(repoDir, "${nomePublico}.java")
//                     if (antigo.exists()) {
//                         antigo.delete()
//                     }


//                     [file: f.file, text: novoTexto]
//                 } else {
//                     f
//                 }
//             }

//             println "organizarUsuario ‚Üí renomeado classe p√∫blica '${nomePublico}' ‚Üí '${nomeEsperado}' para alinhar com os testes"
//         }


//         def ajustarTesteParaPacoteUsuario = { String texto ->
//             // 1) alinhar pacote
//             String pkgTeste = extrairPacote(texto)
//             if (pacoteUsuario == '') {
//                 // Usu√°rio no default package ‚Üí remover package dos testes
//                 texto = texto.replaceFirst(/(?m)^\s*package\s+[^;]+;\s*/, '')
//             } else {
//                 if (pkgTeste == '') {
//                     // teste sem package ‚Üí coloca o MESMO package do usu√°rio
//                     texto = "package ${pacoteUsuario};\n" + texto
//                     pkgTeste = pacoteUsuario
//                 } else {
//                     // teste j√° tem package ‚Üí injeta import * se ainda n√£o tiver
//                     if (!texto.contains("import ${pacoteUsuario}.")) {
//                         texto = texto.replaceFirst(/(?m)^(package\s+[^;]+;\s*)/, "\$1\nimport ${pacoteUsuario}.*;\n")
//                     }
//                 }
//             }

//             // 2) injetar imports JDK comuns se faltarem
//             // s√≠mbolos que frequentemente aparecem nos testes gerados
//             def candidatos = [
//                 // --- java.util ---
//                 [sym: 'Random',              fqcn: 'java.util.Random'],
//                 [sym: 'Scanner',             fqcn: 'java.util.Scanner'],
//                 [sym: 'Arrays',              fqcn: 'java.util.Arrays'],
//                 [sym: 'List',                fqcn: 'java.util.List'],
//                 [sym: 'ArrayList',           fqcn: 'java.util.ArrayList'],
//                 [sym: 'LinkedList',          fqcn: 'java.util.LinkedList'],
//                 [sym: 'Deque',               fqcn: 'java.util.Deque'],
//                 [sym: 'ArrayDeque',          fqcn: 'java.util.ArrayDeque'],
//                 [sym: 'Queue',               fqcn: 'java.util.Queue'],
//                 [sym: 'Set',                 fqcn: 'java.util.Set'],
//                 [sym: 'HashSet',             fqcn: 'java.util.HashSet'],
//                 [sym: 'TreeSet',             fqcn: 'java.util.TreeSet'],
//                 [sym: 'Map',                 fqcn: 'java.util.Map'],
//                 [sym: 'HashMap',             fqcn: 'java.util.HashMap'],
//                 [sym: 'LinkedHashMap',       fqcn: 'java.util.LinkedHashMap'],
//                 [sym: 'TreeMap',             fqcn: 'java.util.TreeMap'],
//                 [sym: 'Collections',         fqcn: 'java.util.Collections'],
//                 [sym: 'Optional',            fqcn: 'java.util.Optional'],
//                 [sym: 'OptionalInt',         fqcn: 'java.util.OptionalInt'],
//                 [sym: 'OptionalLong',        fqcn: 'java.util.OptionalLong'],
//                 [sym: 'OptionalDouble',      fqcn: 'java.util.OptionalDouble'],
//                 [sym: 'Comparator',          fqcn: 'java.util.Comparator'],
//                 [sym: 'UUID',                fqcn: 'java.util.UUID'],
//                 [sym: 'Properties',          fqcn: 'java.util.Properties'],
//                 [sym: 'BitSet',              fqcn: 'java.util.BitSet'],
//                 [sym: 'Stream',              fqcn: 'java.util.stream.Stream'],
//                 [sym: 'IntStream',           fqcn: 'java.util.stream.IntStream'],
//                 [sym: 'LongStream',          fqcn: 'java.util.stream.LongStream'],
//                 [sym: 'DoubleStream',        fqcn: 'java.util.stream.DoubleStream'],

//                 // --- java.time ---
//                 [sym: 'Instant',             fqcn: 'java.time.Instant'],
//                 [sym: 'Duration',            fqcn: 'java.time.Duration'],
//                 [sym: 'Period',              fqcn: 'java.time.Period'],
//                 [sym: 'LocalDate',           fqcn: 'java.time.LocalDate'],
//                 [sym: 'LocalTime',           fqcn: 'java.time.LocalTime'],
//                 [sym: 'LocalDateTime',       fqcn: 'java.time.LocalDateTime'],
//                 [sym: 'ZonedDateTime',       fqcn: 'java.time.ZonedDateTime'],
//                 [sym: 'OffsetDateTime',      fqcn: 'java.time.OffsetDateTime'],
//                 [sym: 'ZoneId',              fqcn: 'java.time.ZoneId'],
//                 [sym: 'DateTimeFormatter',   fqcn: 'java.time.format.DateTimeFormatter'],

//                 // --- java.nio.file / charset ---
//                 [sym: 'Path',                fqcn: 'java.nio.file.Path'],
//                 [sym: 'Paths',               fqcn: 'java.nio.file.Paths'],
//                 [sym: 'Files',               fqcn: 'java.nio.file.Files'],
//                 [sym: 'StandardOpenOption',  fqcn: 'java.nio.file.StandardOpenOption'],
//                 [sym: 'Charset',             fqcn: 'java.nio.charset.Charset'],
//                 [sym: 'StandardCharsets',    fqcn: 'java.nio.charset.StandardCharsets'],

//                 // --- java.io ---
//                 [sym: 'File',                fqcn: 'java.io.File'],
//                 [sym: 'IOException',         fqcn: 'java.io.IOException'],
//                 [sym: 'InputStream',         fqcn: 'java.io.InputStream'],
//                 [sym: 'OutputStream',        fqcn: 'java.io.OutputStream'],
//                 [sym: 'FileInputStream',     fqcn: 'java.io.FileInputStream'],
//                 [sym: 'FileOutputStream',    fqcn: 'java.io.FileOutputStream'],
//                 [sym: 'Reader',              fqcn: 'java.io.Reader'],
//                 [sym: 'Writer',              fqcn: 'java.io.Writer'],
//                 [sym: 'BufferedReader',      fqcn: 'java.io.BufferedReader'],
//                 [sym: 'BufferedWriter',      fqcn: 'java.io.BufferedWriter'],
//                 [sym: 'InputStreamReader',   fqcn: 'java.io.InputStreamReader'],
//                 [sym: 'OutputStreamWriter',  fqcn: 'java.io.OutputStreamWriter'],
//                 [sym: 'FileReader',          fqcn: 'java.io.FileReader'],
//                 [sym: 'FileWriter',          fqcn: 'java.io.FileWriter'],
//                 [sym: 'PrintWriter',         fqcn: 'java.io.PrintWriter'],

//                 // --- java.math ---
//                 [sym: 'BigDecimal',          fqcn: 'java.math.BigDecimal'],
//                 [sym: 'BigInteger',          fqcn: 'java.math.BigInteger'],
//                 [sym: 'RoundingMode',        fqcn: 'java.math.RoundingMode'],

//                 // --- java.util.regex ---
//                 [sym: 'Pattern',             fqcn: 'java.util.regex.Pattern'],
//                 [sym: 'Matcher',             fqcn: 'java.util.regex.Matcher'],

//                 // --- java.net / http ---
//                 [sym: 'URI',                 fqcn: 'java.net.URI'],
//                 [sym: 'URL',                 fqcn: 'java.net.URL'],
//                 [sym: 'URLEncoder',          fqcn: 'java.net.URLEncoder'],
//                 [sym: 'URLDecoder',          fqcn: 'java.net.URLDecoder'],
//                 [sym: 'HttpClient',          fqcn: 'java.net.http.HttpClient'],
//                 [sym: 'HttpRequest',         fqcn: 'java.net.http.HttpRequest'],
//                 [sym: 'HttpResponse',        fqcn: 'java.net.http.HttpResponse'],

//                 // --- utilidades diversas ---
//                 [sym: 'Objects',             fqcn: 'java.util.Objects'],
//                 [sym: 'StringJoiner',        fqcn: 'java.util.StringJoiner'],
//                 [sym: 'Spliterator',         fqcn: 'java.util.Spliterator'],
//             ]


//             // j√° importados?
//             def importados = [] as Set
//             def impMatcher = (texto =~ /(?m)^\s*import\s+([a-zA-Z0-9_.]+)\s*;/)
//             while (impMatcher.find()) {
//                 importados << impMatcher.group(1)
//             }


//             // montar lista de imports a inserir
//             def paraInserir = []
//             candidatos.each { c ->
//                 // se o s√≠mbolo aparece ‚Äúdesqualificado‚Äù (ex.: Random em vez de java.util.Random)
//                 def usaSimbolo = (texto =~ /\b${c.sym}\b/).find()
//                 def jaTemImportDireto = importados.contains(c.fqcn)
//                 def jaTemWildcard = importados.any { it == c.fqcn.replaceAll(/\.[^.]+$/, '.*') } // ex.: java.util.*
//                 def jaUsaQualificado = (texto =~ /\b${java.util.regex.Pattern.quote(c.fqcn)}\b/).find()
//                 if (usaSimbolo && !jaTemImportDireto && !jaTemWildcard && !jaUsaQualificado) {
//                     paraInserir << "import ${c.fqcn};"
//                     importados << c.fqcn
//                 }
//             }

//             if (!paraInserir.isEmpty()) {
//                 if ((texto =~ /(?m)^\s*package\s+[^;]+;\s*$/).find()) {
//                     // h√° package ‚Üí insere ap√≥s o package
//                     texto = texto.replaceFirst(/(?m)^(package\s+[^;]+;\s*)/, "\$1\n" + paraInserir.join("\n") + "\n")
//                 } else {
//                     // sem package ‚Üí insere no topo
//                     texto = paraInserir.join("\n") + "\n" + texto
//                 }
//             }

//             return texto
//         }


//         def espelharParaRepo = { String texto ->
//             String pacote = extrairPacote(texto)
//             String caminhoPacote = pacote ? pacote.replace('.', File.separator) : ''
//             File repoDir = caminhoPacote ? new File(dirEntrada, caminhoPacote) : dirEntrada
//             repoDir.mkdirs()

//             String nomePublicoLocal = extrairNomePublico(texto)
//             String nomeArquivo = nomePublicoLocal ? "${nomePublicoLocal}.java" : "Arquivo_${System.nanoTime()}.java"
//             new File(repoDir, nomeArquivo).setText(texto, 'UTF-8')
//         }

//         // --- Helpers p/ testes: stub + hook por reflex√£o ---

//         def injetarStubLoginAttempt = {
//             // injeta em TEST (mesmo pacote do usu√°rio, se existir)
//             String pacote = pacoteUsuario ?: ''
//             String header = pacote ? "package ${pacote};\n" : ""
//             def destinoDir = pacote ? new File(dirTest, pacote.replace('.', File.separator)) : dirTest
//             destinoDir.mkdirs()
//             new File(destinoDir, "LoginAttempt.java").setText(
//                 """${header}
//                 public class LoginAttempt {
//                     public String user;
//                     public boolean success;
//                     public long timestamp;
//                     public LoginAttempt() {}
//                     public LoginAttempt(String user, boolean success, long ts){
//                         this.user = user; this.success = success; this.timestamp = ts;
//                     }
//                 }
//                 """.stripIndent(), "UTF-8")
//             println "organizarUsuario ‚Üí stub LoginAttempt injetado em testes"
//         }

//         def injetarTestHooks = {
//             String pacote = pacoteUsuario ?: ''
//             String header = pacote ? "package ${pacote};\n" : ""
//             def destinoDir = pacote ? new File(dirTest, pacote.replace('.', File.separator)) : dirTest
//             destinoDir.mkdirs()
//             new File(destinoDir, "TestHooks.java").setText(
//                 """${header}
//                 import java.lang.reflect.Field;
//                 import java.util.Map;

//                 public final class TestHooks {
//                     private TestHooks() {}

//                     @SuppressWarnings("unchecked")
//                     public static void setActive(Object ums, String username, boolean active) {
//                         try {
//                             Class<?> cls = ums.getClass();
//                             Field fUsers = cls.getDeclaredField("users");
//                             fUsers.setAccessible(true);
//                             Object mapObj = fUsers.get(ums);
//                             Object userObj = ((Map<String, ?>) mapObj).get(username);
//                             if (userObj == null) return;
//                             Field fActive = userObj.getClass().getDeclaredField("isActive");
//                             fActive.setAccessible(true);
//                             fActive.setBoolean(userObj, active);
//                         } catch (Exception e) {
//                             throw new RuntimeException("TestHooks.setActive falhou", e);
//                         }
//                     }
//                 }
//                 """.stripIndent(), "UTF-8")
//             println "organizarUsuario ‚Üí TestHooks injetado em testes"
//         }


//         def gravar = { String texto, boolean isTeste ->
//             if (isTeste) {
//                 texto = sanitizeJavaTest(texto)
//                 texto = ajustarTesteParaPacoteUsuario(texto)
//             }
//             String pacote = extrairPacote(texto)
//             String caminhoPacote = pacote ? pacote.replace('.', File.separator) : ''
//             File baseDestino = isTeste ? dirTest : dirMain
//             File destinoDir = caminhoPacote ? new File(baseDestino, caminhoPacote) : baseDestino
//             destinoDir.mkdirs()

//             String nomePublicoLocal = extrairNomePublico(texto)
//             String nomeArquivo = nomePublicoLocal ? "${nomePublicoLocal}.java" : "Arquivo_${System.nanoTime()}.java"
//             new File(destinoDir, nomeArquivo).setText(texto, 'UTF-8')

//             // >>> espelha os fontes de PRODU√á√ÉO no reposit√≥rio (n√£o espelha testes gerados)
//             if (!isTeste) {
//                 espelharParaRepo(texto)
//             }
//             // <<<
//         }

//         // Se o teste tentar acessar .users.get(...).isActive = X; troca por TestHooks.setActive(...)
//         // testesIA = testesIA.collect { ti ->
//         //     String t = ti.text
//         //     String patched = t.replaceAll(
//         //         /(\b[A-Za-z_][A-Za-z0-9_]*)\.users\.get\(([^)]+)\)\.isActive\s*=\s*(true|false)\s*;/,
//         //         'TestHooks.setActive($1, $2, $3);'
//         //     )

//         //     // se o teste referir LoginAttempt, injeta stub
//         //     if (patched.contains("LoginAttempt")) {
//         //         injetarStubLoginAttempt()
//         //     }
//         //     // se precisou setActive, injeta TestHooks
//         //     if (!patched.equals(t) || patched.contains("TestHooks.setActive(")) {
//         //         injetarTestHooks()
//         //     }

//         //     [file: ti.file, text: patched]
//         // }

//         testesIA = testesIA.collect { ti ->
//             String t = sanitizeJavaTest(ti.text)
//             String patched = t.replaceAll(
//                 /(\\b[A-Za-z_][A-Za-z0-9_]*)\\.users\\.get\\(([^)]+)\\)\\.isActive\\s*=\\s*(true|false)\\s*;/,
//                 'TestHooks.setActive($1, $2, $3);'
//             )
//             if (patched.contains("LoginAttempt")) {
//                 injetarStubLoginAttempt()
//             }
//             if (!patched.equals(t) || patched.contains("TestHooks.setActive(")) {
//                 injetarTestHooks()
//             }
//             [file: ti.file, text: patched]
//         }





//         // Grava tudo
//         fontesUsuario.each { gravar(it.text, false) }
//         testesIA.each     { gravar(it.text, true)  }

//         // --- [IN√çCIO: inje√ß√£o condicional de stubs do modelo] ---
//         def modeloPkgPath = new File(dirMain, "org/example/model")
//         def modeloJaExiste = { String nome ->
//             // existe no build?
//             def f1 = new File(modeloPkgPath, "${nome}.java")
//             if (f1.exists()) return true
//             // existe no c√≥digo do usu√°rio?
//             return fileTree(dirEntrada) {
//                 include "**/${nome}.java"
//             }.any { it.text.contains("package org.example.model") }
//         }

//         // analisamos somente se usu√°rio/testes referem algo do modelo
//         def allText = (fontesUsuario.collect{it.text} + testesIA.collect{it.text}).join("\n")
//         def precisaRel   = allText.contains("RelatorioCobertura") && !modeloJaExiste("RelatorioCobertura")
//         def precisaClasse= allText.contains("ClasseCoberta")      && !modeloJaExiste("ClasseCoberta")
//         def precisaMetodo= allText.contains("MetodoCoberto")      && !modeloJaExiste("MetodoCoberto")

//         if (precisaRel || precisaClasse || precisaMetodo) {
//             modeloPkgPath.mkdirs()

//             if (precisaMetodo) {
//                 new File(modeloPkgPath, "MetodoCoberto.java").setText("""
//                     package org.example.model;
//                     public record MetodoCoberto(String nome, int linhaInicio, int linhaFim, double cobertura) {}
//                 """.stripIndent(), "UTF-8")
//             }

//             if (precisaClasse) {
//                 new File(modeloPkgPath, "ClasseCoberta.java").setText("""
//                     package org.example.model;
//                     import java.util.List;
//                     public record ClasseCoberta(String nome, String caminho, List<MetodoCoberto> metodos) {}
//                 """.stripIndent(), "UTF-8")
//             }

//             if (precisaRel) {
//                 new File(modeloPkgPath, "RelatorioCobertura.java").setText("""
//                     package org.example.model;
//                     import java.util.List;
//                     public final class RelatorioCobertura {
//                         public enum Ferramenta { JACOCO, OUTRA }
//                         private final String caminhoRelatorio;
//                         private final List<ClasseCoberta> classes;
//                         private final Ferramenta ferramenta;
//                         public RelatorioCobertura(String caminhoRelatorio, List<ClasseCoberta> classes, Ferramenta ferramenta) {
//                             this.caminhoRelatorio = caminhoRelatorio;
//                             this.classes = classes;
//                             this.ferramenta = ferramenta;
//                         }
//                         public String caminhoRelatorio() { return caminhoRelatorio; }
//                         public List<ClasseCoberta> classes() { return classes; }
//                         public Ferramenta ferramenta() { return ferramenta; }
//                     }
//                 """.stripIndent(), "UTF-8")
//             }

//             println "organizarUsuario ‚Üí stubs injetados em org.example.model: " +
//                     [(precisaMetodo?'MetodoCoberto':null),(precisaClasse?'ClasseCoberta':null),(precisaRel?'RelatorioCobertura':null)]
//                     .findAll{it!=null}.join(", ")
//         }
//         // --- [FIM: inje√ß√£o condicional de stubs do modelo] ---

//         println "organizarUsuario ‚Üí copiado para main: ${dirMain.absolutePath}"
//         println "organizarUsuario ‚Üí copiado para test: ${dirTest.absolutePath}"
//         println "organizarUsuario ‚Üí fontes recebidos: ${fontesUsuario.size()}"
//         println "organizarUsuario ‚Üí testes recebidos:  ${testesIA.size()}"
//         if (nomePublico)  println "organizarUsuario ‚Üí nome p√∫blico (usuario): ${nomePublico}"
//         if (nomeEsperado) println "organizarUsuario ‚Üí nome esperado (testes): ${nomeEsperado}"
//         if (pacoteUsuario) println "organizarUsuario ‚Üí pacote do usu√°rio detectado: ${pacoteUsuario}"
//     }
// }


// sourceSets {
//     usuario {
//         java {
//             srcDirs = [dirMain]
//         }
//         resources.srcDirs = []
//     }
//     usuarioTest {
//         java {
//             srcDirs = [dirTest]
//         }
//         resources.srcDirs = []
//         compileClasspath += sourceSets.usuario.output
//         runtimeClasspath  += sourceSets.usuario.output
//     }
// }

// // compila main s√≥ depois de organizar e resolver libs
// tasks.named(sourceSets.usuario.compileJavaTaskName) {
//     dependsOn 'organizarUsuario', 'resolverDepsUsuario'
// }

// // compila testes s√≥ depois de organizar, resolver libs e compilar main
// tasks.named(sourceSets.usuarioTest.compileJavaTaskName) {
//     dependsOn 'organizarUsuario', 'resolverDepsUsuario', tasks.named(sourceSets.usuario.classesTaskName)
// }


// tasks.register('testUsuario', Test) {
//     dependsOn tasks.named(sourceSets.usuario.classesTaskName),
//               tasks.named(sourceSets.usuarioTest.classesTaskName)

//     testClassesDirs = sourceSets.usuarioTest.output.classesDirs
//     classpath       = sourceSets.usuarioTest.runtimeClasspath
//     useJUnitPlatform()

//     // N√ÉO derrubar o build se testes falharem (para o JaCoCo rodar)
//     ignoreFailures = true

//     // .exec fixo
//     jacoco {
//         destinationFile = layout.buildDirectory.file("jacoco/testUsuario.exec").get().asFile
//     }

//     // log resumido
//     afterSuite { desc, result ->
//         if (!desc.parent) {
//             println "Resumo testUsuario -> total: ${result.testCount}, " +
//                     "passaram: ${result.successfulTestCount}, " +
//                     "falharam: ${result.failedTestCount}, " +
//                     "skipped: ${result.skippedTestCount}"
//         }
//     }

//     finalizedBy('jacocoRelatorioUsuario') // string -> n√£o for√ßa resolu√ß√£o antecipada
// }

// // === JaCoCo (relat√≥rio para o Codecov) ===
// jacoco {
//     toolVersion = '0.8.12'
// }

// tasks.register('jacocoRelatorioUsuario', JacocoReport) {
//     dependsOn 'testUsuario'

//     executionData.setFrom(layout.buildDirectory.file("jacoco/testUsuario.exec"))
//     classDirectories.setFrom(sourceSets.usuario.output.classesDirs)

//     // **s√≥** fontes versionadas no repo para o Codecov mapear
//     sourceDirectories.setFrom(files(file('entrada-usuario')))
//     additionalSourceDirs.setFrom(sourceDirectories)

//     reports {
//         xml.required.set(true)
//         html.required.set(true)
//         csv.required.set(false)
//         html.outputLocation.set(file('entrada-usuario/jacoco-relatorio/html'))
//         xml.outputLocation.set(file('entrada-usuario/jacoco-relatorio/jacoco.xml'))
//     }

//     doFirst {
//         file('entrada-usuario/jacoco-relatorio/html').mkdirs()
//     }
// }




// tasks.register('usuarioCobertura') {
//     dependsOn 'testUsuario'
// }

// tasks.withType(Test).configureEach {
//     testLogging {
//         events "FAILED", "SKIPPED"
//         exceptionFormat "full"
//         showStandardStreams = false
//     }
// }

// dependencies {
//     usuarioTestImplementation platform('org.junit:junit-bom:5.10.2')
//     usuarioTestImplementation 'org.junit.jupiter:junit-jupiter'
//     usuarioTestRuntimeOnly 'org.junit.platform:junit-platform-launcher'
//     usuarioImplementation fileTree('entrada-usuario/libs') { include '*.jar' }
//     testImplementation 'org.mockito:mockito-core:5.13.0'
// }

// tasks.withType(JavaExec).configureEach {
//     environment 'JAVA_TOOL_OPTIONS', '-Dfile.encoding=UTF-8'
// }

// tasks.named('test') {
//     useJUnitPlatform()
// }

plugins {
    id 'java'
    id 'application'
    id 'jacoco'
    id "org.sonarqube" version "6.2.0.5505"
    id 'org.springframework.boot' version '3.3.2'
    id 'io.spring.dependency-management' version '1.1.5'
}

import org.gradle.testing.jacoco.plugins.JacocoTaskExtension
import java.util.regex.Pattern

repositories {
    mavenCentral()
}

dependencies {
    testImplementation libs.junit.jupiter
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    implementation libs.guava
    implementation 'org.json:json:20240303'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.17.1'
    implementation 'commons-io:commons-io:2.16.1'

    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-validation'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    testImplementation platform('org.junit:junit-bom:5.10.2')
    testImplementation 'org.junit.jupiter:junit-jupiter'
    testImplementation 'junit:junit:4.13.2'
    testRuntimeOnly 'org.junit.vintage:junit-vintage-engine:5.10.2'
    testImplementation 'org.testng:testng:7.10.2'
    testImplementation 'org.mockito:mockito-core:5.13.0'
    testImplementation 'org.hamcrest:hamcrest:2.2'
    testImplementation 'org.assertj:assertj-core:3.26.0'
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

application {
    mainClass = 'org.example.web.WebApplication'
}

springBoot {
    mainClass = 'org.example.web.WebApplication'
}

sonar {
    properties {
        property "sonar.projectKey", "lipesanfelice_workflows"
        property "sonar.organization", "lipesanfelice"
        property "sonar.host.url", "https://sonarcloud.io"
        property "sonar.token", System.getenv("SONAR_TOKEN")
        property "sonar.sources", "entrada-usuario"
        property "sonar.inclusions", "entrada-usuario/**/*.java"
        property "sonar.tests", "src/test/java"
        property "sonar.java.binaries", "build/classes/java/main"
        property "sonar.junit.reportPaths", "build/test-results/test"
        property "sonar.coverage.jacoco.xmlReportPaths", "build/reports/jacoco/test/jacocoTestReport.xml"
    }
}

tasks.register('salvarRelatorioSonar', JavaExec) {
    group = 'sonar'
    mainClass = 'org.example.util.SonarRelatorioCli'
    classpath = sourceSets.main.runtimeClasspath
    args "lipesanfelice_workflows", System.getenv('SONAR_TOKEN') ?: '', "$projectDir/entrada-usuario/relatorio-sonar.json"
}

tasks.register('gerarTestesIa', JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'org.example.web.cli.GerarTestesCli'
}

configurations {
    usuarioImplementation.extendsFrom implementation
    usuarioRuntimeOnly.extendsFrom runtimeOnly
    usuarioTestImplementation.extendsFrom testImplementation
    usuarioTestRuntimeOnly.extendsFrom testRuntimeOnly
}

def dirEntrada = file('entrada-usuario')
def dirTestsIA = file('entrada-usuario/testes_explica√ß√µes/tests')
def dirTestsUsuario = file('entrada-usuario/testes')
def dirWork = layout.buildDirectory.dir('usuario-src').get().asFile
def dirMain = new File(dirWork, 'src/main/java')
def dirTest = new File(dirWork, 'src/test/java')

def mapaImports = [
    'org.apache.commons.lang3'        : 'org.apache.commons:commons-lang3:3.14.0',
    'org.apache.commons.io'           : 'commons-io:commons-io:2.16.1',
    'org.apache.commons.text'         : 'org.apache.commons:commons-text:1.11.0',
    'org.apache.commons.collections4' : 'org.apache.commons:commons-collections4:4.4',
    'org.apache.commons.csv'          : 'org.apache.commons:commons-csv:1.10.0',
    'org.apache.commons.codec'        : 'commons-codec:commons-codec:1.16.1',
    'org.apache.commons.compress'     : 'org.apache.commons:commons-compress:1.26.2',
    'org.apache.commons.math3'        : 'org.apache.commons:commons-math3:3.6.1',
    'org.apache.commons.beanutils'    : 'commons-beanutils:commons-beanutils:1.9.4',
    'org.apache.commons.validator'    : 'commons-validator:1.9.0',
    'com.google.common'               : 'com.google.guava:guava:33.2.1-jre',
    'com.google.gson'                 : 'com.google.code.gson:gson:2.11.0',
    'com.google.protobuf'             : 'com.google.protobuf:protobuf-java:3.25.3',
    'com.google.truth'                : 'com.google.truth:truth:1.4.2',
    'org.yaml.snakeyaml'              : 'org.yaml:snakeyaml:2.2',
    'com.fasterxml.jackson.core'      : 'com.fasterxml.jackson.core:jackson-core:2.17.1',
    'com.fasterxml.jackson.annotation': 'com.fasterxml.jackson.core:jackson-annotations:2.17.1',
    'com.fasterxml.jackson.databind'  : 'com.fasterxml.jackson.core:jackson-databind:2.17.1',
    'com.fasterxml.jackson.dataformat': 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.17.1',
    'com.fasterxml.jackson.datatype'  : 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.17.1',
    'org.slf4j'                       : 'org.slf4j:slf4j-api:2.0.13',
    'org.slf4j.simple'                : 'org.slf4j:slf4j-simple:2.0.13',
    'ch.qos.logback'                  : 'ch.qos.logback:logback-classic:1.5.6',
    'org.apache.logging.log4j'        : 'org.apache.logging.log4j:log4j-api:2.23.1',
    'org.apache.logging.log4j.core'   : 'org.apache.logging.log4j:log4j-core:2.23.1',
    'org.apache.http'                 : 'org.apache.httpcomponents.client5:httpclient5:5.3.1',
    'org.apache.http.client'          : 'org.apache.httpcomponents:httpclient:4.5.14',
    'okhttp3'                         : 'com.squareup.okhttp3:okhttp:4.12.0',
    'retrofit2'                       : 'com.squareup.retrofit2:retrofit:2.11.0',
    'okio'                            : 'com.squareup.okio:okio:3.9.0',
    'org.jsoup'                       : 'org.jsoup:jsoup:1.18.1',
    'org.xerial.sqlitejdbc'           : 'org.xerial:sqlite-jdbc:3.45.3.0',
    'com.h2database'                  : 'com.h2database:h2:2.2.224',
    'org.postgresql'                  : 'org.postgresql:postgresql:42.7.3',
    'com.mysql'                       : 'com.mysql:mysql-connector-j:8.3.0',
    'org.hibernate'                   : 'org.hibernate.orm:hibernate-core:6.5.3.Final',
    'jakarta.persistence'             : 'jakarta.persistence:jakarta.persistence-api:3.1.0',
    'jakarta.validation'              : 'jakarta.validation:jakarta.validation-api:3.0.2',
    'jakarta.xml.bind'                : 'jakarta.xml.bind:jakarta.xml.bind-api:4.0.2',
    'org.apache.poi'                  : 'org.apache.poi:poi-ooxml:5.2.5',
    'com.opencsv'                     : 'com.opencsv:opencsv:5.9',
    'org.bitbucket.b_c'               : 'org.bitbucket.b_c:jose4j:0.9.6',
    'org.mindrot.jbcrypt'             : 'org.mindrot:jbcrypt:0.4',
    'org.mapstruct'                   : 'org.mapstruct:mapstruct:1.5.5.Final',
    'org.modelmapper'                 : 'org.modelmapper:modelmapper:3.2.0',
    'org.jetbrains.annotations'       : 'org.jetbrains:annotations:24.1.0',
    'org.junit.jupiter'               : 'org.junit.jupiter:junit-jupiter:5.10.2',
    'org.junit.platform'              : 'org.junit.platform:junit-platform-launcher:1.10.2',
    'org.mockito'                     : 'org.mockito:mockito-core:5.13.0',
    'org.hamcrest'                    : 'org.hamcrest:hamcrest:2.2',
    'org.json'                        : 'org.json:json:20240303',
    'org.joda.time'                   : 'joda-time:joda-time:2.12.7',
    'javax.annotation'                : 'com.google.code.findbugs:jsr305:3.0.2'
]

tasks.register('resolverDepsUsuario') {
    inputs.files(fileTree(dirEntrada) { include '**/*.java' })
    inputs.files(provider { def f = file('entrada-usuario/deps.txt'); f.exists() ? [f] : [] })
    inputs.files(provider { def v = file('entrada-usuario/vendor'); v.exists() ? fileTree(v) { include '*.jar' } : [] })
    outputs.dir(file('entrada-usuario/libs'))
    doLast {
        def libsDir = file('entrada-usuario/libs')
        libsDir.mkdirs()
        def vendorDir = file('entrada-usuario/vendor')
        if (vendorDir.exists()) {
            copy { from(vendorDir); include '*.jar'; into libsDir }
        }
        def coords = [] as Set
        def depsTxt = file('entrada-usuario/deps.txt')
        if (depsTxt.exists()) {
            depsTxt.readLines('UTF-8').each { line ->
                def s = line.trim()
                if (s && !s.startsWith('#')) coords << s
            }
        }
        def imports = [] as Set
        fileTree(dirEntrada) { include '**/*.java' }.each { f ->
            f.eachLine('UTF-8') { l ->
                def m = (l =~ /^\s*import\s+([a-zA-Z0-9_.]+)\./)
                if (m.find()) imports << m.group(1)
            }
        }
        imports.each { pkg ->
            mapaImports.findAll { k, v -> pkg.startsWith(k) }.each { k, v -> coords << v }
        }
        if (!coords.isEmpty()) {
            def depObjs = coords.collect { dependencies.create(it) } as org.gradle.api.artifacts.Dependency[]
            def conf = configurations.detachedConfiguration(depObjs)
            conf.setTransitive(true)
            def filesResolved = conf.resolve()
            copy { from filesResolved; into libsDir }
        }
        new File(libsDir, 'RESOLVIDO.txt').setText((coords.join('\n') + '\n'), 'UTF-8')
        println "resolverDepsUsuario ‚Üí libs geradas em ${libsDir} (${coords.size()} coords)"
    }
}

tasks.register('organizarUsuario') {
    inputs.files(fileTree(dirEntrada) { include '**/*.java' })
    inputs.files(fileTree(dirTestsIA) { include '**/*.java' })
    inputs.files(fileTree(dirTestsUsuario) { include '**/*.java' })
    outputs.dir(dirWork)
    doLast {
        if (dirWork.exists()) { dirWork.deleteDir() }
        dirMain.mkdirs()
        dirTest.mkdirs()
        def extrairPacote = { String src ->
            def m = (src =~ /(?m)^\s*package\s+([a-zA-Z0-9_.]+)\s*;/)
            m.find() ? m.group(1) : ''
        }
        def extrairNomePublico = { String src ->
            def m = (src =~ /(?m)^\s*public\s+(?:class|interface|enum|record)\s+([A-Za-z_][A-Za-z0-9_]*)\b/)
            m.find() ? m.group(1) : null
        }
        def classesReferenciadasEmTestes = { String src ->
            def ignora = ['Assertions','Assert','System','Math','Objects','List','ArrayList','Arrays','Collections','Stream','Optional','Files','Paths','Mockito','Matchers','Pattern','Matcher'] as Set
            def nomes = [] as Set
            def pat = ~/(?m)([A-Z][A-Za-z0-9_]*)\s*\.\s*[A-Za-z_][A-Za-z0-9_]*\s*\(/
            def matcher = pat.matcher(src)
            while (matcher.find()) { def c = matcher.group(1); if (!ignora.contains(c)) nomes << c }
            nomes
        }
        def sanitizeJavaTest = { String s ->
            if (s == null) return s
            s = s.replaceAll('(?m)^```\\w*\\s*\\r?\\n?', '')
            s = s.replaceAll('(?m)^```\\s*$', '')
            s = s.replace('\uFEFF', '')
            def lines = s.readLines()
            def isValidStart = { String ln ->
                (ln ==~ /\s*/) || (ln ==~ /\s*package\s+.*/) || (ln ==~ /\s*import\s+.*/) || (ln ==~ /\s*@.*/) || (ln ==~ /\s*(public\s+)?(class|interface|enum|record)\b.*/) || (ln ==~ /\s*\/\/.*/) || (ln ==~ /\s*\/\*.*/) || (ln ==~ /\s*\*.*/)
            }
            def fileNameOnly = Pattern.compile('^[A-Za-z0-9_.\\/\\-]+\\.java$')
            while (!lines.isEmpty() && !isValidStart(lines[0])) {
                def head = lines[0].trim()
                if (fileNameOnly.matcher(head).matches()) { lines.remove(0); continue }
                lines.remove(0)
            }
            lines.join('\n')
        }
        def fontesUsuario = []
        def testesIA = []
        inputs.files.files.each { File origem ->
            boolean isTeste = origem.toPath().startsWith(dirTestsIA.toPath()) || origem.toPath().startsWith(dirTestsUsuario.toPath())
            String texto = origem.getText('UTF-8')
            (isTeste ? testesIA : fontesUsuario) << [file: origem, text: texto]
        }
        def pacotesUsuario = fontesUsuario.collect { extrairPacote(it.text) }.toSet()
        String pacoteUsuario = (pacotesUsuario.size() == 1) ? pacotesUsuario.first() : ''
        def nomesPublicosUsuario = fontesUsuario.collect { extrairNomePublico(it.text) }.findAll { it }
        def nomesReferenciadosTestes = classesReferenciadasEmTestes(testesIA.collect { it.text }.join("\n"))
        String nomePublico = (nomesPublicosUsuario ?: [null]).first()
        String nomeEsperado = (nomesReferenciadosTestes ?: [null]).first()
        boolean deveRenomear = (nomePublico && nomeEsperado && nomePublico != nomeEsperado && nomesPublicosUsuario.size()==1 && nomesReferenciadosTestes.size()==1)
        if (deveRenomear) {
            fontesUsuario = fontesUsuario.collect { f ->
                if (extrairNomePublico(f.text) == nomePublico) {
                    def novoTexto = f.text.replaceFirst(/(?m)(^\s*public\s+(?:class|interface|enum|record)\s+)${java.util.regex.Pattern.quote(nomePublico)}\b/,"\$1${nomeEsperado}")
                    def pacote = extrairPacote(novoTexto)
                    def caminhoPacote = pacote ? pacote.replace('.', File.separator) : ''
                    def repoDir = new File(dirEntrada, caminhoPacote)
                    repoDir.mkdirs()
                    new File(repoDir, "${nomeEsperado}.java").setText(novoTexto, 'UTF-8')
                    def antigo = new File(repoDir, "${nomePublico}.java")
                    if (antigo.exists()) { antigo.delete() }
                    [file: f.file, text: novoTexto]
                } else { f }
            }
            println "organizarUsuario ‚Üí renomeado classe p√∫blica '${nomePublico}' ‚Üí '${nomeEsperado}'"
        }
        def ajustarTesteParaPacoteUsuario = { String texto ->
            String pkgTeste = extrairPacote(texto)
            if (pacoteUsuario == '') {
                texto = texto.replaceFirst(/(?m)^\s*package\s+[^;]+;\s*/, '')
            } else {
                if (pkgTeste == '') {
                    texto = "package ${pacoteUsuario};\n" + texto
                    pkgTeste = pacoteUsuario
                } else {
                    if (!texto.contains("import ${pacoteUsuario}.")) {
                        texto = texto.replaceFirst(/(?m)^(package\s+[^;]+;\s*)/, "\$1\nimport ${pacoteUsuario}.*;\n")
                    }
                }
            }
            def candidatos = [
                [sym:'Random',fqcn:'java.util.Random'],[sym:'Scanner',fqcn:'java.util.Scanner'],[sym:'Arrays',fqcn:'java.util.Arrays'],[sym:'List',fqcn:'java.util.List'],[sym:'ArrayList',fqcn:'java.util.ArrayList'],[sym:'LinkedList',fqcn:'java.util.LinkedList'],[sym:'Deque',fqcn:'java.util.Deque'],[sym:'ArrayDeque',fqcn:'java.util.ArrayDeque'],[sym:'Queue',fqcn:'java.util.Queue'],[sym:'Set',fqcn:'java.util.Set'],[sym:'HashSet',fqcn:'java.util.HashSet'],[sym:'TreeSet',fqcn:'java.util.TreeSet'],[sym:'Map',fqcn:'java.util.Map'],[sym:'HashMap',fqcn:'java.util.HashMap'],[sym:'LinkedHashMap',fqcn:'java.util.LinkedHashMap'],[sym:'TreeMap',fqcn:'java.util.TreeMap'],[sym:'Collections',fqcn:'java.util.Collections'],[sym:'Optional',fqcn:'java.util.Optional'],[sym:'OptionalInt',fqcn:'java.util.OptionalInt'],[sym:'OptionalLong',fqcn:'java.util.OptionalLong'],[sym:'OptionalDouble',fqcn:'java.util.OptionalDouble'],[sym:'Comparator',fqcn:'java.util.Comparator'],[sym:'UUID',fqcn:'java.util.UUID'],[sym:'Properties',fqcn:'java.util.Properties'],[sym:'BitSet',fqcn:'java.util.BitSet'],[sym:'Stream',fqcn:'java.util.stream.Stream'],[sym:'IntStream',fqcn:'java.util.stream.IntStream'],[sym:'LongStream',fqcn:'java.util.stream.LongStream'],[sym:'DoubleStream',fqcn:'java.util.stream.DoubleStream'],
                [sym:'Instant',fqcn:'java.time.Instant'],[sym:'Duration',fqcn:'java.time.Duration'],[sym:'Period',fqcn:'java.time.Period'],[sym:'LocalDate',fqcn:'java.time.LocalDate'],[sym:'LocalTime',fqcn:'java.time.LocalTime'],[sym:'LocalDateTime',fqcn:'java.time.LocalDateTime'],[sym:'ZonedDateTime',fqcn:'java.time.ZonedDateTime'],[sym:'OffsetDateTime',fqcn:'java.time.OffsetDateTime'],[sym:'ZoneId',fqcn:'java.time.ZoneId'],[sym:'DateTimeFormatter',fqcn:'java.time.format.DateTimeFormatter'],
                [sym:'Path',fqcn:'java.nio.file.Path'],[sym:'Paths',fqcn:'java.nio.file.Paths'],[sym:'Files',fqcn:'java.nio.file.Files'],[sym:'StandardOpenOption',fqcn:'java.nio.file.StandardOpenOption'],[sym:'Charset',fqcn:'java.nio.charset.Charset'],[sym:'StandardCharsets',fqcn:'java.nio.charset.StandardCharsets'],
                [sym:'File',fqcn:'java.io.File'],[sym:'IOException',fqcn:'java.io.IOException'],[sym:'InputStream',fqcn:'java.io.InputStream'],[sym:'OutputStream',fqcn:'java.io.OutputStream'],[sym:'FileInputStream',fqcn:'java.io.FileInputStream'],[sym:'FileOutputStream',fqcn:'java.io.FileOutputStream'],[sym:'Reader',fqcn:'java.io.Reader'],[sym:'Writer',fqcn:'java.io.Writer'],[sym:'BufferedReader',fqcn:'java.io.BufferedReader'],[sym:'BufferedWriter',fqcn:'java.io.BufferedWriter'],[sym:'InputStreamReader',fqcn:'java.io.InputStreamReader'],[sym:'OutputStreamWriter',fqcn:'java.io.OutputStreamWriter'],[sym:'FileReader',fqcn:'java.io.FileReader'],[sym:'FileWriter',fqcn:'java.io.FileWriter'],[sym:'PrintWriter',fqcn:'java.io.PrintWriter'],
                [sym:'BigDecimal',fqcn:'java.math.BigDecimal'],[sym:'BigInteger',fqcn:'java.math.BigInteger'],[sym:'RoundingMode',fqcn:'java.math.RoundingMode'],
                [sym:'Pattern',fqcn:'java.util.regex.Pattern'],[sym:'Matcher',fqcn:'java.util.regex.Matcher'],
                [sym:'URI',fqcn:'java.net.URI'],[sym:'URL',fqcn:'java.net.URL'],[sym:'URLEncoder',fqcn:'java.net.URLEncoder'],[sym:'URLDecoder',fqcn:'java.net.URLDecoder'],[sym:'HttpClient',fqcn:'java.net.http.HttpClient'],[sym:'HttpRequest',fqcn:'java.net.http.HttpRequest'],[sym:'HttpResponse',fqcn:'java.net.http.HttpResponse'],
                [sym:'Objects',fqcn:'java.util.Objects'],[sym:'StringJoiner',fqcn:'java.util.StringJoiner'],[sym:'Spliterator',fqcn:'java.util.Spliterator']
            ]
            def importados = [] as Set
            def impMatcher = (texto =~ /(?m)^\s*import\s+([a-zA-Z0-9_.]+)\s*;/)
            while (impMatcher.find()) { importados << impMatcher.group(1) }
            def paraInserir = []
            candidatos.each { c ->
                def usaSimbolo = (texto =~ /\b${c.sym}\b/).find()
                def jaTemImportDireto = importados.contains(c.fqcn)
                def jaTemWildcard = importados.any { it == c.fqcn.replaceAll(/\.[^.]+$/, '.*') }
                def jaUsaQualificado = (texto =~ /\b${java.util.regex.Pattern.quote(c.fqcn)}\b/).find()
                if (usaSimbolo && !jaTemImportDireto && !jaTemWildcard && !jaUsaQualificado) {
                    paraInserir << "import ${c.fqcn};"
                    importados << c.fqcn
                }
            }
            if (!paraInserir.isEmpty()) {
                if ((texto =~ /(?m)^\s*package\s+[^;]+;\s*$/).find()) {
                    texto = texto.replaceFirst(/(?m)^(package\s+[^;]+;\s*)/, "\$1\n" + paraInserir.join("\n") + "\n")
                } else {
                    texto = paraInserir.join("\n") + "\n" + texto
                }
            }
            texto
        }
        def espelharParaRepo = { String texto ->
            String pacote = extrairPacote(texto)
            String caminhoPacote = pacote ? pacote.replace('.', File.separator) : ''
            File repoDir = caminhoPacote ? new File(dirEntrada, caminhoPacote) : dirEntrada
            repoDir.mkdirs()
            String nomePublicoLocal = extrairNomePublico(texto)
            String nomeArquivo = nomePublicoLocal ? "${nomePublicoLocal}.java" : "Arquivo_${System.nanoTime()}.java"
            new File(repoDir, nomeArquivo).setText(texto, 'UTF-8')
        }
        def injetarStubLoginAttempt = {
            String pacote = pacoteUsuario ?: ''
            String header = pacote ? "package ${pacote};\n" : ""
            def destinoDir = pacote ? new File(dirTest, pacote.replace('.', File.separator)) : dirTest
            destinoDir.mkdirs()
            new File(destinoDir, "LoginAttempt.java").setText("""${header}
                public class LoginAttempt {
                    public String user;
                    public boolean success;
                    public long timestamp;
                    public LoginAttempt() {}
                    public LoginAttempt(String user, boolean success, long ts){
                        this.user = user; this.success = success; this.timestamp = ts;
                    }
                }
            """.stripIndent(), "UTF-8")
            println "organizarUsuario ‚Üí stub LoginAttempt injetado em testes"
        }
        def injetarTestHooks = {
            String pacote = pacoteUsuario ?: ''
            String header = pacote ? "package ${pacote};\n" : ""
            def destinoDir = pacote ? new File(dirTest, pacote.replace('.', File.separator)) : dirTest
            destinoDir.mkdirs()
            new File(destinoDir, "TestHooks.java").setText("""${header}
                import java.lang.reflect.Field;
                import java.util.Map;
                public final class TestHooks {
                    private TestHooks() {}
                    @SuppressWarnings("unchecked")
                    public static void setActive(Object ums, String username, boolean active) {
                        try {
                            Class<?> cls = ums.getClass();
                            Field fUsers = cls.getDeclaredField("users");
                            fUsers.setAccessible(true);
                            Object mapObj = fUsers.get(ums);
                            Object userObj = ((Map<String, ?>) mapObj).get(username);
                            if (userObj == null) return;
                            Field fActive = userObj.getClass().getDeclaredField("isActive");
                            fActive.setAccessible(true);
                            fActive.setBoolean(userObj, active);
                        } catch (Exception e) {
                            throw new RuntimeException("TestHooks.setActive falhou", e);
                        }
                    }
                }
            """.stripIndent(), "UTF-8")
            println "organizarUsuario ‚Üí TestHooks injetado em testes"
        }
        def gravar = { String texto, boolean isTeste ->
            if (isTeste) {
                texto = sanitizeJavaTest(texto)
                texto = ajustarTesteParaPacoteUsuario(texto)
            }
            String pacote = extrairPacote(texto)
            String caminhoPacote = pacote ? pacote.replace('.', File.separator) : ''
            File baseDestino = isTeste ? dirTest : dirMain
            File destinoDir = caminhoPacote ? new File(baseDestino, caminhoPacote) : baseDestino
            destinoDir.mkdirs()
            String nomePublicoLocal = extrairNomePublico(texto)
            String nomeArquivo = nomePublicoLocal ? "${nomePublicoLocal}.java" : "Arquivo_${System.nanoTime()}.java"
            new File(destinoDir, nomeArquivo).setText(texto, 'UTF-8')
            if (!isTeste) { espelharParaRepo(texto) }
        }
        testesIA = testesIA.collect { ti ->
            String t = sanitizeJavaTest(ti.text)
            String patched = t.replaceAll(/(\\b[A-Za-z_][A-Za-z0-9_]*)\\.users\\.get\\(([^)]+)\\)\\.isActive\\s*=\\s*(true|false)\\s*;/,'TestHooks.setActive($1, $2, $3);')
            if (patched.contains("LoginAttempt")) { injetarStubLoginAttempt() }
            if (!patched.equals(t) || patched.contains("TestHooks.setActive(")) { injetarTestHooks() }
            [file: ti.file, text: patched]
        }
        fontesUsuario.each { gravar(it.text, false) }
        testesIA.each { gravar(it.text, true) }
        def modeloPkgPath = new File(dirMain, "org/example/model")
        def modeloJaExiste = { String nome ->
            def f1 = new File(modeloPkgPath, "${nome}.java"); if (f1.exists()) return true
            return fileTree(dirEntrada) { include "**/${nome}.java" }.any { it.text.contains("package org.example.model") }
        }
        def allText = (fontesUsuario.collect{it.text} + testesIA.collect{it.text}).join("\n")
        def precisaRel = allText.contains("RelatorioCobertura") && !modeloJaExiste("RelatorioCobertura")
        def precisaClasse = allText.contains("ClasseCoberta") && !modeloJaExiste("ClasseCoberta")
        def precisaMetodo = allText.contains("MetodoCoberto") && !modeloJaExiste("MetodoCoberto")
        if (precisaRel || precisaClasse || precisaMetodo) {
            modeloPkgPath.mkdirs()
            if (precisaMetodo) {
                new File(modeloPkgPath, "MetodoCoberto.java").setText("""
                    package org.example.model;
                    public record MetodoCoberto(String nome, int linhaInicio, int linhaFim, double cobertura) {}
                """.stripIndent(), "UTF-8")
            }
            if (precisaClasse) {
                new File(modeloPkgPath, "ClasseCoberta.java").setText("""
                    package org.example.model;
                    import java.util.List;
                    public record ClasseCoberta(String nome, String caminho, List<MetodoCoberto> metodos) {}
                """.stripIndent(), "UTF-8")
            }
            if (precisaRel) {
                new File(modeloPkgPath, "RelatorioCobertura.java").setText("""
                    package org.example.model;
                    import java.util.List;
                    public final class RelatorioCobertura {
                        public enum Ferramenta { JACOCO, OUTRA }
                        private final String caminhoRelatorio;
                        private final List<ClasseCoberta> classes;
                        private final Ferramenta ferramenta;
                        public RelatorioCobertura(String caminhoRelatorio, List<ClasseCoberta> classes, Ferramenta ferramenta) {
                            this.caminhoRelatorio = caminhoRelatorio;
                            this.classes = classes;
                            this.ferramenta = ferramenta;
                        }
                        public String caminhoRelatorio() { return caminhoRelatorio; }
                        public List<ClasseCoberta> classes() { return classes; }
                        public Ferramenta ferramenta() { return ferramenta; }
                    }
                """.stripIndent(), "UTF-8")
            }
            println "organizarUsuario ‚Üí stubs injetados em org.example.model: " + [(precisaMetodo?'MetodoCoberto':null),(precisaClasse?'ClasseCoberta':null),(precisaRel?'RelatorioCobertura':null)].findAll{it!=null}.join(", ")
        }
        println "organizarUsuario ‚Üí copiado para main: ${dirMain.absolutePath}"
        println "organizarUsuario ‚Üí copiado para test: ${dirTest.absolutePath}"
        println "organizarUsuario ‚Üí fontes recebidos: ${fontesUsuario.size()}"
        println "organizarUsuario ‚Üí testes recebidos:  ${testesIA.size()}"
        nomePublico  = (fontesUsuario.collect { extrairNomePublico(it.text) }.findAll { it } ?: [null]).first()
        nomeEsperado = (classesReferenciadasEmTestes(testesIA.collect { it.text }.join("\n")) ?: [null]).first()
        if (nomePublico)  println "organizarUsuario ‚Üí nome p√∫blico (usuario): ${nomePublico}"
        if (nomeEsperado) println "organizarUsuario ‚Üí nome esperado (testes): ${nomeEsperado}"
        if (pacoteUsuario) println "organizarUsuario ‚Üí pacote do usu√°rio detectado: ${pacoteUsuario}"
    }
}

sourceSets {
    usuario {
        java { srcDirs = [dirMain] }
        resources.srcDirs = []
    }
    usuarioTest {
        java { srcDirs = [dirTest] }
        resources.srcDirs = []
        compileClasspath += sourceSets.usuario.output
        runtimeClasspath  += sourceSets.usuario.output
    }
}

tasks.named(sourceSets.usuario.compileJavaTaskName) {
    dependsOn 'organizarUsuario', 'resolverDepsUsuario'
}

tasks.named(sourceSets.usuarioTest.compileJavaTaskName) {
    dependsOn 'organizarUsuario', 'resolverDepsUsuario', tasks.named(sourceSets.usuario.classesTaskName)
}

def temTestNg
try {
    temTestNg = configurations.usuarioTestRuntimeClasspath.resolve().any { it.name.startsWith('testng-') } || configurations.testRuntimeClasspath.resolve().any { it.name.startsWith('testng-') }
} catch (Throwable ignore) {
    temTestNg = false
}

tasks.register('testUsuario', Test) {
    dependsOn tasks.named(sourceSets.usuario.classesTaskName), tasks.named(sourceSets.usuarioTest.classesTaskName)
    testClassesDirs = sourceSets.usuarioTest.output.classesDirs
    classpath = sourceSets.usuarioTest.runtimeClasspath
    if (temTestNg) { useTestNG() } else { useJUnitPlatform() }
    ignoreFailures = true
    jacoco { destinationFile = layout.buildDirectory.file("jacoco/testUsuario.exec").get().asFile }
    afterSuite { desc, result -> if (!desc.parent) { println "Resumo testUsuario -> total: ${result.testCount}, passaram: ${result.successfulTestCount}, falharam: ${result.failedTestCount}, skipped: ${result.skippedTestCount}" } }
    finalizedBy('jacocoRelatorioUsuario')
}

jacoco {
    toolVersion = '0.8.12'
}

tasks.register('jacocoRelatorioUsuario', JacocoReport) {
    dependsOn 'testUsuario'
    def execs = files(
        fileTree("$buildDir") { include '**/*.exec' },
        layout.buildDirectory.file("jacoco/testUsuario.exec")
    ).filter { it != null && it.exists() }
    executionData.setFrom(execs)
    classDirectories.setFrom(sourceSets.usuario.output.classesDirs)
    sourceDirectories.setFrom(files(file('entrada-usuario')))
    additionalSourceDirs.setFrom(sourceDirectories)
    reports {
        xml.required.set(true)
        html.required.set(true)
        csv.required.set(false)
        html.outputLocation.set(file('entrada-usuario/jacoco-relatorio/html'))
        xml.outputLocation.set(file('entrada-usuario/jacoco-relatorio/jacoco.xml'))
    }
    onlyIf { !executionData.files.isEmpty() }
    doFirst { file('entrada-usuario/jacoco-relatorio/html').mkdirs(); if (executionData.files.isEmpty()) logger.lifecycle('jacoco: nenhum executionData encontrado; relat√≥rio ser√° omitido') }
}

tasks.register('usuarioCobertura') {
    dependsOn 'testUsuario'
}

tasks.withType(Test).configureEach {
    testLogging {
        events "FAILED", "SKIPPED"
        exceptionFormat "full"
        showStandardStreams = false
    }
}

dependencies {
    usuarioTestImplementation platform('org.junit:junit-bom:5.10.2')
    usuarioTestImplementation 'org.junit.jupiter:junit-jupiter'
    usuarioTestRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    usuarioImplementation fileTree('entrada-usuario/libs') { include '*.jar' }
    testImplementation 'org.mockito:mockito-core:5.13.0'
}

tasks.withType(JavaExec).configureEach {
    environment 'JAVA_TOOL_OPTIONS', '-Dfile.encoding=UTF-8'
}

tasks.named('test') {
    useJUnitPlatform()
}

tasks.named('check') {
    finalizedBy 'jacocoRelatorioUsuario'
}

