plugins {
    id 'java'
    id 'application'
    id 'jacoco'
    id "org.sonarqube" version "6.2.0.5505"
    id 'org.springframework.boot' version '3.3.2'
    id 'io.spring.dependency-management' version '1.1.5'
}

import org.gradle.testing.jacoco.plugins.JacocoTaskExtension
import java.util.regex.Pattern
repositories {
    mavenCentral()
}

dependencies {
    // Testes
    testImplementation libs.junit.jupiter
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    // Utilitários
    implementation libs.guava
    implementation 'org.json:json:20240303'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.17.1'
    implementation 'commons-io:commons-io:2.16.1'

    // Spring Boot Web
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-validation'

    // Testes Spring Boot
    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    testImplementation platform('org.junit:junit-bom:5.10.2')
    testImplementation 'org.junit.jupiter:junit-jupiter'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

application {
    mainClass = 'org.example.web.WebApplication'
}

springBoot {
    mainClass = 'org.example.web.WebApplication'
}

sonar {
    properties {
        property "sonar.projectKey", "lipesanfelice_workflows"
        property "sonar.organization", "lipesanfelice"
        property "sonar.host.url", "https://sonarcloud.io"
        property "sonar.token", System.getenv("SONAR_TOKEN")

        // 👇 fontes analisadas = APENAS a pasta entrada-usuario
        property "sonar.sources", "entrada-usuario"
        property "sonar.inclusions", "entrada-usuario/**/*.java"

        property "sonar.tests", "src/test/java"
        property "sonar.java.binaries", "build/classes/java/main"
        property "sonar.junit.reportPaths", "build/test-results/test"
        property "sonar.coverage.jacoco.xmlReportPaths", "build/reports/jacoco/test/jacocoTestReport.xml"
    }
}

tasks.register('salvarRelatorioSonar', JavaExec) {
    group = 'sonar'
    mainClass = 'org.example.util.SonarRelatorioCli'
    classpath = sourceSets.main.runtimeClasspath
    args "lipesanfelice_workflows", System.getenv('SONAR_TOKEN') ?: '', "$projectDir/entrada-usuario/relatorio-sonar.json"
}

// app/build.gradle
tasks.register('gerarTestesIa', JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'org.example.web.cli.GerarTestesCli'
}

configurations {
    usuarioImplementation.extendsFrom implementation
    usuarioRuntimeOnly.extendsFrom runtimeOnly
    usuarioTestImplementation.extendsFrom testImplementation
    usuarioTestRuntimeOnly.extendsFrom testRuntimeOnly
}

def dirEntrada = file('entrada-usuario')
def dirTestsIA = file('entrada-usuario/testes_explicações/tests')
def dirTestsUsuario = file('entrada-usuario/testes')
def dirWork = layout.buildDirectory.dir('usuario-src').get().asFile
def dirMain = new File(dirWork, 'src/main/java')
def dirTest = new File(dirWork, 'src/test/java')

// Mapeia imports -> coordenadas Maven padrão (versões estáveis p/ Java 21 / Spring Boot 3.x)
def mapaImports = [
    // === Apache Commons ===
    'org.apache.commons.lang3'         : 'org.apache.commons:commons-lang3:3.14.0',
    'org.apache.commons.io'            : 'commons-io:commons-io:2.16.1',
    'org.apache.commons.text'          : 'org.apache.commons:commons-text:1.11.0',
    'org.apache.commons.collections4'  : 'org.apache.commons:commons-collections4:4.4',
    'org.apache.commons.csv'           : 'org.apache.commons:commons-csv:1.10.0',
    'org.apache.commons.codec'         : 'commons-codec:commons-codec:1.16.1',
    'org.apache.commons.compress'      : 'org.apache.commons:commons-compress:1.26.2',
    'org.apache.commons.math3'         : 'org.apache.commons:commons-math3:3.6.1',
    'org.apache.commons.beanutils'     : 'commons-beanutils:commons-beanutils:1.9.4',
    'org.apache.commons.validator'     : 'commons-validator:commons-validator:1.9.0',

    // === Google / JSON / Utils ===
    'com.google.common'                : 'com.google.guava:guava:33.2.1-jre',
    'com.google.gson'                  : 'com.google.code.gson:gson:2.11.0',
    'com.google.protobuf'              : 'com.google.protobuf:protobuf-java:3.25.3',
    'com.google.truth'                 : 'com.google.truth:truth:1.4.2',
    'org.yaml.snakeyaml'               : 'org.yaml:snakeyaml:2.2',

    // === Jackson (core + módulos comuns) ===
    'com.fasterxml.jackson.core'       : 'com.fasterxml.jackson.core:jackson-core:2.17.1',
    'com.fasterxml.jackson.annotation' : 'com.fasterxml.jackson.core:jackson-annotations:2.17.1',
    'com.fasterxml.jackson.databind'   : 'com.fasterxml.jackson.core:jackson-databind:2.17.1',
    'com.fasterxml.jackson.dataformat' : 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.17.1',
    'com.fasterxml.jackson.datatype'   : 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.17.1',

    // === Logging ===
    'org.slf4j'                        : 'org.slf4j:slf4j-api:2.0.13',
    'org.slf4j.simple'                 : 'org.slf4j:slf4j-simple:2.0.13',
    'ch.qos.logback'                   : 'ch.qos.logback-classic:1.5.6',
    'org.apache.logging.log4j'         : 'org.apache.logging.log4j:log4j-api:2.23.1',
    'org.apache.logging.log4j.core'    : 'org.apache.logging.log4j:log4j-core:2.23.1',

    // === HTTP / Cliente Web ===
    'org.apache.http'                  : 'org.apache.httpcomponents.client5:httpclient5:5.3.1',
    'org.apache.http.client'           : 'org.apache.httpcomponents:httpclient:4.5.14',
    'okhttp3'                          : 'com.squareup.okhttp3:okhttp:4.12.0',
    'retrofit2'                        : 'com.squareup.retrofit2:retrofit:2.11.0',
    'okio'                             : 'com.squareup.okio:okio:3.9.0',
    'org.jsoup'                        : 'org.jsoup:jsoup:1.18.1',

    // === Banco de dados / JDBC ===
    'org.xerial.sqlitejdbc'            : 'org.xerial:sqlite-jdbc:3.45.3.0',
    'com.h2database'                   : 'com.h2database:h2:2.2.224',
    'org.postgresql'                   : 'org.postgresql:postgresql:42.7.3',
    'com.mysql'                        : 'com.mysql:mysql-connector-j:8.3.0',

    // === ORM / Jakarta ===
    'org.hibernate'                    : 'org.hibernate.orm:hibernate-core:6.5.3.Final',
    'jakarta.persistence'              : 'jakarta.persistence:jakarta.persistence-api:3.1.0',
    'jakarta.validation'               : 'jakarta.validation:jakarta.validation-api:3.0.2',
    'jakarta.xml.bind'                 : 'jakarta.xml.bind:jakarta.xml.bind-api:4.0.2',

    // === Arquivos Office / CSV ===
    'org.apache.poi'                   : 'org.apache.poi:poi-ooxml:5.2.5',
    'com.opencsv'                      : 'com.opencsv:opencsv:5.9',

    // === Segurança / Cripto ===
    'org.jose4j'                       : 'org.bitbucket.b_c:jose4j:0.9.6',
    'org.mindrot.jbcrypt'              : 'org.mindrot:jbcrypt:0.4',

    // === Mapping / Utils extras ===
    'org.mapstruct'                    : 'org.mapstruct:mapstruct:1.5.5.Final',
    'org.modelmapper'                  : 'org.modelmapper:modelmapper:3.2.0',
    'org.jetbrains.annotations'        : 'org.jetbrains:annotations:24.1.0',

    // === Testes ===
    'org.junit.jupiter'                : 'org.junit.jupiter:junit-jupiter:5.10.2',
    'org.junit.platform'               : 'org.junit.platform:junit-platform-launcher:1.10.2',
    'org.mockito'                      : 'org.mockito:mockito-core:5.13.0',
    'org.hamcrest'                     : 'org.hamcrest:hamcrest:2.2',
    'org.assertj'                      : 'org.assertj:assertj-core:3.26.0',

    // === Outras utilidades ===
    'org.json'                         : 'org.json:json:20240303',
    'org.joda.time'                    : 'joda-time:joda-time:2.12.7',
    'javax.annotation'                 : 'com.google.code.findbugs:jsr305:3.0.2',
]

tasks.register('resolverDepsUsuario') {
    // varre fontes do usuário
    inputs.files(fileTree(dirEntrada) { include '**/*.java' })

    // deps.txt opcional
    inputs.files(provider {
        def f = file('entrada-usuario/deps.txt')
        f.exists() ? [f] : []
    })

    // vendor/*.jar opcional (use files, não dir)
    inputs.files(provider {
        def v = file('entrada-usuario/vendor')
        v.exists() ? fileTree(v) { include '*.jar' } : []
    })

    outputs.dir(file('entrada-usuario/libs'))

    doLast {
        def libsDir = file('entrada-usuario/libs')
        libsDir.mkdirs()

        // 1) JARs locais do usuário
        def vendorDir = file('entrada-usuario/vendor')
        if (vendorDir.exists()) {
            copy {
                from(vendorDir)
                include '*.jar'
                into libsDir
            }
        }

        // 2) deps.txt (coordenadas explícitas)
        def coords = [] as Set
        def depsTxt = file('entrada-usuario/deps.txt')
        if (depsTxt.exists()) {
            depsTxt.readLines('UTF-8').each { line ->
                def s = line.trim()
                if (s && !s.startsWith('#')) coords << s
            }
        }

        // 3) Heurística por imports
        def imports = [] as Set
        fileTree(dirEntrada) { include '**/*.java' }.each { f ->
            f.eachLine('UTF-8') { l ->
                def m = (l =~ /^\s*import\s+([a-zA-Z0-9_.]+)\./)
                if (m.find()) imports << m.group(1)
            }
        }
        imports.each { pkg ->
            mapaImports.findAll { k, v -> pkg.startsWith(k) }.each { k, v -> coords << v }
        }

        // 4) Resolve e copia jars
        if (!coords.isEmpty()) {
            def depObjs = coords.collect { dependencies.create(it) } as org.gradle.api.artifacts.Dependency[]
            def conf = configurations.detachedConfiguration(depObjs)
            conf.setTransitive(true)
            def filesResolved = conf.resolve()
            copy {
                from filesResolved
                into libsDir
            }
        }

        new File(libsDir, 'RESOLVIDO.txt').setText((coords.join('\n') + '\n'), 'UTF-8')
        println "resolverDepsUsuario → libs geradas em ${libsDir} (${coords.size()} coords)"
    }
}

tasks.register('organizarUsuario') {
    inputs.files(fileTree(dirEntrada) { include '**/*.java' })
    inputs.files(fileTree(dirTestsIA) { include '**/*.java' })
    inputs.files(fileTree(dirTestsUsuario) { include '**/*.java' })
    outputs.dir(dirWork)

    doLast {
        if (dirWork.exists()) {
            dirWork.deleteDir()
        }
        dirMain.mkdirs()
        dirTest.mkdirs()

        // helpers
        def extrairPacote = { String src ->
            def m = (src =~ /(?m)^\s*package\s+([a-zA-Z0-9_.]+)\s*;/)
            m.find() ? m.group(1) : ''
        }
        def extrairNomePublico = { String src ->
            def m = (src =~ /(?m)^\s*public\s+(?:class|interface|enum|record)\s+([A-Za-z_][A-Za-z0-9_]*)\b/)
            m.find() ? m.group(1) : null
        }
        def classesReferenciadasEmTestes = { String src ->
            def ignora = [
                'Assertions','Assert','System','Math','Objects','List','ArrayList','Arrays',
                'Collections','Stream','Optional','Files','Paths','Mockito','Matchers','Pattern','Matcher'
            ] as Set
            def nomes = [] as Set
            def pat = ~/(?m)([A-Z][A-Za-z0-9_]*)\s*\.\s*[A-Za-z_][A-Za-z0-9_]*\s*\(/
            def matcher = pat.matcher(src)
            while (matcher.find()) {
                def c = matcher.group(1)
                if (!ignora.contains(c)) nomes << c
            }
            return nomes
        }

        def sanitizeJavaTest = { String s ->
            if (s == null) return s
            s = s.replaceAll('(?m)^```\\w*\\s*\\r?\\n?', '')
            s = s.replaceAll('(?m)^```\\s*$', '')
            s = s.replace('\uFEFF', '')

            def lines = s.readLines()

            def isValidStart = { String ln ->
                return (ln ==~ /\s*/) ||                        // vazia
                    (ln ==~ /\s*package\s+.*/) ||
                    (ln ==~ /\s*import\s+.*/)  ||
                    (ln ==~ /\s*@.*/)          ||
                    (ln ==~ /\s*(public\s+)?(class|interface|enum|record)\b.*/) ||
                    (ln ==~ /\s*\/\/.*/) || (ln ==~ /\s*\/\*.*/) || (ln ==~ /\s*\*.*/)
            }

            // ✅ Regex sem slashy: evita erro do parser
            def fileNameOnly = Pattern.compile('^[A-Za-z0-9_.\\/\\-]+\\.java$')

            while (!lines.isEmpty() && !isValidStart(lines[0])) {
                def head = lines[0].trim()
                if (fileNameOnly.matcher(head).matches()) {  // "Algo.java" sozinho no topo
                    lines.remove(0)
                    continue
                }
                lines.remove(0) // qualquer lixo antes do primeiro token Java válido
            }
            return lines.join('\n')
        }

        // Carrega tudo
        def fontesUsuario = []
        def testesIA = []
        inputs.files.files.each { File origem ->
            boolean isTeste = origem.toPath().startsWith(dirTestsIA.toPath()) ||
                            origem.toPath().startsWith(dirTestsUsuario.toPath())
            String texto = origem.getText('UTF-8')
            (isTeste ? testesIA : fontesUsuario) << [file: origem, text: texto]
        }

        // Detecta pacote(s) do usuário
        def pacotesUsuario = fontesUsuario.collect { extrairPacote(it.text) }.toSet()
        String pacoteUsuario = (pacotesUsuario.size() == 1) ? pacotesUsuario.first() : ''  // se múltiplos, tratamos como default

        // Renome de classe pública se teste espera outro nome
        def nomesPublicosUsuario = fontesUsuario.collect { extrairNomePublico(it.text) }.findAll { it }
        def nomesReferenciadosTestes = classesReferenciadasEmTestes(testesIA.collect { it.text }.join("\n"))
        String nomePublico = (nomesPublicosUsuario ?: [null]).first()
        String nomeEsperado = (nomesReferenciadosTestes ?: [null]).first()
        boolean deveRenomear = (nomePublico && nomeEsperado && nomePublico != nomeEsperado &&
                                nomesPublicosUsuario.size()==1 && nomesReferenciadosTestes.size()==1)

        if (deveRenomear) {
            fontesUsuario = fontesUsuario.collect { f ->
                if (extrairNomePublico(f.text) == nomePublico) {
                    def novoTexto = f.text.replaceFirst(
                        /(?m)(^\s*public\s+(?:class|interface|enum|record)\s+)${java.util.regex.Pattern.quote(nomePublico)}\b/,
                        "\$1${nomeEsperado}"
                    )

                    def pacote = extrairPacote(novoTexto)
                    def caminhoPacote = pacote ? pacote.replace('.', File.separator) : ''
                    def repoDir = new File(dirEntrada, caminhoPacote)
                    repoDir.mkdirs()
                    new File(repoDir, "${nomeEsperado}.java").setText(novoTexto, 'UTF-8')
                    def antigo = new File(repoDir, "${nomePublico}.java")
                    if (antigo.exists()) {
                        antigo.delete()
                    }

                    [file: f.file, text: novoTexto]
                } else {
                    f
                }
            }

            println "organizarUsuario → renomeado classe pública '${nomePublico}' → '${nomeEsperado}' para alinhar com os testes"
        }

        def ajustarTesteParaPacoteUsuario = { String texto ->
            // 1) alinhar pacote
            String pkgTeste = extrairPacote(texto)
            if (pacoteUsuario == '') {
                texto = texto.replaceFirst(/(?m)^\s*package\s+[^;]+;\s*/, '')
            } else {
                if (pkgTeste == '') {
                    texto = "package ${pacoteUsuario};\n" + texto
                    pkgTeste = pacoteUsuario
                } else {
                    if (!texto.contains("import ${pacoteUsuario}.")) {
                        texto = texto.replaceFirst(/(?m)^(package\s+[^;]+;\s*)/, "\$1\nimport ${pacoteUsuario}.*;\n")
                    }
                }
            }

            // 2) injetar imports JDK comuns se faltarem
            def candidatos = [
                [sym: 'Random',              fqcn: 'java.util.Random'],
                [sym: 'Scanner',             fqcn: 'java.util.Scanner'],
                [sym: 'Arrays',              fqcn: 'java.util.Arrays'],
                [sym: 'List',                fqcn: 'java.util.List'],
                [sym: 'ArrayList',           fqcn: 'java.util.ArrayList'],
                [sym: 'LinkedList',          fqcn: 'java.util.LinkedList'],
                [sym: 'Deque',               fqcn: 'java.util.Deque'],
                [sym: 'ArrayDeque',          fqcn: 'java.util.ArrayDeque'],
                [sym: 'Queue',               fqcn: 'java.util.Queue'],
                [sym: 'Set',                 fqcn: 'java.util.Set'],
                [sym: 'HashSet',             fqcn: 'java.util.HashSet'],
                [sym: 'TreeSet',             fqcn: 'java.util.TreeSet'],
                [sym: 'Map',                 fqcn: 'java.util.Map'],
                [sym: 'HashMap',             fqcn: 'java.util.HashMap'],
                [sym: 'LinkedHashMap',       fqcn: 'java.util.LinkedHashMap'],
                [sym: 'TreeMap',             fqcn: 'java.util.TreeMap'],
                [sym: 'Collections',         fqcn: 'java.util.Collections'],
                [sym: 'Optional',            fqcn: 'java.util.Optional'],
                [sym: 'OptionalInt',         fqcn: 'java.util.OptionalInt'],
                [sym: 'OptionalLong',        fqcn: 'java.util.OptionalLong'],
                [sym: 'OptionalDouble',      fqcn: 'java.util.OptionalDouble'],
                [sym: 'Comparator',          fqcn: 'java.util.Comparator'],
                [sym: 'UUID',                fqcn: 'java.util.UUID'],
                [sym: 'Properties',          fqcn: 'java.util.Properties'],
                [sym: 'BitSet',              fqcn: 'java.util.BitSet'],
                [sym: 'Stream',              fqcn: 'java.util.stream.Stream'],
                [sym: 'IntStream',           fqcn: 'java.util.stream.IntStream'],
                [sym: 'LongStream',          fqcn: 'java.util.stream.LongStream'],
                [sym: 'DoubleStream',        fqcn: 'java.util.stream.DoubleStream'],
                [sym: 'Instant',             fqcn: 'java.time.Instant'],
                [sym: 'Duration',            fqcn: 'java.time.Duration'],
                [sym: 'Period',              fqcn: 'java.time.Period'],
                [sym: 'LocalDate',           fqcn: 'java.time.LocalDate'],
                [sym: 'LocalTime',           fqcn: 'java.time.LocalTime'],
                [sym: 'LocalDateTime',       fqcn: 'java.time.LocalDateTime'],
                [sym: 'ZonedDateTime',       fqcn: 'java.time.ZonedDateTime'],
                [sym: 'OffsetDateTime',      fqcn: 'java.time.OffsetDateTime'],
                [sym: 'ZoneId',              fqcn: 'java.time.ZoneId'],
                [sym: 'DateTimeFormatter',   fqcn: 'java.time.format.DateTimeFormatter'],
                [sym: 'Path',                fqcn: 'java.nio.file.Path'],
                [sym: 'Paths',               fqcn: 'java.nio.file.Paths'],
                [sym: 'Files',               fqcn: 'java.nio.file.Files'],
                [sym: 'StandardOpenOption',  fqcn: 'java.nio.file.StandardOpenOption'],
                [sym: 'Charset',             fqcn: 'java.nio.charset.Charset'],
                [sym: 'StandardCharsets',    fqcn: 'java.nio.charset.StandardCharsets'],
                [sym: 'File',                fqcn: 'java.io.File'],
                [sym: 'IOException',         fqcn: 'java.io.IOException'],
                [sym: 'InputStream',         fqcn: 'java.io.InputStream'],
                [sym: 'OutputStream',        fqcn: 'java.io.OutputStream'],
                [sym: 'FileInputStream',     fqcn: 'java.io.FileInputStream'],
                [sym: 'FileOutputStream',    fqcn: 'java.io.FileOutputStream'],
                [sym: 'Reader',              fqcn: 'java.io.Reader'],
                [sym: 'Writer',              fqcn: 'java.io.Writer'],
                [sym: 'BufferedReader',      fqcn: 'java.io.BufferedReader'],
                [sym: 'BufferedWriter',      fqcn: 'java.io.BufferedWriter'],
                [sym: 'InputStreamReader',   fqcn: 'java.io.InputStreamReader'],
                [sym: 'OutputStreamWriter',  fqcn: 'java.io.OutputStreamWriter'],
                [sym: 'FileReader',          fqcn: 'java.io.FileReader'],
                [sym: 'FileWriter',          fqcn: 'java.io.FileWriter'],
                [sym: 'PrintWriter',         fqcn: 'java.io.PrintWriter'],
                [sym: 'BigDecimal',          fqcn: 'java.math.BigDecimal'],
                [sym: 'BigInteger',          fqcn: 'java.math.BigInteger'],
                [sym: 'RoundingMode',        fqcn: 'java.math.RoundingMode'],
                [sym: 'Pattern',             fqcn: 'java.util.regex.Pattern'],
                [sym: 'Matcher',             fqcn: 'java.util.regex.Matcher'],
                [sym: 'URI',                 fqcn: 'java.net.URI'],
                [sym: 'URL',                 fqcn: 'java.net.URL'],
                [sym: 'URLEncoder',          fqcn: 'java.net.URLEncoder'],
                [sym: 'URLDecoder',          fqcn: 'java.net.URLDecoder'],
                [sym: 'HttpClient',          fqcn: 'java.net.http.HttpClient'],
                [sym: 'HttpRequest',         fqcn: 'java.net.http.HttpRequest'],
                [sym: 'HttpResponse',        fqcn: 'java.net.http.HttpResponse'],
                [sym: 'Objects',             fqcn: 'java.util.Objects'],
                [sym: 'StringJoiner',        fqcn: 'java.util.StringJoiner'],
                [sym: 'Spliterator',         fqcn: 'java.util.Spliterator'],
            ]

            def importados = [] as Set
            def impMatcher = (texto =~ /(?m)^\s*import\s+([a-zA-Z0-9_.]+)\s*;/)
            while (impMatcher.find()) {
                importados << impMatcher.group(1)
            }

            def paraInserir = []
            candidatos.each { c ->
                def usaSimbolo = (texto =~ /\b${c.sym}\b/).find()
                def jaTemImportDireto = importados.contains(c.fqcn)
                def jaTemWildcard = importados.any { it == c.fqcn.replaceAll(/\.[^.]+$/, '.*') }
                def jaUsaQualificado = (texto =~ /\b${java.util.regex.Pattern.quote(c.fqcn)}\b/).find()
                if (usaSimbolo && !jaTemImportDireto && !jaTemWildcard && !jaUsaQualificado) {
                    paraInserir << "import ${c.fqcn};"
                    importados << c.fqcn
                }
            }

            if (!paraInserir.isEmpty()) {
                if ((texto =~ /(?m)^\s*package\s+[^;]+;\s*$/).find()) {
                    texto = texto.replaceFirst(/(?m)^(package\s+[^;]+;\s*)/, "\$1\n" + paraInserir.join("\n") + "\n")
                } else {
                    texto = paraInserir.join("\n") + "\n" + texto
                }
            }

            return texto
        }

        def espelharParaRepo = { String texto ->
            String pacote = extrairPacote(texto)
            String caminhoPacote = pacote ? pacote.replace('.', File.separator) : ''
            File repoDir = caminhoPacote ? new File(dirEntrada, caminhoPacote) : dirEntrada
            repoDir.mkdirs()

            String nomePublicoLocal = extrairNomePublico(texto)
            String nomeArquivo = nomePublicoLocal ? "${nomePublicoLocal}.java" : "Arquivo_${System.nanoTime()}.java"
            new File(repoDir, nomeArquivo).setText(texto, 'UTF-8')
        }

        // --- Helpers p/ testes: stub + hook por reflexão ---
        def injetarStubLoginAttempt = {
            String pacote = pacoteUsuario ?: ''
            String header = pacote ? "package ${pacote};\n" : ""
            def destinoDir = pacote ? new File(dirTest, pacote.replace('.', File.separator)) : dirTest
            destinoDir.mkdirs()
            new File(destinoDir, "LoginAttempt.java").setText(
                """${header}
                public class LoginAttempt {
                    public String user;
                    public boolean success;
                    public long timestamp;
                    public LoginAttempt() {}
                    public LoginAttempt(String user, boolean success, long ts){
                        this.user = user; this.success = success; this.timestamp = ts;
                    }
                }
                """.stripIndent(), "UTF-8")
            println "organizarUsuario → stub LoginAttempt injetado em testes"
        }

        def injetarTestHooks = {
            String pacote = pacoteUsuario ?: ''
            String header = pacote ? "package ${pacote};\n" : ""
            def destinoDir = pacote ? new File(dirTest, pacote.replace('.', File.separator)) : dirTest
            destinoDir.mkdirs()
            new File(destinoDir, "TestHooks.java").setText(
                """${header}
                import java.lang.reflect.Field;
                import java.util.Map;

                public final class TestHooks {
                    private TestHooks() {}

                    @SuppressWarnings("unchecked")
                    public static void setActive(Object ums, String username, boolean active) {
                        try {
                            Class<?> cls = ums.getClass();
                            Field fUsers = cls.getDeclaredField("users");
                            fUsers.setAccessible(true);
                            Object mapObj = fUsers.get(ums);
                            Object userObj = ((Map<String, ?>) mapObj).get(username);
                            if (userObj == null) return;
                            Field fActive = userObj.getClass().getDeclaredField("isActive");
                            fActive.setAccessible(true);
                            fActive.setBoolean(userObj, active);
                        } catch (Exception e) {
                            throw new RuntimeException("TestHooks.setActive falhou", e);
                        }
                    }
                }
                """.stripIndent(), "UTF-8")
            println "organizarUsuario → TestHooks injetado em testes"
        }

        def gravar = { String texto, boolean isTeste ->
            if (isTeste) {
                texto = sanitizeJavaTest(texto)
                texto = ajustarTesteParaPacoteUsuario(texto)
            }
            String pacote = extrairPacote(texto)
            String caminhoPacote = pacote ? pacote.replace('.', File.separator) : ''
            File baseDestino = isTeste ? dirTest : dirMain
            File destinoDir = caminhoPacote ? new File(baseDestino, caminhoPacote) : baseDestino
            destinoDir.mkdirs()

            String nomePublicoLocal = extrairNomePublico(texto)
            String nomeArquivo = nomePublicoLocal ? "${nomePublicoLocal}.java" : "Arquivo_${System.nanoTime()}.java"
            new File(destinoDir, nomeArquivo).setText(texto, 'UTF-8')

            if (!isTeste) {
                espelharParaRepo(texto)
            }
        }

        testesIA = testesIA.collect { ti ->
            String t = sanitizeJavaTest(ti.text)
            String patched = t.replaceAll(
                /(\\b[A-Za-z_][A-Za-z0-9_]*)\\.users\\.get\\(([^)]+)\\)\\.isActive\\s*=\\s*(true|false)\\s*;/,
                'TestHooks.setActive($1, $2, $3);'
            )
            if (patched.contains("LoginAttempt")) {
                injetarStubLoginAttempt()
            }
            if (!patched.equals(t) || patched.contains("TestHooks.setActive(")) {
                injetarTestHooks()
            }
            [file: ti.file, text: patched]
        }

        // --- SANEAMENTO DE FONTES DE PRODUÇÃO ---
        def sanitizeJavaMain = { String s ->
            if (s == null) return s
            s = s.replace('\uFEFF','')
            s = s.replaceAll('(?m)^```\\w*\\s*\\r?\\n?', '')
            s = s.replaceAll('(?m)^```\\s*$', '')

            def lines = s.readLines()
            def inicioValido = { String ln ->
                ln ==~ /\s*/ ||
                ln ==~ /\s*package\s+.*/ ||
                ln ==~ /\s*import\s+.*/  ||
                ln ==~ /\s*@.*/          ||
                ln ==~ /\s*(public\s+)?(class|interface|enum|record)\b.*/ ||
                ln ==~ /\s*\/\/.*/ || ln ==~ /\s*\/\*.*/ || ln ==~ /\s*\*.*/
            }
            while (!lines.isEmpty() && !inicioValido(lines[0])) { lines.remove(0) }
            s = lines.join('\n')

            s = s.replaceFirst(/^\s*}\s*(public\s+(class|interface|enum|record)\s+)/, '$1')

            def declMatcher = (s =~ /(?m)^\s*public\s+(class|interface|enum|record)\s+([A-Za-z_]\w*)\b/)
            def decls = []
            while (declMatcher.find()) {
                decls << [pos: declMatcher.start(), nome: declMatcher.group(2)]
            }
            if (decls.size() >= 2) {
                def ultima = decls.last()
                def existeAnteriorMesmoNome = decls[0..-2].any { it.nome == ultima.nome }
                if (existeAnteriorMesmoNome) {
                    s = s.substring(ultima.pos)
                }
            }

            return s
        }

        fontesUsuario = fontesUsuario.collect { f ->
            [file: f.file, text: sanitizeJavaMain(f.text)]
        }

        fontesUsuario.each { gravar(it.text, false) }
        testesIA.each     { gravar(it.text, true)  }

        // --- [INÍCIO: injeção condicional de stubs do modelo] ---
        def modeloPkgPath = new File(dirMain, "org/example/model")
        def modeloJaExiste = { String nome ->
            def f1 = new File(modeloPkgPath, "${nome}.java")
            if (f1.exists()) return true
            return fileTree(dirEntrada) {
                include "**/${nome}.java"
            }.any { it.text.contains("package org.example.model") }
        }

        def allText = (fontesUsuario.collect{it.text} + testesIA.collect{it.text}).join("\n")
        def precisaRel   = allText.contains("RelatorioCobertura") && !modeloJaExiste("RelatorioCobertura")
        def precisaClasse= allText.contains("ClasseCoberta")      && !modeloJaExiste("ClasseCoberta")
        def precisaMetodo= allText.contains("MetodoCoberto")      && !modeloJaExiste("MetodoCoberto")

        if (precisaRel || precisaClasse || precisaMetodo) {
            modeloPkgPath.mkdirs()

            if (precisaMetodo) {
                new File(modeloPkgPath, "MetodoCoberto.java").setText("""
                    package org.example.model;
                    public record MetodoCoberto(String nome, int linhaInicio, int linhaFim, double cobertura) {}
                """.stripIndent(), "UTF-8")
            }

            if (precisaClasse) {
                new File(modeloPkgPath, "ClasseCoberta.java").setText("""
                    package org.example.model;
                    import java.util.List;
                    public record ClasseCoberta(String nome, String caminho, List<MetodoCoberto> metodos) {}
                """.stripIndent(), "UTF-8")
            }

            if (precisaRel) {
                new File(modeloPkgPath, "RelatorioCobertura.java").setText("""
                    package org.example.model;
                    import java.util.List;
                    public final class RelatorioCobertura {
                        public enum Ferramenta { JACOCO, OUTRA }
                        private final String caminhoRelatorio;
                        private final List<ClasseCoberta> classes;
                        private final Ferramenta ferramenta;
                        public RelatorioCobertura(String caminhoRelatorio, List<ClasseCoberta> classes, Ferramenta ferramenta) {
                            this.caminhoRelatorio = caminhoRelatorio;
                            this.classes = classes;
                            this.ferramenta = ferramenta;
                        }
                        public String caminhoRelatorio() { return caminhoRelatorio; }
                        public List<ClasseCoberta> classes() { return classes; }
                        public Ferramenta ferramenta() { return ferramenta; }
                    }
                """.stripIndent(), "UTF-8")
            }

            println "organizarUsuario → stubs injetados em org.example.model: " +
                    [(precisaMetodo?'MetodoCoberto':null),(precisaClasse?'ClasseCoberta':null),(precisaRel?'RelatorioCobertura':null)]
                    .findAll{it!=null}.join(", ")
        }
        // --- [FIM: injeção condicional de stubs do modelo] ---

        println "organizarUsuario → copiado para main: ${dirMain.absolutePath}"
        println "organizarUsuario → copiado para test: ${dirTest.absolutePath}"
        println "organizarUsuario → fontes recebidos: ${fontesUsuario.size()}"
        println "organizarUsuario → testes recebidos:  ${testesIA.size()}"
        if (nomePublico)  println "organizarUsuario → nome público (usuario): ${nomePublico}"
        if (nomeEsperado) println "organizarUsuario → nome esperado (testes): ${nomeEsperado}"
        if (pacoteUsuario) println "organizarUsuario → pacote do usuário detectado: ${pacoteUsuario}"
    }
}

sourceSets {
    usuario {
        java {
            srcDirs = [dirMain]
        }
        resources.srcDirs = []
    }
    usuarioTest {
        java {
            srcDirs = [dirTest]
        }
        resources.srcDirs = []
        compileClasspath += sourceSets.usuario.output
        runtimeClasspath  += sourceSets.usuario.output
    }
}

// compila main só depois de organizar e resolver libs
tasks.named(sourceSets.usuario.compileJavaTaskName) {
    dependsOn 'organizarUsuario', 'resolverDepsUsuario'
}

// compila testes só depois de organizar, resolver libs e compilar main
tasks.named(sourceSets.usuarioTest.compileJavaTaskName) {
    dependsOn 'organizarUsuario', 'resolverDepsUsuario', tasks.named(sourceSets.usuario.classesTaskName)
}

tasks.register('testUsuario', Test) {
    dependsOn tasks.named(sourceSets.usuario.classesTaskName),
              tasks.named(sourceSets.usuarioTest.classesTaskName)

    testClassesDirs = sourceSets.usuarioTest.output.classesDirs
    classpath       = sourceSets.usuarioTest.runtimeClasspath
    useJUnitPlatform()

    // NÃO derrubar o build se testes falharem (para o JaCoCo rodar)
    ignoreFailures = true

    // .exec fixo
    jacoco {
        destinationFile = layout.buildDirectory.file("jacoco/testUsuario.exec").get().asFile
    }

    // log resumido
    afterSuite { desc, result ->
        if (!desc.parent) {
            println "Resumo testUsuario -> total: ${result.testCount}, " +
                    "passaram: ${result.successfulTestCount}, " +
                    "falharam: ${result.failedTestCount}, " +
                    "skipped: ${result.skippedTestCount}"
        }
    }

    finalizedBy('jacocoRelatorioUsuario') // execução "completa"
}

// === JaCoCo (relatório para o Codecov) ===
jacoco {
    toolVersion = '0.8.12'
}

// sanearTestesUsuario — registra se não existir; senão, apenas configura
def configurarSanear = { ->
    doLast {
        def baseMain = file("$buildDir/usuario-src/src/main/java")
        def baseTest = file("$buildDir/usuario-src/src/test/java")
        if (!baseTest.exists()) return

        // Descobre 1) pacote principal; 2) uma classe pública para uso no smoke test
        def descobrirPacote = { File raiz ->
            if (!raiz?.exists()) return null
            def candidatos = []
            raiz.eachFileRecurse { f ->
                if (f.isFile() && f.name.endsWith(".java") && f.name != "module-info.java") {
                    def txt = f.getText("UTF-8")
                    def m = (txt =~ /(?m)^\s*package\s+([A-Za-z_][\w.]*?)\s*;\s*$/)
                    candidatos << (m.find() ? m.group(1) : null)
                }
            }
            if (candidatos.isEmpty()) return null
            def comPacote = candidatos.find { it != null }
            return comPacote ?: null
        }

        def descobrirPublicClass = { File raiz ->
            if (!raiz?.exists()) return null
            def nome = null
            raiz.eachFileRecurse { f ->
                if (nome != null) return
                if (f.isFile() && f.name.endsWith(".java") && f.name != "module-info.java") {
                    def txt = f.getText("UTF-8")
                    def m = (txt =~ /(?m)^\s*public\s+(?:class|interface|enum|record)\s+([A-Za-z_]\w*)\b/)
                    if (m.find()) nome = m.group(1)
                }
            }
            return nome
        }

        def pacoteMain = descobrirPacote(baseMain)
        def classePublica = descobrirPublicClass(baseMain) ?: "Object"

        // Helpers
        def isValidStart = { String ln ->
            return (ln ==~ /\s*/) ||                        // vazia
                   (ln ==~ /\s*package\s+.*/) ||
                   (ln ==~ /\s*import\s+.*/)  ||
                   (ln ==~ /\s*@.*/)          ||
                   (ln ==~ /\s*(public\s+)?(class|interface|enum|record)\b.*/) ||
                   (ln ==~ /\s*\/\/.*/) || (ln ==~ /\s*\/\*.*/) || (ln ==~ /\s*\*.*/)
        }

        def limparLixoTopo = { String s ->
            if (s == null) return s
            s = s.replace('\uFEFF','')
            s = s.replaceAll('(?m)^```\\w*\\s*\\r?\\n?', '')
            s = s.replaceAll('(?m)^```\\s*$', '')
            s = s.replaceAll('(?m)^====+.*$', '')
            s = s.replaceAll('(?m)^----+.*$', '')
            s = s.replaceAll('(?m)^CODE:?\\s*$', '')
            s = s.replaceAll('(?m)^CÓDIGO:?\\s*$', '')
            def linhas = s.readLines()
            while (!linhas.isEmpty() && !isValidStart(linhas[0])) {
                def head = linhas[0].trim()
                if (head.matches('[A-Za-z0-9_.\\\\/\\-]+\\.java')) {
                    linhas.remove(0)
                } else {
                    linhas.remove(0)
                }
            }
            return linhas.join('\n')
        }

        def balancearChaves = { String s ->
            int abre = 0
            for (ch in s.toCharArray()) {
                if (ch == '{') abre++
                else if (ch == '}') abre = Math.max(0, abre - 1)
            }
            if (abre > 0) {
                s = s + ("\n" + ("}" * abre) + "\n")
            }
            return s
        }

        def injetarImportsJUnit = { String conteudo ->
            def usaAssertions = (conteudo =~ /\bassert(?:Equals|True|False|NotNull|Null|Throws|All|DoesNotThrow|ArrayEquals|IterableEquals|LinesMatch|Same|NotSame)\s*\(/).find()
            def temStaticAssertions = (conteudo =~ /(?m)^\s*import\s+static\s+org\.junit\.jupiter\.api\.Assertions\.\*\s*;\s*$/).find()
            def temQualificadoAssertions = (conteudo =~ /\borg\.junit\.jupiter\.api\.Assertions\./).find()

            if (usaAssertions && !temStaticAssertions && !temQualificadoAssertions) {
                if ((conteudo =~ /(?m)^\s*package\s+[^;]+;\s*$/).find()) {
                    conteudo = conteudo.replaceFirst(/(?m)^(package\s+[^;]+;\s*)/, "\$1\nimport static org.junit.jupiter.api.Assertions.*;\n")
                } else {
                    conteudo = "import static org.junit.jupiter.api.Assertions.*;\n" + conteudo
                }
            }
            if ((conteudo =~ /(?<!\.)\bassertThrows\s*\(/).find() && !temStaticAssertions) {
                conteudo = conteudo.replaceAll(/(?<!\.)\bassertThrows\s*\(/, "org.junit.jupiter.api.Assertions.assertThrows(")
            }
            if (conteudo.contains("@Test") && !(conteudo =~ /(?m)^\s*import\s+org\.junit\.jupiter\.api\.Test\s*;\s*$/).find()) {
                if ((conteudo =~ /(?m)^\s*package\s+[^;]+;\s*$/).find()) {
                    conteudo = conteudo.replaceFirst(/(?m)^(package\s+[^;]+;\s*)/, "\$1\nimport org.junit.jupiter.api.Test;\n")
                } else {
                    conteudo = "import org.junit.jupiter.api.Test;\n" + conteudo
                }
            }
            return conteudo
        }

        int qtdTestsValidos = 0

        baseTest.eachFileRecurse { f ->
            if (!(f.isFile() && f.name.endsWith(".java"))) return
            def conteudo = f.getText("UTF-8")

            conteudo = limparLixoTopo(conteudo)

            String pacoteTeste = null
            def mPkg = (conteudo =~ /(?m)^\s*package\s+([A-Za-z_][\w.]*?)\s*;\s*$/)
            if (mPkg.find()) pacoteTeste = mPkg.group(1)

            if (pacoteMain == null) {
                if (pacoteTeste != null) {
                    conteudo = conteudo.replaceFirst("(?m)^\\s*package\\s+[A-Za-z_][\\w.]*?\\s*;\\s*\\n?", "")
                }
            } else {
                if (pacoteTeste == null) {
                    conteudo = "package ${pacoteMain};\n\n" + conteudo
                    pacoteTeste = pacoteMain
                } else {
                    def jaImporta = conteudo.contains("import ${pacoteMain}.*;") || conteudo.contains("import ${pacoteMain}.")
                    if (!jaImporta && pacoteTeste != pacoteMain) {
                        conteudo = conteudo.replaceFirst("(?s)^(\\s*package\\s+[^{;]+;\\s*)", "\$1\nimport ${pacoteMain}.*;\n")
                    }
                }
            }

            conteudo = conteudo.replaceAll('(?m)^\\s*[A-Za-z0-9_.\\\\/\\-]+\\.java\\s*$', '')
            conteudo = conteudo.replaceAll('(?m)^\\s*>\\s*Task\\s*:\\S+\\s*$', '')
            conteudo = conteudo.replaceAll('(?m)^\\s*\\[?Incubating\\]?.*$', '')
            conteudo = conteudo.replaceAll('(?m)^\\s*Deprecated Gradle features.*$', '')

            conteudo = injetarImportsJUnit(conteudo)

            // 1) finalizar linhas double sem ';'
            conteudo = conteudo.replaceAll('(?m)^(\\s*double\\s+[^;\\n{}]+)(\\s*)$', '$1;$2')
                               .replaceAll('(?m)\\b(char)\\s+([A-Za-z_]\\w*)\\s*=\\s*;', '$1 $2 = \'\\0\';')

            // 2) Corrige declarações com '=;' sem valor inicial
            // 2) Corrige declarações com '= +;' ou '= -;' (sem valor) e depois '=;' sem valor
            conteudo = conteudo
                // casos com sinal isolado após o '='
                .replaceAll('(?m)\\b(double|float)\\s+([A-Za-z_]\\w*)\\s*=\\s*[+-]?\\s*;', '$1 $2 = 0.0;')
                .replaceAll('(?m)\\b(int|long|short|byte)\\s+([A-Za-z_]\\w*)\\s*=\\s*[+-]?\\s*;', '$1 $2 = 0;')
                // casos '=;' puros
                .replaceAll('(?m)\\b(double|float)\\s+([A-Za-z_]\\w*)\\s*=\\s*;', '$1 $2 = 0.0;')
                .replaceAll('(?m)\\b(int|long|short|byte)\\s+([A-Za-z_]\\w*)\\s*=\\s*;', '$1 $2 = 0;')
                .replaceAll('(?m)\\b(boolean)\\s+([A-Za-z_]\\w*)\\s*=\\s*;', '$1 $2 = false;')
                .replaceAll('(?m)\\b(char)\\s+([A-Za-z_]\\w*)\\s*=\\s*;', '$1 $2 = \'\\0\';')
                .replaceAll('(?m)\\b(String)\\s+([A-Za-z_]\\w*)\\s*=\\s*;', '$1 $2 = "";')
                .replaceAll('(?m)\\b([A-Za-z_][\\w<>\\[\\]]*)\\s+([A-Za-z_]\\w*)\\s*=\\s*;', '$1 $2;')

            // Corrige assertThrows truncado na mesma linha (se a linha não fecha com ');')
            conteudo = conteudo.replaceAll(
                '(?m)^\\s*(?:org\\.junit\\.jupiter\\.api\\.Assertions\\.)?assertThrows\\([^;\\n]*$',
                'org.junit.jupiter.api.Assertions.assertThrows(ArithmeticException.class, () -> { throw new ArithmeticException(); });'
            )

            // Dá corpo a métodos "void nome(...)" sem abrir bloco
            conteudo = conteudo.replaceAll(
                '(?m)^\\s*(public|protected|private)?\\s+void\\s+[A-Za-z_]\\w*\\s*\\([^)]*\\)\\s*$',
                '$0 { }'
            )

            // --- Fallback genérico: se o RHS (depois do '=') não tem letras/dígitos/aspas, troca por default ---
            // (cobre casos como "= -;", "= + ;", "= /**/ ;", "= ??? ;" e similares)
            def ehRhsLixo = { String rhs ->
                if (rhs == null) return true
                def t = rhs.trim()
                if (t.isEmpty()) return true
                // Se NÃO houver nenhuma letra, dígito ou aspas simples/duplas, consideramos lixo
                return !((t =~ /[A-Za-z0-9'"]/).find())
            }

            def defaultDe = { String tipo ->
                switch (tipo) {
                    case 'float'  : return '0.0f'
                    case 'double' : return '0.0'
                    case ['int','long','short','byte']: return '0'
                    case 'boolean': return 'false'
                    case 'char'   : return "'\\0'"
                    case 'String' : return '""'
                    default       : return null
                }
            }

            // 1) Tipos primitivos + String com fallback por tipo
            conteudo = conteudo.replaceAll(
                ~/(?m)\b(double|float|int|long|short|byte|boolean|char|String)\s+([A-Za-z_]\w*)\s*=\s*([^;]*);/
            ) { all, tipo, nome, rhs ->
                if (ehRhsLixo(rhs)) {
                    def d = defaultDe(tipo)
                    return d != null ? "${tipo} ${nome} = ${d};" : "${tipo} ${nome};"
                }
                return all
            }

            // 2) Qualquer outro tipo: se RHS é lixo, apenas remove a atribuição
            conteudo = conteudo.replaceAll(
                ~/(?m)\b([A-Za-z_][\w<>\[\]]*)\s+([A-Za-z_]\w*)\s*=\s*([^;]*);/
            ) { all, tipo, nome, rhs ->
                ehRhsLixo(rhs) ? "${tipo} ${nome};" : all
            }

            conteudo = balancearChaves(conteudo)

            boolean temAnotacaoTest = conteudo.contains("@Test")
            boolean temClass = (conteudo =~ /(?m)^\s*(public\s+)?(class|interface|enum|record)\b/).find()
            // Depois dos fixes que adicionam "{ }" em métodos void, já dá para detectar método com "{"
            boolean temMetodo = (conteudo =~ /(?m)^\s*(public|protected|private)?\s+void\s+[A-Za-z_]\w*\s*\([^)]*\)\s*\{/).find()

            if (!temClass && (temAnotacaoTest || temMetodo)) {
                String header = (pacoteMain != null) ? "package ${pacoteMain};\n" : ""
                def imports = []
                // (corrigido: usar \s, não \\s, dentro de slashy regex)
                def mImp = (conteudo =~ /(?m)^\s*import\s+.*;\s*$/)
                while (mImp.find()) imports << mImp.group()
                def corpo = conteudo.replaceAll(/(?m)^\s*import\s+.*;\s*$/, "").trim()
                conteudo =
                    header +
                    (imports.isEmpty() ? "" : (imports.join("\n") + "\n")) +
                    "\npublic class UsuarioTestsAuto {\n" +
                    corpo + "\n}\n"
            }

            // (corrigido: usar \s,\w,\b — não \\s,\\w,\\b — dentro de slashy regex)
            boolean valido = ((conteudo =~ /(?m)^\s*public\s+class\s+\w+\b/).find() && conteudo.contains("@Test"))
            if (valido) qtdTestsValidos++

            f.setText(conteudo, "UTF-8")
        }

        if (qtdTestsValidos == 0) {
            def destinoDir = (pacoteMain != null) ? new File(baseTest, pacoteMain.replace('.', File.separator)) : baseTest
            destinoDir.mkdirs()
            new File(destinoDir, "AutoSmokeTest.java").setText(
                """${pacoteMain ? "package ${pacoteMain};\n" : ""}
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class AutoSmokeTest {
    @Test
    void smoke() {
        Object obj;
        try {
            obj = ${classePublica}.class.getDeclaredConstructor().newInstance();
        } catch (Throwable t) {
            obj = new Object();
        }
        assertNotNull(obj);
    }
}
""", "UTF-8")
            println "sanearTestesUsuario → nenhum teste válido detectado; AutoSmokeTest.java gerado para garantir execução e cobertura."
        }
    }
}
if (tasks.findByName("sanearTestesUsuario") == null) {
    tasks.register("sanearTestesUsuario") { configurarSanear.delegate = it; configurarSanear() }
} else {
    tasks.named("sanearTestesUsuario").configure { configurarSanear.delegate = it; configurarSanear() }
}

tasks.named("compileUsuarioTestJava") {
    dependsOn("sanearTestesUsuario")
    options.encoding = "UTF-8"
}

// ===== JaCoCo — configuração mínima e robusta =====
jacoco { toolVersion = "0.8.12" }

// 2) Relatório do JaCoCo "completo" (para rodadas normais)
tasks.register("jacocoRelatorioUsuario", JacocoReport) {
    dependsOn "testUsuario", "classes", tasks.named(sourceSets.usuario.classesTaskName)

    executionData.from(file("$buildDir/jacoco/testUsuario.exec"))

    sourceDirectories.from = files(
        sourceSets.main.allSource.srcDirs,
        (sourceSets.findByName("usuario")?.allSource?.srcDirs ?: [])
    )
    classDirectories.from = files(
        fileTree(dir: "$buildDir/classes/java/main",    exclude: ['**/*$*']),
        fileTree(dir: "$buildDir/classes/java/usuario", exclude: ['**/*$*'])
    )

    reports {
        xml.required = true
        html.required = true
        csv.required = false
        xml.outputLocation = file("$projectDir/entrada-usuario/jacoco-relatorio/jacoco.xml")
        html.outputLocation = file("$projectDir/entrada-usuario/jacoco-relatorio/html")
    }

    doFirst { file("$projectDir/entrada-usuario/jacoco-relatorio/html").mkdirs() }
}

// ---> Verificação de cobertura (não-fatal por padrão; fatal só com -PenforceCoverage=true ou ENFORCE_COVERAGE=true)
tasks.register("coberturaMinimaUsuario") {
    dependsOn "jacocoRelatorioUsuario"
    doLast {
        def thr = (project.findProperty("coverageMinUsuario") ?: System.getenv("MIN_COVERAGE") ?: "0.60") as BigDecimal
        def enforce = (project.findProperty("enforceCoverage") ?: System.getenv("ENFORCE_COVERAGE") ?: "false").toString().equalsIgnoreCase("true")

        def xml = file("$projectDir/entrada-usuario/jacoco-relatorio/jacoco.xml")
        if (!xml.exists() || xml.length() == 0) {
            logger.warn("coberturaMinimaUsuario → jacoco.xml não encontrado; pulando verificação.")
            return
        }

        def sl = new groovy.xml.XmlSlurper().parse(xml)
        long missed = 0
        long covered = 0

        sl.'**'.findAll { it.name() == 'counter' && it.@type?.text() == 'LINE' }.each { c ->
            missed += (c.@missed.text() as long)
            covered += (c.@covered.text() as long)
        }

        long total = missed + covered
        if (total == 0) {
            logger.warn("coberturaMinimaUsuario → relatório sem linhas contadas; pulando verificação.")
            return
        }

        BigDecimal pct = total ? (covered as BigDecimal) / (total as BigDecimal) : 0
        def pctFmt = String.format(java.util.Locale.US, "%.2f", pct * 100)
        def thrFmt = String.format(java.util.Locale.US, "%.0f", (thr * 100))

        println "coberturaMinimaUsuario → Cobertura de linhas: ${pctFmt}%  (threshold: ${thrFmt}%)"

        if (pct < thr) {
            if (enforce) {
                throw new GradleException("Cobertura (${pctFmt}%) abaixo do mínimo (${thrFmt}%).")
            } else {
                logger.warn("Cobertura (${pctFmt}%) abaixo do mínimo (${thrFmt}%). Sinalizando apenas (não-fatal).")
            }
        }
    }
}

// === Caminho BEST-EFFORT para o CI/Codecov ===

// Teste best-effort: não depende de compilar os testes agora; usa o que existir e não falha
tasks.register("testUsuarioBestEffort", Test) {
    ignoreFailures = true
    useJUnitPlatform()

    testClassesDirs = files(
        file("$buildDir/classes/java/usuarioTest")
    )
    classpath = files(
        fileTree("$buildDir/classes/java/usuario"),
        fileTree("$buildDir/classes/java/main"),
        sourceSets.findByName("usuarioTest")?.runtimeClasspath ?: files()
    )

    outputs.upToDateWhen { false }
    doFirst { file("$buildDir/jacoco").mkdirs() }
    jacoco { destinationFile = file("$buildDir/jacoco/testUsuario.exec") }
}

// Relatório best-effort: só roda se existir .exec
tasks.register("jacocoRelatorioUsuarioBestEffort", JacocoReport) {
    def execFile = file("$buildDir/jacoco/testUsuario.exec")

    onlyIf { execFile.exists() }
    executionData.setFrom(execFile.exists() ? files(execFile) : files())

    sourceDirectories.from = files(
        sourceSets.main.allSource.srcDirs,
        (sourceSets.findByName("usuario")?.allSource?.srcDirs ?: [])
    )
    classDirectories.from = files(
        fileTree(dir: "$buildDir/classes/java/main",    exclude: ['**/*$*']),
        fileTree(dir: "$buildDir/classes/java/usuario", exclude: ['**/*$*'])
    )

    reports {
        xml.required = true
        html.required = true
        csv.required = false
        xml.outputLocation = file("$projectDir/entrada-usuario/jacoco-relatorio/jacoco.xml")
        html.outputLocation = file("$projectDir/entrada-usuario/jacoco-relatorio/html")
    }

    doFirst { file("$projectDir/entrada-usuario/jacoco-relatorio/html").mkdirs() }
}

// Garantia: se o XML não sair (porque não houve exec), cria vazio para Codecov
tasks.register("jacocoXmlGarantido") {
    doLast {
        def xml = file("$projectDir/entrada-usuario/jacoco-relatorio/jacoco.xml")
        if (!xml.exists() || xml.length() == 0) {
            xml.parentFile.mkdirs()
            xml.text = '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<report name="empty">
  <sessioninfo id="none" start="0" dump="0"/>
  <counter type="INSTRUCTION" missed="0" covered="0"/>
  <counter type="LINE" missed="0" covered="0"/>
  <counter type="COMPLEXITY" missed="0" covered="0"/>
  <counter type="METHOD" missed="0" covered="0"/>
  <counter type="CLASS" missed="0" covered="0"/>
</report>
'''
            println "jacocoXmlGarantido → jacoco.xml vazio (sem exec) — fallback para Codecov."
        }
    }
}

// Alias do CI: tenta executar e reportar; se não conseguir, cai no XML vazio
tasks.register("covUsuario") {
    dependsOn "testUsuarioBestEffort"
    dependsOn "jacocoRelatorioUsuarioBestEffort"
    finalizedBy "jacocoXmlGarantido"
}

// --- Demais integrações que você já tinha ---

def _configJacocoRelatorioGeral = { JacocoReport t ->
    t.dependsOn(tasks.findByName("test"), tasks.findByName("testUsuario"))
    t.executionData fileTree(projectDir) { include "**/build/jacoco/*.exec", "**/jacoco/*.exec" }
    t.sourceDirectories.from = files(
        sourceSets.main.allSource.srcDirs,
        (sourceSets.findByName("usuario")?.allSource?.srcDirs ?: [])
    )
    t.classDirectories.from = files(
        fileTree(dir: "$buildDir/classes/java/main"),
        fileTree(dir: "$buildDir/classes/java/usuario")
    )
    t.reports {
        xml.required = true
        html.required = true
        csv.required = false
        html.outputLocation = layout.buildDirectory.dir("reports/jacoco/geral").get().asFile
    }
}

if (tasks.findByName("jacocoRelatorioGeral") != null) {
    tasks.named("jacocoRelatorioGeral", JacocoReport).configure { _configJacocoRelatorioGeral(it) }
} else {
    tasks.register("jacocoRelatorioGeral", JacocoReport) { _configJacocoRelatorioGeral(it) }
}

tasks.named("jacocoRelatorioUsuario") {
    finalizedBy("jacocoRelatorioGeral")
}

tasks.named("jacocoRelatorioUsuario") {
    finalizedBy("coberturaMinimaUsuario")   // verificação após o relatório "completo"
}

tasks.register('usuarioCobertura') {
    dependsOn 'testUsuario'
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()
    testLogging {
        events "passed","skipped","failed"
        showStandardStreams = false
        exceptionFormat "short"
    }
}

dependencies {
    usuarioTestImplementation platform('org.junit:junit-bom:5.10.2')
    usuarioTestImplementation 'org.junit.jupiter:junit-jupiter'
    usuarioTestRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    usuarioImplementation fileTree('entrada-usuario/libs') { include '*.jar' }
    testImplementation 'org.mockito:mockito-core:5.13.0'
}

tasks.withType(JavaExec).configureEach {
    environment 'JAVA_TOOL_OPTIONS', '-Dfile.encoding=UTF-8'
}

tasks.named('test') {
    useJUnitPlatform()
}
