<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Processando…</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
</head>
<body class="min-h-screen bg-gray-50 flex items-center justify-center">
  <div class="w-full max-w-md mx-4">
    <div class="bg-white shadow rounded-2xl p-8 text-center">
      <div class="flex items-center justify-center mb-4">
        <i data-feather="loader" class="w-10 h-10 animate-spin text-blue-600"></i>
      </div>
      <h1 class="text-xl font-semibold text-gray-800 mb-2">Estamos processando seu código…</h1>
      <p id="msg" class="text-gray-500">Aguarde enquanto a pipeline executa.</p>

      <div id="errBox" class="hidden mt-4 text-sm text-red-700 bg-red-50 border border-red-200 rounded p-3 text-left"></div>

      <div class="mt-6">
        <a href="index.html" class="text-sm text-gray-500 hover:underline">Voltar</a>
      </div>
    </div>
  </div>

<script>
feather.replace();

/** ======== CONFIG ======== */
let OWNER         = 'lipesanfelice';
let REPO          = 'workflows';
let BRANCH        = 'main';
let WORKFLOW_FILE = '.github/workflows/ci.yml'; // <- caminho do workflow no repo

// Permite override via query string (útil p/ testes)
const qs = new URLSearchParams(location.search);
OWNER         = qs.get('owner')  || OWNER;
REPO          = qs.get('repo')   || REPO;
BRANCH        = qs.get('branch') || BRANCH;
WORKFLOW_FILE = qs.get('wf')     || WORKFLOW_FILE;

// Endpoints
const GH_RUNS_URL = `https://api.github.com/repos/${OWNER}/${REPO}/actions/workflows/${encodeURIComponent(WORKFLOW_FILE)}/runs?branch=${encodeURIComponent(BRANCH)}&per_page=1&event=push`;
const DONE_URL    = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/app/entrada-usuario/done.json`;

const POLL_MS         = 1200;     // intervalo primário (rápido)
const FALLBACK_POLL_MS= 2000;     // intervalo quando em fallback
const HARD_TIMEOUT_MS = 18*60*1000; // fail-safe geral (~18min)

const msgEl  = document.getElementById('msg');
const errBox = document.getElementById('errBox');

function showErr(s){
  errBox.classList.remove('hidden');
  errBox.textContent = s;
}
function toResults(status, runId){
  const t = runId ? String(runId) : String(Date.now());
  const url = new URL('results.html', location.href);
  if (status) url.searchParams.set('status', status);
  url.searchParams.set('t', t);  // marca para cache-busting na results.html
  location.href = url.toString();
}

/** ============== 1) Poll pela API do GitHub Actions (rápida) ============== */
async function pollGithubActions(){
  try{
    // cache bust + no-store
    const url = `${GH_RUNS_URL}&t=${Date.now()}`;
    const r = await fetch(url, {
      cache:'no-store',
      headers:{
        'Accept':'application/vnd.github+json',
        'Cache-Control':'no-store, no-cache, must-revalidate, max-age=0',
        'Pragma':'no-cache',
        'Expires':'0'
      }
    });
    if (!r.ok){
      // 403/404/5xx → tenta fallback
      showErr(`GitHub Actions API: HTTP ${r.status}; usando fallback…`);
      return pollDoneJsonFallback();
    }
    const j = await r.json();
    const run = j && Array.isArray(j.workflow_runs) ? j.workflow_runs[0] : null;

    // Se ainda não há run recente, segue tentando
    if (!run){
      msgEl.textContent = 'Aguardando início da pipeline…';
      return setTimeout(pollGithubActions, POLL_MS);
    }

    // status: queued | in_progress | completed
    // conclusion (só quando completed): success | failure | cancelled | skipped | timed_out | action_required
    if (run.status === 'completed'){
      const status = (run.conclusion || '').toLowerCase();
      msgEl.textContent = `Pipeline concluída (${status || 'desconhecido'})`;
      return toResults(status || 'success', run.id);
    } else {
      msgEl.textContent = 'Pipeline em execução…';
      return setTimeout(pollGithubActions, POLL_MS);
    }
  }catch(e){
    // Qualquer erro de rede → fallback
    showErr('Falha na API do GitHub Actions; usando fallback. Detalhe: ' + e.message);
    return pollDoneJsonFallback();
  }
}

/** ============== 2) Fallback: done.json no repositório (pode demorar) ============== */
function safeJson(s){ try { return JSON.parse(s); } catch { return null; } }

async function pollDoneJsonFallback(){
  try{
    const url = `${DONE_URL}?t=${Date.now()}`; // cache-busting
    const r = await fetch(url, { cache:'no-store' });
    if (r.status === 404){
      // ainda não existe → tenta novamente
      msgEl.textContent = 'Aguardando marcação de conclusão…';
      return setTimeout(pollDoneJsonFallback, FALLBACK_POLL_MS);
    }
    if (!r.ok){
      showErr(`Falha ao consultar marcador: HTTP ${r.status}`);
      return setTimeout(pollDoneJsonFallback, FALLBACK_POLL_MS + 800);
    }
    const txt = await r.text();
    const j = safeJson(txt);
    if (j && j.done === true){
      const status = (j.status || '').toLowerCase();
      return toResults(status || 'success', j.ts || Date.now());
    }
    // existe, mas done ainda não é true
    return setTimeout(pollDoneJsonFallback, FALLBACK_POLL_MS);
  }catch(e){
    showErr('Erro ao consultar marcador: ' + e.message);
    return setTimeout(pollDoneJsonFallback, FALLBACK_POLL_MS + 800);
  }
}

/** ============== Bootstrap + Fail-safe ============== */
msgEl.textContent = 'Verificando status da pipeline…';

// fail-safe: se nada responder, leva para results (timeout)
setTimeout(() => toResults('timeout', Date.now()), HARD_TIMEOUT_MS);

// start pela API (rápida); se cair, o próprio código chama o fallback
pollGithubActions();
</script>


</body>
</html>
