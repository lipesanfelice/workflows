<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Processando…</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
  <style>.tiny{font-size:.72rem;opacity:.8}</style>
</head>
<body class="min-h-screen bg-gray-50 flex items-center justify-center">
  <div class="w-full max-w-md mx-4">
    <div class="bg-white shadow rounded-2xl p-8 text-center">
      <div class="flex items-center justify-center mb-4">
        <i data-feather="loader" class="w-10 h-10 animate-spin text-blue-600"></i>
      </div>
      <h1 class="text-xl font-semibold text-gray-800 mb-2">Estamos processando seu código…</h1>
      <p id="msg" class="text-gray-500">Aguarde enquanto a pipeline executa.</p>

      <div id="errBox" class="hidden mt-4 text-sm text-red-700 bg-red-50 border border-red-200 rounded p-3 text-left"></div>

      <div class="mt-6">
        <a href="index.html" class="text-sm text-gray-500 hover:underline">Voltar</a>
      </div>
    </div>

    <pre id="dbg" class="tiny text-center mt-3 whitespace-pre-wrap"></pre>
  </div>

<script>
feather.replace();

/**
 * Poll duplo:
 *  - GitHub API (contents)   → evita cache da CDN do RAW
 *  - RAW (fallback)
 * Redireciona assim que encontrar {"done":true}.
 *
 * Overrides por query:
 *   ?owner=...&repo=...&branch=...&debug=1
 */

// ===== config =====
const qs = new URLSearchParams(location.search);
let OWNER  = qs.get('owner')  || 'lipesanfelice';
let REPO   = qs.get('repo')   || 'workflows';
let BRANCH = qs.get('branch') || 'main';

const DONE_PATH = 'app/entrada-usuario/done.json';
const RUN_T     = qs.get('t') || String(Date.now()); // marca desta rodada
const DEBUG     = qs.get('debug') === '1';

const MSG    = document.getElementById('msg');
const ERR    = document.getElementById('errBox');
const DBG    = document.getElementById('dbg');

let intervalMs = 900;
const MAX_INTERVAL = 3000;
const TIMEOUT_MS = 10*60*1000;

// URLs
const RAW_URL = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/${DONE_PATH}`;
const API_URL = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodeURIComponent(DONE_PATH)}?ref=${encodeURIComponent(BRANCH)}`;

// helpers
function logDbg(x){ if(!DEBUG) return; DBG.textContent = (DBG.textContent+'\n'+(typeof x==='string'?x:JSON.stringify(x,null,2))).trim(); }
function showErr(t){ ERR.classList.remove('hidden'); ERR.textContent = t; }
function nc(u){ const s = u.includes('?')?'&':'?'; return `${u}${s}t=${encodeURIComponent(RUN_T)}&r=${Math.random().toString(36).slice(2)}`; }
function safeJson(s){ try{ return JSON.parse(s); }catch{return null;} }
function b64toStr(b){ try{ return atob(b); }catch{return ''; } }
function go(status){
  const url = new URL('results.html', location.href);
  if (status) url.searchParams.set('status', String(status).toLowerCase());
  url.searchParams.set('t', RUN_T);
  location.replace(url.toString());
}

// fontes
async function getByAPI(){
  const r = await fetch(nc(API_URL), { cache:'no-store' });
  if (r.status===404) return {ok:false, notFound:true, src:'api'};
  if (!r.ok) return {ok:false, code:r.status, src:'api'};
  const j = await r.json();
  // Conteúdo via API vem base64 quando é arquivo
  if (j && j.type === 'file' && j.encoding === 'base64' && j.content){
    const txt = b64toStr(j.content.replace(/\n/g,''));
    const data = safeJson(txt);
    return data ? {ok:true, data, src:'api'} : {ok:false, badJson:true, src:'api'};
  }
  // Se a API retornou diretório/objeto diferente, considere não encontrado
  return {ok:false, notFile:true, src:'api'};
}
async function getByRAW(){
  const r = await fetch(nc(RAW_URL), { cache:'no-store' });
  if (r.status===404) return {ok:false, notFound:true, src:'raw'};
  if (!r.ok) return {ok:false, code:r.status, src:'raw'};
  const txt = await r.text();
  const data = safeJson(txt);
  return data ? {ok:true, data, src:'raw'} : {ok:false, badJson:true, src:'raw'};
}

let tries = 0;
async function loop(){
  tries++;
  try {
    // tenta API primeiro
    const a = await getByAPI();
    logDbg({try:tries, from:'api', status:a.ok? 'ok' : (a.notFound?'404':a.code||Object.keys(a)[1])});
    if (a.ok && a.data && a.data.done === true){
      MSG.textContent = 'Finalizando…';
      return go(a.data.status || 'success');
    }

    // se API não deu ok, tenta RAW como fallback
    if (!a.ok || (a.data && a.data.done !== true)) {
      const b = await getByRAW();
      logDbg({try:tries, from:'raw', status:b.ok? 'ok' : (b.notFound?'404':b.code||Object.keys(b)[1])});
      if (b.ok && b.data && b.data.done === true){
        MSG.textContent = 'Finalizando…';
        return go(b.data.status || 'success');
      }
    }

    // feedback leve em erro
    if ((!a.ok && !a.notFound) || (!a.ok && a.code>=400)) showErr(`API GitHub: ${a.code||'falha'}`);
  } catch(e){
    logDbg({error:String(e && e.message || e)});
    showErr('Erro de rede ao consultar marcador.');
  }

  // não finalizou → backoff leve
  if (tries % 10 === 0) intervalMs = Math.min(intervalMs+300, MAX_INTERVAL);
  setTimeout(loop, intervalMs);
}

// fail-safe
setTimeout(()=> go('timeout'), TIMEOUT_MS);

// init
MSG.textContent = 'Aguarde enquanto a pipeline executa…';
if (DEBUG) logDbg({api:API_URL, raw:RAW_URL, owner:OWNER, repo:REPO, branch:BRANCH, run:RUN_T});
loop();
</script>
</body>
</html>
