<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Processando…</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
</head>
<body class="min-h-screen bg-gray-50 flex items-center justify-center">
  <div class="w-full max-w-md mx-4">
    <div class="bg-white shadow rounded-2xl p-8 text-center">
      <div class="flex items-center justify-center mb-4">
        <i data-feather="loader" class="w-10 h-10 animate-spin text-blue-600"></i>
      </div>
      <h1 class="text-xl font-semibold text-gray-800 mb-2">Estamos processando seu código…</h1>
      <p id="msg" class="text-gray-500">Aguarde enquanto a pipeline executa.</p>

      <div id="errBox" class="hidden mt-4 text-sm text-red-700 bg-red-50 border border-red-200 rounded p-3 text-left"></div>

      <div class="mt-6">
        <a href="index.html" class="text-sm text-gray-500 hover:underline">Voltar</a>
      </div>
    </div>
  </div>

<script>
feather.replace();

/**
 * ✅ Sem backend / sem execId
 * Poll em um arquivo "marcador" commitado pelo GitHub Actions:
 *   app/entrada-usuario/done.json  → { "done": true, "status": "success|failure|cancelled" }
 * Assim que done=true → redireciona para results.html?status=...&run=...
 *
 * Query params opcionais para override:
 *   ?owner=USER&repo=REPO&branch=BRANCH&marker=CAMINHO
 */

// ===== Config padrão (ajuste para o seu repo) =====
let OWNER   = 'lipesanfelice';
let REPO    = 'workflows';
let BRANCH  = 'main';
let MARKER  = 'app/entrada-usuario/done.json';

const qs = new URLSearchParams(location.search);
OWNER  = qs.get('owner')  || OWNER;
REPO   = qs.get('repo')   || REPO;
BRANCH = qs.get('branch') || BRANCH;
MARKER = qs.get('marker') || MARKER;

// URL raw do marcador
function markerURL() {
  const base = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/${MARKER}`;
  // cache-busting
  return `${base}?t=${Date.now()}`;
}

// ===== UI refs =====
const msgEl  = document.getElementById('msg');
const errBox = document.getElementById('errBox');

// ===== Run token (usado na results.html para bust de cache) =====
function newRunToken(){
  return String(Date.now());
}
function sendToResults(status){
  const run = newRunToken();
  try { sessionStorage.setItem('lastRun', run); } catch(_) {}
  const url = new URL('results.html', location.href);
  url.searchParams.set('status', status || '');
  url.searchParams.set('run', run);
  location.href = url.toString();
}

// ===== Fail-safe global =====
const MAX_WAIT_MIN    = 20;
const HARD_TIMEOUT_MS = MAX_WAIT_MIN * 60 * 1000;
setTimeout(() => sendToResults('timeout'), HARD_TIMEOUT_MS);

// ===== Polling com backoff suave =====
let intervalMs = 1500;
const MAX_INTERVAL_MS = 8000; // limite do backoff
let startedAt = Date.now();

function fmtElapsed(ms){
  const s = Math.floor(ms/1000);
  const m = Math.floor(s/60), r = s%60;
  return (m ? `${m}m ` : '') + `${r}s`;
}

function safeJson(t){ try { return JSON.parse(t); } catch { return null; } }

async function checkMarker(){
  const url = markerURL();
  try {
    const r = await fetch(url, { cache: 'no-store' });
    if (r.status === 404) {
      // ainda não existe
      msgEl.textContent = `Pipeline em execução… (${fmtElapsed(Date.now()-startedAt)})`;
      scheduleNext();
      return;
    }
    if (!r.ok) {
      // erro transitório (403 rate-limit, etc.) → exibe e tenta de novo com backoff
      showError(`Falha ao consultar marcador: HTTP ${r.status}`);
      scheduleNext(true);
      return;
    }

    const txt = await r.text();
    const j = safeJson(txt);

    // se o arquivo existir mas vier vazio/sem JSON, continua aguardando
    if (!j || j.done !== true) {
      msgEl.textContent = `Preparando resultados… (${fmtElapsed(Date.now()-startedAt)})`;
      scheduleNext();
      return;
    }

    // Sucesso/Erro/Cancelado informados pelo workflow
    const status = String(j.status || '').toLowerCase();
    sendToResults(status || 'done');
  } catch (e) {
    showError('Erro de rede ao consultar marcador: ' + e.message);
    scheduleNext(true);
  }
}

function showError(text){
  errBox.classList.remove('hidden');
  errBox.textContent = text;
}

// Próxima tentativa (com backoff só quando há erro)
function scheduleNext(withBackoff=false){
  if (withBackoff){
    intervalMs = Math.min(MAX_INTERVAL_MS, Math.floor(intervalMs * 1.5));
  } else {
    intervalMs = 1500; // reseta quando está ok
  }
  setTimeout(checkMarker, intervalMs);
}

// Mensagem inicial e start
msgEl.textContent = 'Aguarde enquanto a pipeline executa…';
checkMarker();
</script>
</body>
</html>
