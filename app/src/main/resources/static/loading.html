<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Processando…</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
  <style>
    .pulse { animation: pulse 1.6s ease-in-out infinite }
    @keyframes pulse { 0%{opacity:.45} 50%{opacity:1} 100%{opacity:.45} }
  </style>
</head>
<body class="min-h-screen bg-gray-50 flex items-center justify-center">
  <div class="w-full max-w-2xl mx-4">
    <div class="bg-white shadow rounded-2xl p-6">
      <div class="flex items-center justify-center mb-4">
        <i data-feather="loader" class="w-10 h-10 animate-spin text-blue-600"></i>
      </div>
      <h1 class="text-xl font-semibold text-gray-800 text-center mb-2">Processando…</h1>
      <p id="headline" class="text-center text-gray-500 mb-6">Estamos executando a pipeline.</p>

      <div class="w-full bg-gray-200 rounded-full h-2.5 mb-4 overflow-hidden">
        <div id="progressBar" class="bg-blue-600 h-2.5 rounded-full transition-all" style="width: 8%"></div>
      </div>

      <ul class="grid grid-cols-1 gap-2 text-sm mb-4">
        <li id="step1" class="text-gray-400">Preparando envio…</li>
        <li id="step2" class="text-gray-400">Análise estática…</li>
        <li id="step3" class="text-gray-400">Gerando testes…</li>
        <li id="step4" class="text-gray-400">Calculando cobertura…</li>
        <li id="step5" class="text-gray-400">Finalizando relatórios…</li>
      </ul>

      <div class="flex items-center justify-between text-xs text-gray-500">
        <div id="statusChip" class="px-2 py-1 rounded bg-gray-100 text-gray-700">Aguardando…</div>
        <div id="execChip" class="px-2 py-1 rounded bg-gray-100 text-gray-700">execId: —</div>
      </div>

      <div id="diag" class="mt-4 hidden">
        <div class="text-xs font-semibold text-gray-700 mb-1">Diagnóstico</div>
        <pre id="diagPre" class="text-xs bg-gray-100 rounded p-2 overflow-auto max-h-40"></pre>
      </div>

      <div id="actions" class="mt-4 hidden">
        <div class="flex gap-2 justify-end">
          <a id="btnRetry" class="px-3 py-2 rounded bg-blue-600 text-white text-sm cursor-pointer">Tentar novamente</a>
          <a href="index.html" class="px-3 py-2 rounded bg-gray-200 text-gray-800 text-sm">Voltar</a>
        </div>
      </div>
    </div>

    <div class="text-center mt-4 text-sm">
      <a id="verResultados" href="#" class="text-blue-600 hover:underline hidden">Ir para resultados</a>
    </div>
  </div>

<script>
feather.replace();

const qs = new URLSearchParams(location.search);
const DEBUG = qs.get('debug') === '1';

const progressBar = document.getElementById('progressBar');
const statusChip  = document.getElementById('statusChip');
const execChip    = document.getElementById('execChip');
const diag        = document.getElementById('diag');
const diagPre     = document.getElementById('diagPre');
const actions     = document.getElementById('actions');
const btnRetry    = document.getElementById('btnRetry');
const verResultados = document.getElementById('verResultados');

const steps = [
  { id: 'step1', labels: ['INICIADO','QUEUED','PREPARANDO','STARTING','PREPARING'] },
  { id: 'step2', labels: ['ANALISE_ESTATICA','STATIC','ANALYZE','ANALYSIS'] },
  { id: 'step3', labels: ['GERANDO_TESTES','TEST','GENERATE','RUNNING_TESTS'] },
  { id: 'step4', labels: ['CALCULANDO_COBERTURA','COVERAGE'] },
  { id: 'step5', labels: ['FINALIZANDO','FINALIZING','POST','REPORT'] },
];

function markDone(idx){
  const el = document.getElementById(steps[idx].id);
  if (!el) return;
  el.textContent = el.textContent.replace(/…?$/,'') + ' ✔️';
  el.classList.remove('text-gray-400','text-gray-600');
  el.classList.add('text-green-600','font-medium');
  const pct = Math.max(parseInt(progressBar.style.width)||0, Math.round(((idx+1)/steps.length)*100));
  progressBar.style.width = pct + '%';
}
function markActive(idx){
  const el = document.getElementById(steps[idx].id);
  if (!el) return;
  el.classList.remove('text-gray-400');
  el.classList.add('text-gray-600');
}
function fallbackPulse(){
  // animação leve pra não “parecer travado” quando não há progresso do backend
  progressBar.classList.add('pulse');
  setTimeout(()=>progressBar.classList.remove('pulse'), 1600);
}
function logDiag(obj){
  if (!DEBUG) return;
  diag.classList.remove('hidden');
  const line = typeof obj === 'string' ? obj : JSON.stringify(obj, null, 2);
  diagPre.textContent = (diagPre.textContent + '\n' + line).trim();
}

function mapEstadoToStep(estadoRaw){
  const e = (estadoRaw||'').toString().toUpperCase();
  if (!e) return 0;
  for (let i=0;i<steps.length;i++){
    if (steps[i].labels.some(lbl => e.includes(lbl))) return i;
  }
  if (e.includes('FINAL')) return 4;
  if (e.includes('ERROR') || e.includes('ERRO') || e.includes('FAIL')) return -1;
  return 0;
}

function extractExecId(j){
  return j?.execId || j?.id || j?.executionId || j?.runId || j?.jobId || j?.exec || j?.meta?.execId || null;
}
function extractEstado(j){
  return j?.estado ?? j?.status ?? j?.phase ?? j?.stage ?? j?.step ?? '';
}
function extractMsg(j){
  return j?.mensagem ?? j?.message ?? j?.detail ?? '';
}
function extractPct(j){
  const raw = j?.progresso ?? j?.progress ?? j?.percentage ?? j?.percent ?? j?.pct;
  const n = Number(raw);
  return Number.isFinite(n) ? Math.max(0, Math.min(100, n)) : null;
}

function setStatusBadge(text, tone){
  statusChip.textContent = text;
  statusChip.className = 'px-2 py-1 rounded text-xs ' + (tone==='err'
      ? 'bg-red-100 text-red-700'
      : tone==='ok'
        ? 'bg-green-100 text-green-700'
        : 'bg-gray-100 text-gray-700');
}

function base64ToBlob(b64, mime) {
  const byteChars = atob(b64);
  const byteNums = new Array(byteChars.length);
  for (let i=0;i<byteChars.length;i++) byteNums[i]=byteChars.charCodeAt(i);
  return new Blob([new Uint8Array(byteNums)], { type: mime || 'application/octet-stream' });
}

async function startPipelineFromPending() {
  const raw = sessionStorage.getItem('pendingJob');
  if (!raw) return null;

  const job = JSON.parse(raw);
  let url = null, body = null, headers;

  if (job.tipo === 'codigo') {
    url = '/api/codigo';
    headers = { 'Content-Type':'application/json' };
    body = JSON.stringify({ codigo: job.payload.codigo });
  } else if (job.tipo === 'arquivo') {
    url = '/api/arquivo';
    const fd = new FormData();
    const blob = base64ToBlob(job.payload.base64, job.payload.mime);
    fd.append('file', new File([blob], job.payload.nome || 'Codigo.java', { type: job.payload.mime }));
    body = fd;
  } else if (job.tipo === 'zip') {
    url = '/api/projeto';
    const fd = new FormData();
    const blob = base64ToBlob(job.payload.base64, job.payload.mime);
    fd.append('file', new File([blob], job.payload.nome || 'projeto.zip', { type: job.payload.mime }));
    body = fd;
  } else {
    return null;
  }

  setStatusBadge('Iniciando pipeline…');
  logDiag({sendingTo:url});

  let resp, data = {};
  try {
    resp = await fetch(url, { method:'POST', body, headers, credentials:'include' });
  } catch (e) {
    setStatusBadge('Falha ao iniciar', 'err'); logDiag(String(e));
    return null;
  } finally {
    sessionStorage.removeItem('pendingJob');
  }

  try {
    const ct = (resp.headers.get('content-type')||'').toLowerCase();
    if (ct.includes('application/json')) data = await resp.json(); else logDiag('Resposta não-JSON do /api/*');
  } catch (e) {
    logDiag('Erro lendo JSON do /api/*: '+e.message);
  }

  const execId = extractExecId(data);
  if (execId) {
    const u = new URL(location.href); u.searchParams.set('execId', execId); history.replaceState(null, '', u.toString());
    execChip.textContent = 'execId: '+execId;
  } else {
    setStatusBadge('Aguardando id de execução…');
  }
  return execId;
}

async function pollByExecId(execId) {
  let delay = 900;
  async function loop(){
    try {
      const url = '/api/process/status?execId=' + encodeURIComponent(execId);
      const r = await fetch(url, { credentials:'include' });
      if (!r.ok) {
        setStatusBadge('Status HTTP '+r.status);
        logDiag('GET '+url+' -> HTTP '+r.status);
        fallbackPulse();
        delay = Math.min(delay*2, 5000);
        setTimeout(loop, delay); return;
      }
      let s={};
      try { s = await r.json(); } catch(e){ setStatusBadge('Status inválido', 'err'); logDiag('JSON inválido: '+e.message); }

      const estado = extractEstado(s);
      const pct    = extractPct(s);
      const msg    = extractMsg(s);

      if (pct != null) progressBar.style.width = pct + '%';
      if (msg) logDiag({msg});

      const isDone   = (estado||'').toUpperCase().includes('FINAL') || s.done === true || s.finished === true || s.success === true;
      const isError  = (estado||'').toUpperCase().includes('ERRO') || (estado||'').toUpperCase().includes('ERROR') || s.error || s.failed;

      if (isError) {
        setStatusBadge('Erro na pipeline', 'err');
        document.getElementById('step5').textContent = 'Falha no processamento';
        document.getElementById('step5').className = 'text-red-600 font-semibold';
        progressBar.style.width = '100%';
        actions.classList.remove('hidden');
        return;
      }

      const stepIdx = mapEstadoToStep(estado);
      for (let i=0;i<steps.length;i++){
        if (i < stepIdx) markDone(i);
        else if (i === stepIdx) markActive(i);
      }
      if (isDone) {
        for (let i=0;i<steps.length;i++) markDone(i);
        setStatusBadge('Concluído', 'ok');
        const to = 'results.html?execId='+encodeURIComponent(execId);
        verResultados.href = to; verResultados.classList.remove('hidden');
        setTimeout(()=>location.href = to, 700);
        return;
      }

      setStatusBadge(estado ? ('Status: '+estado) : 'Aguardando status…');
      delay = 900; // reset backoff em sucesso
      setTimeout(loop, delay);
    } catch (e) {
      setStatusBadge('Erro de rede', 'err'); logDiag('Network: '+e.message);
      fallbackPulse();
      delay = Math.min(delay*2, 5000);
      setTimeout(loop, delay);
    }
  }
  loop();
}

btnRetry.addEventListener('click', async ()=>{
  actions.classList.add('hidden');
  const id = new URLSearchParams(location.search).get('execId');
  if (id) pollByExecId(id); else init(); // tenta tudo de novo
});

async function init(){
  if (DEBUG) diag.classList.remove('hidden');

  let execId = new URLSearchParams(location.search).get('execId');
  if (execId) {
    execChip.textContent = 'execId: '+execId;
    setStatusBadge('Retomando…');
    pollByExecId(execId);
    return;
  }

  setStatusBadge('Iniciando…');
  const got = await startPipelineFromPending();
  if (got) {
    setStatusBadge('Pipeline iniciada');
    pollByExecId(got);
    return;
  }

  setStatusBadge('Aguardando tarefa…');
  // Fallback opcional: tente buscar o último execId se seu backend expõe algo assim.
  // try {
  //   const r = await fetch('/api/process/status/latest', { credentials:'include' });
  //   const j = await r.json();
  //   const latest = extractExecId(j);
  //   if (latest) { const u=new URL(location.href); u.searchParams.set('execId', latest); history.replaceState(null,'',u.toString()); execChip.textContent='execId: '+latest; pollByExecId(latest); return; }
  // } catch (e) { logDiag('latest: '+e.message); }

  // Sem execId e sem pendingJob -> habilita ações
  actions.classList.remove('hidden');
}

init();
</script>
</body>
</html>
