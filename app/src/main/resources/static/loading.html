<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Processando…</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
</head>
<body class="min-h-screen bg-gray-50 flex items-center justify-center">
  <div class="w-full max-w-md mx-4">
    <div class="bg-white shadow rounded-2xl p-8 text-center">
      <div class="flex items-center justify-center mb-4">
        <i data-feather="loader" class="w-10 h-10 animate-spin text-blue-600"></i>
      </div>
      <h1 class="text-xl font-semibold text-gray-800 mb-2">Estamos processando seu código…</h1>
      <p id="msg" class="text-gray-500">Aguarde enquanto a pipeline executa.</p>

      <div id="errBox" class="hidden mt-4 text-sm text-red-700 bg-red-50 border border-red-200 rounded p-3 text-left"></div>

      <div class="mt-6">
        <a href="index.html" class="text-sm text-gray-500 hover:underline">Voltar</a>
      </div>
    </div>
  </div>

<script>
  feather.replace();

  /**
  * Fica consultando o arquivo raw do GitHub:
  *   https://raw.githubusercontent.com/<owner>/<repo>/<branch>/app/entrada-usuario/done.json
  *
  * Redireciona para results.html **somente** quando:
  *   - done === true
  *   - ts do done.json é posterior ao momento em que o loading foi aberto (anti-stale)
  */

  let OWNER  = 'lipesanfelice';
  let REPO   = 'workflows';
  let BRANCH = 'main';

  const qs = new URLSearchParams(location.search);
  OWNER  = qs.get('owner')  || OWNER;
  REPO   = qs.get('repo')   || REPO;
  BRANCH = qs.get('branch') || BRANCH;

  const DONE_URL = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/app/entrada-usuario/done.json`;

  const msgEl  = document.getElementById('msg');
  const errBox = document.getElementById('errBox');

  const POLL_INTERVAL_MS = 1500;
  const HARD_TIMEOUT_MS  = 20 * 60 * 1000; // 20min fail-safe
  const PAGE_OPENED_AT   = Date.now();
  const FRESH_TOLERANCE  = 2000; // 2s de tolerância de relógio

  function safeJson(s){ try { return JSON.parse(s); } catch { return null; } }

  async function checkDone(){
    const url = DONE_URL + `?t=${Date.now()}`; // cache-busting
    try {
      const r = await fetch(url, { cache: 'no-store' });
      if (r.status === 404) { setTimeout(checkDone, POLL_INTERVAL_MS); return; }
      if (!r.ok) {
        errBox.classList.remove('hidden');
        errBox.textContent = `Falha ao consultar marcador: HTTP ${r.status}`;
        setTimeout(checkDone, POLL_INTERVAL_MS + 1000);
        return;
      }
      const txt = await r.text();
      const j = safeJson(txt);

      // Anti-stale: exige done=true **e** ts >= PAGE_OPENED_AT - tolerância
      if (j && j.done === true) {
        const ts = Date.parse(j.ts || '');
        const isFresh = Number.isFinite(ts) && ts >= (PAGE_OPENED_AT - FRESH_TOLERANCE);
        if (isFresh) {
          const status = (j.status || '').toLowerCase();
          // dica: se quiser forçar reload total da results (anti-cache), acrescente ?ts=<now>
          location.href = `results.html?status=${encodeURIComponent(status)}&t=${Date.now()}`;
          return;
        }
      }

      // segue aguardando
      setTimeout(checkDone, POLL_INTERVAL_MS);
    } catch (e) {
      errBox.classList.remove('hidden');
      errBox.textContent = 'Erro de rede ao consultar marcador: ' + e.message;
      setTimeout(checkDone, POLL_INTERVAL_MS + 1000);
    }
  }

  msgEl.textContent = 'Aguarde enquanto a pipeline executa…';

  // Fail-safe: se demorar demais, vá para results com status=timeout (e t=… para bust de cache)
  setTimeout(() => { location.href = 'results.html?status=timeout&t=' + Date.now(); }, HARD_TIMEOUT_MS);

  // inicia o polling
  checkDone();
</script>

</body>
</html>
