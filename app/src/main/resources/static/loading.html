<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Processando…</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
  <style>
    .pulse { animation: pulse 1.6s ease-in-out infinite }
    @keyframes pulse { 0%{opacity:.45} 50%{opacity:1} 100%{opacity:.45} }
  </style>
</head>
<body class="min-h-screen bg-gray-50 flex items-center justify-center">
  <div class="w-full max-w-2xl mx-4">
    <div class="bg-white shadow rounded-2xl p-6">
      <div class="flex items-center justify-center mb-4">
        <i data-feather="loader" class="w-10 h-10 animate-spin text-blue-600"></i>
      </div>
      <h1 class="text-xl font-semibold text-gray-800 text-center mb-2">Processando…</h1>
      <p id="headline" class="text-center text-gray-500 mb-6">Estamos executando a pipeline.</p>

      <div class="w-full bg-gray-200 rounded-full h-2.5 mb-4 overflow-hidden">
        <div id="progressBar" class="bg-blue-600 h-2.5 rounded-full transition-all" style="width: 8%"></div>
      </div>

      <ul class="grid grid-cols-1 gap-2 text-sm mb-4">
        <li id="step1" class="text-gray-400">Preparando envio…</li>
        <li id="step2" class="text-gray-400">Análise estática…</li>
        <li id="step3" class="text-gray-400">Gerando testes…</li>
        <li id="step4" class="text-gray-400">Calculando cobertura…</li>
        <li id="step5" class="text-gray-400">Finalizando relatórios…</li>
      </ul>

      <div class="flex items-center justify-between text-xs text-gray-500">
        <div id="statusChip" class="px-2 py-1 rounded bg-gray-100 text-gray-700">Aguardando…</div>
        <div id="execChip" class="px-2 py-1 rounded bg-gray-100 text-gray-700">execId: —</div>
      </div>

      <div id="diag" class="mt-4 hidden">
        <div class="text-xs font-semibold text-gray-700 mb-1">Diagnóstico</div>
        <pre id="diagPre" class="text-xs bg-gray-100 rounded p-2 overflow-auto max-h-40"></pre>
      </div>

      <div id="actions" class="mt-4 hidden">
        <div class="flex gap-2 justify-end">
          <a id="btnRetry" class="px-3 py-2 rounded bg-blue-600 text-white text-sm cursor-pointer">Tentar novamente</a>
          <a href="index.html" class="px-3 py-2 rounded bg-gray-200 text-gray-800 text-sm">Voltar</a>
        </div>
      </div>
    </div>

    <div class="text-center mt-4 text-sm">
      <a id="verResultados" href="#" class="text-blue-600 hover:underline hidden">Ir para resultados</a>
    </div>
  </div>

<script>
feather.replace();

const qs = new URLSearchParams(location.search);
const DEBUG = qs.get('debug') === '1';

const progressBar = document.getElementById('progressBar');
const statusChip  = document.getElementById('statusChip');
const execChip    = document.getElementById('execChip');
const diag        = document.getElementById('diag');
const diagPre     = document.getElementById('diagPre');
const actions     = document.getElementById('actions');
const btnRetry    = document.getElementById('btnRetry');
const verResultados = document.getElementById('verResultados');

const STATUS_ENDPOINTS = ['/api/process/status','/api/status','/status','/pipeline/status'];
const RESULTS_ENDPOINTS = ['/api/resultados','/api/results','/results'];

const steps = [
  { id: 'step1', labels: ['INICIADO','QUEUED','PREPARANDO','STARTING','PREPARING'] },
  { id: 'step2', labels: ['ANALISE_ESTATICA','STATIC','ANALYZE','ANALYSIS'] },
  { id: 'step3', labels: ['GERANDO_TESTES','TEST','GENERATE','RUNNING_TESTS'] },
  { id: 'step4', labels: ['CALCULANDO_COBERTURA','COVERAGE'] },
  { id: 'step5', labels: ['FINALIZANDO','FINALIZING','POST','REPORT'] },
];

function markDone(idx){
  const el = document.getElementById(steps[idx].id);
  if (!el) return;
  el.textContent = el.textContent.replace(/…?$/,'') + ' ✔️';
  el.classList.remove('text-gray-400','text-gray-600');
  el.classList.add('text-green-600','font-medium');
  const pct = Math.max(parseInt(progressBar.style.width)||0, Math.round(((idx+1)/steps.length)*100));
  progressBar.style.width = pct + '%';
}
function markActive(idx){
  const el = document.getElementById(steps[idx].id);
  if (!el) return;
  el.classList.remove('text-gray-400');
  el.classList.add('text-gray-600');
}
function fallbackPulse(){ progressBar.classList.add('pulse'); setTimeout(()=>progressBar.classList.remove('pulse'), 1600); }
function logDiag(obj){
  if (!DEBUG) return;
  diag.classList.remove('hidden');
  const line = typeof obj === 'string' ? obj : JSON.stringify(obj, null, 2);
  diagPre.textContent = (diagPre.textContent + '\n' + line).trim();
}

/* ===================== Normalizadores ===================== */
function mapEstadoToStep(estadoRaw){
  const e = (estadoRaw||'').toString().toUpperCase();
  if (!e) return 0;
  for (let i=0;i<steps.length;i++){
    if (steps[i].labels.some(lbl => e.includes(lbl))) return i;
  }
  if (e.includes('FINAL')) return 4;
  if (e.includes('DONE')) return 4;
  if (e.includes('COMPLETE')) return 4;
  if (e.includes('SUCCESS')) return 4;
  if (e.includes('SUCCEED')) return 4;
  if (e.includes('ERROR') || e.includes('ERRO') || e.includes('FAIL')) return -1;
  return 0;
}
function isDoneState(s){
  const e = (s || '').toString().toUpperCase();
  return e.includes('FINAL') || e.includes('DONE') || e.includes('COMPLETE') || e.includes('SUCCESS') || e.includes('SUCCEED');
}
function isErrorState(s){
  const e = (s || '').toString().toUpperCase();
  return e.includes('ERROR') || e.includes('ERRO') || e.includes('FAIL');
}

function extractExecId(j){
  return j?.execId || j?.id || j?.executionId || j?.runId || j?.jobId || j?.exec || j?.meta?.execId || null;
}
function extractEstado(j){
  return j?.estado ?? j?.status ?? j?.phase ?? j?.stage ?? j?.step ?? '';
}
function extractMsg(j){
  return j?.mensagem ?? j?.message ?? j?.detail ?? '';
}
function extractPct(j){
  let raw = j?.progresso ?? j?.progress ?? j?.percentage ?? j?.percent ?? j?.pct;
  if (raw == null) return null;
  if (typeof raw === 'string'){
    const m = raw.match(/([\d.]+)/);
    if (m) raw = parseFloat(m[1]);
  }
  const n = Number(raw);
  return Number.isFinite(n) ? Math.max(0, Math.min(100, n)) : null;
}

/* ===================== Utils ===================== */
function setStatusBadge(text, tone){
  statusChip.textContent = text;
  statusChip.className = 'px-2 py-1 rounded text-xs ' + (tone==='err'
      ? 'bg-red-100 text-red-700'
      : tone==='ok'
        ? 'bg-green-100 text-green-700'
        : 'bg-gray-100 text-gray-700');
}
function base64ToBlob(b64, mime) {
  const byteChars = atob(b64);
  const byteNums = new Array(byteChars.length);
  for (let i=0;i<byteChars.length;i++) byteNums[i]=byteChars.charCodeAt(i);
  return new Blob([new Uint8Array(byteNums)], { type: mime || 'application/octet-stream' });
}
async function tryFetchJSON(url){
  try{
    const r = await fetch(url, { credentials:'include' });
    if (!r.ok) return { ok:false, status:r.status, url };
    const ct = (r.headers.get('content-type')||'').toLowerCase();
    if (!ct.includes('application/json')) return { ok:false, status:r.status, url, note:'non-json' };
    const j = await r.json();
    return { ok:true, status:r.status, url, json:j };
  }catch(e){
    return { ok:false, error:e.message, url };
  }
}
async function fetchFirst(urls, maker){
  let last;
  for (const u of urls){
    const res = await maker(u);
    if (res.ok) return { ...res, chosen:u };
    last = res;
  }
  return { ok:false, last };
}

/* ===================== Pipeline start ===================== */
function getExecFromURL(){
  const p = new URLSearchParams(location.search).get('execId');
  return p || null;
}
function setExecInURL(id){
  const u = new URL(location.href);
  u.searchParams.set('execId', id);
  history.replaceState(null, '', u.toString());
  execChip.textContent = 'execId: ' + id;
}

async function startPipelineFromPending() {
  const raw = sessionStorage.getItem('pendingJob');
  if (!raw) return null;

  const job = JSON.parse(raw);
  let url = null, body = null, headers;

  if (job.tipo === 'codigo') {
    url = '/api/codigo';
    headers = { 'Content-Type':'application/json' };
    body = JSON.stringify({ codigo: job.payload.codigo });
  } else if (job.tipo === 'arquivo') {
    url = '/api/arquivo';
    const fd = new FormData();
    const blob = base64ToBlob(job.payload.base64, job.payload.mime);
    fd.append('file', new File([blob], job.payload.nome || 'Codigo.java', { type: job.payload.mime }));
    body = fd;
  } else if (job.tipo === 'zip') {
    url = '/api/projeto';
    const fd = new FormData();
    const blob = base64ToBlob(job.payload.base64, job.payload.mime);
    fd.append('file', new File([blob], job.payload.nome || 'projeto.zip', { type: job.payload.mime }));
    body = fd;
  } else {
    return null;
  }

  setStatusBadge('Iniciando pipeline…');
  logDiag({sendingTo:url});

  let resp, data = {};
  try {
    resp = await fetch(url, { method:'POST', body, headers, credentials:'include' });
  } catch (e) {
    setStatusBadge('Falha ao iniciar', 'err'); logDiag(String(e));
    return null;
  } finally {
    sessionStorage.removeItem('pendingJob');
  }

  try {
    const ct = (resp.headers.get('content-type')||'').toLowerCase();
    if (ct.includes('application/json')) data = await resp.json(); else logDiag('Resposta não-JSON do /api/*');
  } catch (e) {
    logDiag('Erro lendo JSON do /api/*: '+e.message);
  }

  const execId = extractExecId(data);
  if (execId) setExecInURL(execId); else setStatusBadge('Aguardando id de execução…');
  return execId;
}

/* ===================== Polling ===================== */
let chosenStatusEndpoint = null;
let chosenResultsEndpoint = null;

async function pollByExecId(execId) {
  let delay = 900;
  let stagnation = 0; // contagem de loops sem avanço, para acionar verificação por resultados
  let lastPct = 0;

  async function getStatus(){
    if (chosenStatusEndpoint){
      const res = await tryFetchJSON(chosenStatusEndpoint + '?execId=' + encodeURIComponent(execId));
      if (res.ok) return res;
      logDiag({retryStatusFrom:chosenStatusEndpoint, err:res.status || res.error});
      chosenStatusEndpoint = null; // força fallback
    }
    const probe = await fetchFirst(STATUS_ENDPOINTS.map(b=>b+'?execId='+encodeURIComponent(execId)), tryFetchJSON);
    if (probe.ok) { chosenStatusEndpoint = probe.chosen.replace(/\?.*$/,''); logDiag({usingStatus:chosenStatusEndpoint}); }
    return probe;
  }

  async function getResults(){
    if (chosenResultsEndpoint){
      const res = await tryFetchJSON(chosenResultsEndpoint + '?execId=' + encodeURIComponent(execId));
      if (res.ok) return res;
      chosenResultsEndpoint = null;
    }
    const probe = await fetchFirst(RESULTS_ENDPOINTS.map(b=>b+'?execId='+encodeURIComponent(execId)), tryFetchJSON);
    if (probe.ok) { chosenResultsEndpoint = probe.chosen.replace(/\?.*$/,''); logDiag({usingResults:chosenResultsEndpoint}); }
    return probe;
  }

  async function loop(){
    try {
      const st = await getStatus();
      if (!st.ok) {
        setStatusBadge('Sem status ('+(st.last?.status || st.last?.error || 'erro')+')');
        logDiag({statusFail:st.last});
        fallbackPulse();
        // plano B: tentar resultados mesmo sem status
        const rr = await getResults();
        if (rr.ok && resultadosSugeremPronto(rr.json)) {
          return concluir(execId);
        }
        delay = Math.min(delay*2, 5000);
        setTimeout(loop, delay); return;
      }

      const s = st.json || {};
      const estado = extractEstado(s);
      const pct    = extractPct(s);
      const msg    = extractMsg(s);

      if (pct != null) {
        progressBar.style.width = pct + '%';
        if (pct <= lastPct) stagnation++; else stagnation = 0;
        lastPct = pct;
      } else {
        stagnation++;
      }
      if (msg) logDiag({msg});

      if (isErrorState(estado) || s.error || s.failed) {
        setStatusBadge('Erro na pipeline', 'err');
        document.getElementById('step5').textContent = 'Falha no processamento';
        document.getElementById('step5').className = 'text-red-600 font-semibold';
        progressBar.style.width = '100%';
        actions.classList.remove('hidden');
        return;
      }

      const stepIdx = mapEstadoToStep(estado);
      for (let i=0;i<steps.length;i++){
        if (i < stepIdx) markDone(i);
        else if (i === stepIdx) markActive(i);
      }

      const done = isDoneState(estado) || s.done === true || s.finished === true || s.success === true || s.completed === true;
      if (done) return concluir(execId);

      setStatusBadge(estado ? ('Status: '+estado) : 'Aguardando status…');
      delay = 900; // reset backoff em sucesso

      // se está “parado” por tempo demais, tente verificar resultados
      if (stagnation >= 4) { // ~ 4 ciclos sem mudança
        const rr = await getResults();
        if (rr.ok && resultadosSugeremPronto(rr.json)) {
          return concluir(execId);
        }
      }

      setTimeout(loop, delay);
    } catch (e) {
      setStatusBadge('Erro de rede', 'err'); logDiag('Network: '+e.message);
      fallbackPulse();
      delay = Math.min(delay*2, 5000);
      setTimeout(loop, delay);
    }
  }

  function resultadosSugeremPronto(j){
    if (!j) return false;
    if (Array.isArray(j.arquivos) && j.arquivos.length) return true;
    if (Array.isArray(j.tests) && j.tests.length) return true;
    if (Array.isArray(j.testes) && j.testes.length) return true;
    if (j.done === true || j.finished === true || j.success === true) return true;
    if (typeof j.cobertura === 'number' || typeof j.cobertura === 'string') return true;
    return false;
  }

  function concluir(id){
    for (let i=0;i<steps.length;i++) markDone(i);
    setStatusBadge('Concluído', 'ok');
    const to = 'results.html?execId='+encodeURIComponent(id);
    verResultados.href = to; verResultados.classList.remove('hidden');
    setTimeout(()=>location.href = to, 600);
  }

  loop();
}

/* ===================== Boot ===================== */
btnRetry.addEventListener('click', async ()=>{
  actions.classList.add('hidden');
  const id = getExecFromURL();
  if (id) pollByExecId(id); else init();
});

async function init(){
  if (DEBUG) diag.classList.remove('hidden');

  let execId = getExecFromURL();
  if (execId) {
    execChip.textContent = 'execId: '+execId;
    setStatusBadge('Retomando…');
    pollByExecId(execId);
    return;
  }

  setStatusBadge('Iniciando…');
  const got = await startPipelineFromPending();
  if (got) {
    setStatusBadge('Pipeline iniciada');
    pollByExecId(got);
    return;
  }

  setStatusBadge('Aguardando tarefa…');
  actions.classList.remove('hidden');
}

init();
</script>
</body>
</html>
