<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Processando…</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
</head>
<body class="min-h-screen bg-gray-50 flex items-center justify-center">
  <div class="w-full max-w-lg mx-4">
    <div class="bg-white shadow rounded-xl p-6">
      <div class="flex items-center justify-center mb-4">
        <i data-feather="loader" class="w-10 h-10 animate-spin text-blue-600"></i>
      </div>
      <h1 class="text-xl font-semibold text-gray-800 text-center mb-2">Processando…</h1>
      <p class="text-center text-gray-500 mb-6">Estamos executando a pipeline. Você será redirecionado aos resultados quando terminar.</p>

      <!-- barra de progresso -->
      <div class="w-full bg-gray-200 rounded-full h-2.5 mb-6">
        <div id="progressBar" class="bg-blue-600 h-2.5 rounded-full transition-all" style="width: 8%"></div>
      </div>

      <!-- passos -->
      <ul class="space-y-2 text-sm">
        <li id="step1" class="text-gray-400">Analisando estrutura do código…</li>
        <li id="step2" class="text-gray-400">Executando análise estática…</li>
        <li id="step3" class="text-gray-400">Gerando casos de teste…</li>
        <li id="step4" class="text-gray-400">Calculando cobertura…</li>
        <li id="step5" class="text-gray-400">Finalizando relatórios…</li>
      </ul>

      <div id="msg" class="mt-4 text-center text-xs text-gray-400"></div>
    </div>

    <div class="text-center mt-4">
      <a href="index.html" class="text-blue-600 text-sm hover:underline">Cancelar e voltar</a>
    </div>
  </div>

<script>
  feather.replace();

  // ---------- helpers visuais ----------
  const progressBar = document.getElementById('progressBar');
  const steps = [
    { id: 'step1', label: 'Analisando estrutura do código…' },
    { id: 'step2', label: 'Executando análise estática…' },
    { id: 'step3', label: 'Gerando casos de teste…' },
    { id: 'step4', label: 'Calculando cobertura…' },
    { id: 'step5', label: 'Finalizando relatórios…' }
  ];
  function markDone(idx){
    const el = document.getElementById(steps[idx].id);
    if (!el) return;
    el.textContent = steps[idx].label + ' ✔️';
    el.classList.remove('text-gray-400','text-gray-600');
    el.classList.add('text-green-600','font-medium');
    const pct = Math.round(((idx+1)/steps.length)*100);
    progressBar.style.width = pct + '%';
  }
  function markActive(idx){
    const el = document.getElementById(steps[idx].id);
    if (!el) return;
    el.textContent = steps[idx].label;
    el.classList.remove('text-gray-400');
    el.classList.add('text-gray-600');
  }
  function estadoParaEtapa(estado){
    // ajuste conforme os estados reais do seu backend
    switch((estado||'').toUpperCase()){
      case 'INICIADO': return 0;
      case 'ANALISE_ESTATICA': return 1;
      case 'GERANDO_TESTES': return 2;
      case 'CALCULANDO_COBERTURA': return 3;
      case 'FINALIZANDO': return 4;
      default: return 0;
    }
  }
  function setMsg(t){ const m=document.getElementById('msg'); if(m) m.textContent=t||''; }

  // ---------- util payload ----------
  function base64ToBlob(b64, mime) {
    const byteChars = atob(b64);
    const byteNums = new Array(byteChars.length);
    for (let i=0;i<byteChars.length;i++) byteNums[i]=byteChars.charCodeAt(i);
    return new Blob([new Uint8Array(byteNums)], { type: mime || 'application/octet-stream' });
  }

  // ---------- dispara pipeline a partir do pendingJob ----------
  async function startPipelineFromPending() {
    const raw = sessionStorage.getItem('pendingJob');
    if (!raw) return null;

    const job = JSON.parse(raw);
    let url = null, body = null, headers;

    if (job.tipo === 'codigo') {
      url = '/api/codigo';
      headers = { 'Content-Type':'application/json' };
      body = JSON.stringify({ codigo: job.payload.codigo });
    } else if (job.tipo === 'arquivo') {
      url = '/api/arquivo';
      const fd = new FormData();
      const blob = base64ToBlob(job.payload.base64, job.payload.mime);
      fd.append('file', new File([blob], job.payload.nome || 'Codigo.java', { type: job.payload.mime }));
      body = fd;
    } else if (job.tipo === 'zip') {
      url = '/api/projeto';
      const fd = new FormData();
      const blob = base64ToBlob(job.payload.base64, job.payload.mime);
      fd.append('file', new File([blob], job.payload.nome || 'projeto.zip', { type: job.payload.mime }));
      body = fd;
    } else {
      return null;
    }

    // Envia e limpa o pending para não reenviar em refresh
    let resp;
    try {
      setMsg('Enviando dados…');
      resp = await fetch(url, { method:'POST', body, headers, credentials:'include' });
    } finally {
      sessionStorage.removeItem('pendingJob');
    }

    const ct = (resp.headers.get('content-type')||'').toLowerCase();
    let data = {};
    if (ct.includes('application/json')) {
      try { data = await resp.json(); } catch {}
    }
    const execId =
      data.execId || data.id || data.exec || data.executionId ||
      (data.meta && data.meta.execId) || null;

    // injeta execId na URL sem recarregar (para o polling)
    if (execId) {
      const u = new URL(location.href);
      u.searchParams.set('execId', execId);
      history.replaceState(null, '', u.toString());
    }
    return execId;
  }

  // ---------- polling ----------
  async function pollByExecId(execId) {
    try {
      const r = await fetch('/api/process/status?execId=' + encodeURIComponent(execId), { credentials:'include' });
      if (!r.ok) throw new Error('HTTP ' + r.status);
      const s = await r.json();
      const estado = (s.estado || s.status || '').toUpperCase();

      if (estado === 'FINALIZADO' || s.done === true) {
        for (let i=0;i<steps.length;i++) markDone(i);
        setMsg('Concluído — redirecionando…');
        setTimeout(()=>location.href='results.html?execId=' + encodeURIComponent(execId), 600);
        return;
      }
      if (estado === 'ERRO' || s.error) {
        const el = document.getElementById('step5');
        if (el){
          el.textContent = 'Falha no processamento';
          el.classList.remove('text-gray-400','text-gray-600');
          el.classList.add('text-red-600','font-semibold');
        }
        progressBar.style.width = '100%';
        setMsg('Ocorreu um erro na pipeline.');
        return;
      }

      // avança etapas
      const etapa = estadoParaEtapa(estado);
      for (let i=0;i<steps.length;i++){
        if (i < etapa) markDone(i);
        else if (i === etapa) markActive(i);
      }

      if (typeof s.progresso === 'number') {
        progressBar.style.width = Math.max(0, Math.min(100, s.progresso)) + '%';
      }
      setMsg(s.mensagem || s.message || '');
    } catch(e) {
      // silencioso: mantém loading e tenta de novo
    } finally {
      setTimeout(()=>pollByExecId(execId), 900);
    }
  }

  // ---------- boot ----------
  (async function init(){
    // 1) se já veio com execId (ex.: refresh), apenas poll
    const qs = new URLSearchParams(location.search);
    let execId = qs.get('execId');

    // 2) senão, tente iniciar a pipeline a partir do pendingJob
    if (!execId) {
      execId = await startPipelineFromPending();
    }

    // 3) se obteve execId, começa o polling
    if (execId) {
      pollByExecId(execId);
    } else {
      // opcional: você pode tentar buscar último job (“latest”) se houver endpoint
      // const r = await fetch('/api/process/status/latest', { credentials:'include' });
      // const j = await r.json(); if (j.execId) { history.replaceState(null,'',`?execId=${j.execId}`); pollByExecId(j.execId); }
    }
  })();
</script>
</body>
</html>
