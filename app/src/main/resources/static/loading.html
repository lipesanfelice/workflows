<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Processando…</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
  <style>
    .muted{opacity:.8}
  </style>
</head>
<body class="min-h-screen bg-gray-50 flex items-center justify-center">
  <div class="w-full max-w-md mx-4">
    <div class="bg-white shadow rounded-2xl p-8 text-center">
      <div class="flex items-center justify-center mb-4">
        <i data-feather="loader" class="w-10 h-10 animate-spin text-blue-600"></i>
      </div>
      <h1 class="text-xl font-semibold text-gray-800 mb-2">Estamos processando seu código…</h1>
      <p id="msg" class="text-gray-500">Aguarde enquanto a pipeline executa.</p>

      <div class="mt-6">
        <a href="index.html" class="text-sm text-gray-500 hover:underline">Voltar</a>
      </div>
    </div>

    <p id="hint" class="text-center text-xs text-gray-400 mt-3 muted"></p>
  </div>

<script>
feather.replace();

/**
 * Esta página verifica periodicamente o arquivo
 *   app/entrada-usuario/done.json
 * no seu repositório GitHub. Assim que encontrar { "done": true },
 * redireciona para results.html?status=...&t=...
 *
 * Formato esperado (gravado pelo seu workflow):
 *   {"done":true,"status":"success|failure|cancelled","ts":"..."}
 */

/* ======== CONFIG ======== */
let OWNER  = 'lipesanfelice';
let REPO   = 'workflows';
let BRANCH = 'main';

// Permite sobrescrever por query (?owner=&repo=&branch=)
const qs = new URLSearchParams(location.search);
OWNER  = qs.get('owner')  || OWNER;
REPO   = qs.get('repo')   || REPO;
BRANCH = qs.get('branch') || BRANCH;

// Caminho do marcador
const DONE_PATH = 'app/entrada-usuario/done.json';

// marca única desta execução (será propagada para results.html)
const RUN_T = qs.get('t') || String(Date.now());

/* ======== TUNING ======== */
let INTERVAL_MS = 1000;   // polling rápido
const MAX_INTERVAL = 3000;
const HARD_TIMEOUT_MS = 15 * 60 * 1000; // 15 min fail-safe

/* ======== REFS ======== */
const msgEl  = document.getElementById('msg');
const hintEl = document.getElementById('hint');

/* ======== HELPERS ======== */
function nc(url){
  const sep = url.includes('?') ? '&' : '?';
  return `${url}${sep}t=${RUN_T}&r=${Math.random().toString(36).slice(2)}`;
}
function safeJson(s){ try { return JSON.parse(s); } catch { return null; } }
function toStatusStr(v){ return (v||'').toString().toLowerCase(); }
function show(text){ msgEl.textContent = text; }
function hint(text){ hintEl.textContent = text || ''; }

/* ======== FONTES DE DADOS ======== */
// 1) RAW do GitHub (mais rápido quando já propagou)
async function fetchFromRaw(){
  const RAW = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/${DONE_PATH}`;
  const r = await fetch(nc(RAW), {
    cache: 'no-store',
    headers: {
      'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
      'Pragma': 'no-cache'
    }
  });
  if (r.status === 404) return { ok:false, notFound:true };
  if (!r.ok) return { ok:false, code:r.status };
  const txt = await r.text();
  const j = safeJson(txt);
  return j ? { ok:true, data:j, src:'raw' } : { ok:false, badJson:true };
}

// 2) Contents API (fallback se o RAW ainda não propagou)
async function fetchFromAPI(){
  const API = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodeURIComponent(DONE_PATH)}?ref=${encodeURIComponent(BRANCH)}`;
  const r = await fetch(nc(API), { cache: 'no-store' });
  if (r.status === 404) return { ok:false, notFound:true };
  if (!r.ok) return { ok:false, code:r.status };
  const j = await r.json();
  if (!j || j.type !== 'file' || !j.content) return { ok:false, badContent:true };
  try {
    const decoded = atob(j.content.replace(/\s+/g,''));
    const obj = safeJson(decoded);
    return obj ? { ok:true, data:obj, src:'api' } : { ok:false, badJson:true };
  } catch {
    return { ok:false, badBase64:true };
  }
}

/* ======== POLLING ======== */
let attempts = 0;

async function check(){
  attempts++;
  // Tenta RAW; se não vier, tenta API.
  // Fazemos em sequência para economizar rate-limit, mas mantendo latência baixa.
  try{
    // Mostra feedback sutil
    if (attempts % 10 === 1) hint('verificando…');
    const raw = await fetchFromRaw();
    let hit = null;
    if (raw.ok) {
      hit = raw;
    } else if (raw.notFound || raw.badJson) {
      const api = await fetchFromAPI();
      if (api.ok) hit = api;
    }

    if (hit && hit.data && hit.data.done === true) {
      const status = toStatusStr(hit.data.status);
      show('Finalizando…');
      // redireciona imediatamente
      const url = new URL('results.html', location.href);
      url.searchParams.set('status', status || '');
      url.searchParams.set('t', RUN_T);
      location.replace(url.toString());
      return;
    }

    // Ainda não finalizou — continua
    if (attempts % 10 === 0) {
      // pequeno backoff, mas limita a 3s
      INTERVAL_MS = Math.min(INTERVAL_MS + 250, MAX_INTERVAL);
    }
    setTimeout(check, INTERVAL_MS);
  } catch (e){
    // Falha de rede eventual — não poluir a UI
    if (attempts % 5 === 0) hint('reconectando…');
    setTimeout(check, Math.min(INTERVAL_MS + 500, MAX_INTERVAL));
  }
}

/* ======== FAIL-SAFE ======== */
setTimeout(()=>{
  const url = new URL('results.html', location.href);
  url.searchParams.set('status', 'timeout');
  url.searchParams.set('t', RUN_T);
  location.replace(url.toString());
}, HARD_TIMEOUT_MS);

/* ======== START ======== */
show('Aguarde enquanto a pipeline executa…');
check();
</script>
</body>
</html>
