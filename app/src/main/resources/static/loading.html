<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Processando…</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
</head>
<body class="min-h-screen bg-gray-50 flex items-center justify-center">
  <div class="w-full max-w-md mx-4">
    <div class="bg-white shadow rounded-2xl p-8 text-center">
      <div class="flex items-center justify-center mb-4">
        <i data-feather="loader" class="w-10 h-10 animate-spin text-blue-600"></i>
      </div>
      <h1 class="text-xl font-semibold text-gray-800 mb-2">Estamos processando seu código…</h1>
      <p id="msg" class="text-gray-500">Aguardando o início da execução…</p>

      <div id="errBox" class="hidden mt-4 text-sm text-red-700 bg-red-50 border border-red-200 rounded p-3 text-left"></div>

      <details class="mt-4 text-left">
        <summary class="text-sm text-gray-500 cursor-pointer">Diagnóstico</summary>
        <pre id="diag" class="mt-2 text-xs text-gray-700 bg-gray-50 border border-gray-200 rounded p-2 whitespace-pre-wrap"></pre>
      </details>

      <div class="mt-6">
        <a href="index.html" class="text-sm text-gray-500 hover:underline">Voltar</a>
      </div>
    </div>
  </div>

<script>
feather.replace();

let dono='lipesanfelice',repo='workflows',ramo='main';
const qs=new URLSearchParams(location.search);
dono=qs.get('owner')||dono;repo=qs.get('repo')||repo;ramo=qs.get('branch')||ramo;
const runIdInicial=qs.get('run_id')||'';
const startedAt=Number(qs.get('startedAt')||Date.now());
const eventoEsperado=qs.get('event')||'';

const msgEl=document.getElementById('msg');
const errBox=document.getElementById('errBox');
const diag=document.getElementById('diag');

function fmt(ms){if(!ms||ms<1)return'—';let s=Math.floor(ms/1000),m=Math.floor(s/60);s%=60;let h=Math.floor(m/60);m%=60;const p=[];if(h)p.push(h+'h');if(m)p.push(m+'m');if(s)p.push(s+'s');return p.join(' ')}

function urlRate(){return `/gh/rate_limit`}
function urlRuns(){return `/gh/repos/${dono}/${repo}/actions/runs?branch=${encodeURIComponent(ramo)}&per_page=10`}
function urlRunById(id){return `/gh/repos/${dono}/${repo}/actions/runs/${id}`}

function opt(){return {cache:'no-store',headers:{'X-Requested-With':'fetch'}}}

/* =========================
   Rate limit backoff helpers
   ========================= */
let cooldownUntil = 0;

function parseRateHeaders(resp){
  const rem = Number(resp.headers.get('X-RateLimit-Remaining')||'');
  const reset = Number(resp.headers.get('X-RateLimit-Reset')||'');
  return { remaining: isNaN(rem)?null:rem, reset: isNaN(reset)?null:reset };
}

function applyBackoffFromResponse(resp){
  const { remaining, reset } = parseRateHeaders(resp);
  if (remaining !== null) {
    // Log no diagnóstico para ajudar
    diag.textContent += `\nRate remaining: ${remaining}` + (reset? ` | reset: ${new Date(reset*1000).toLocaleTimeString()}` : '');
  }
  if (remaining !== null && remaining <= 1 && reset) {
    const resetMs = reset*1000;
    cooldownUntil = Math.max(cooldownUntil, resetMs);
    errBox.classList.remove('hidden');
    errBox.textContent = `Atingiu rate limit. Aguardando até ${new Date(resetMs).toLocaleTimeString()} antes de consultar novamente.`;
  }
}

function nextDelay(defaultMs){
  const now = Date.now();
  if (cooldownUntil && now < cooldownUntil) {
    // Espera até o reset (com folga de 500ms)
    return Math.max(1000, cooldownUntil - now + 500);
  }
  return defaultMs;
}

/* ========================= */

async function autoteste(){
  try{
    const r=await fetch(urlRate(),opt()); if(!r.ok) throw new Error('HTTP '+r.status);
    const j=await r.json();
    const remaining = (j.resources?.core?.remaining??'?');
    const limit = (j.resources?.core?.limit??'?');
    diag.textContent=['Autoteste OK',`rate remaining: ${remaining} / ${limit}`].join('\n');
    if (Number(remaining)===0 && j.resources?.core?.reset){
      cooldownUntil = (j.resources.core.reset*1000);
      errBox.classList.remove('hidden');
      errBox.textContent = `Atingiu rate limit. Aguardando até ${new Date(cooldownUntil).toLocaleTimeString()} antes de iniciar o polling.`;
    }
    return true;
  }catch(e){
    errBox.classList.remove('hidden');errBox.textContent='Falha no autoteste: '+(e?.message||e);
    return false;
  }
}

// Exibe corpo do erro e aplica backoff
async function getRunById(id){
  const u=urlRunById(id);diag.textContent+=`\nGET ${u}`;
  const r=await fetch(u,opt());
  applyBackoffFromResponse(r);
  if(!r.ok){
    const body=await r.text().catch(()=> '');
    errBox.classList.remove('hidden');
    errBox.textContent = `Erro ${r.status}: ${body || 'sem corpo'}`;
    return {erro:r.status};
  }
  return {ok:true,dados:await r.json()};
}

// Exibe corpo do erro e aplica backoff
async function acharRunNovo(){
  const u=urlRuns();diag.textContent+=`\nGET ${u}`;
  const r=await fetch(u,opt());
  applyBackoffFromResponse(r);
  if(!r.ok){
    const body=await r.text().catch(()=> '');
    errBox.classList.remove('hidden');
    errBox.textContent = `Erro ${r.status}: ${body || 'sem corpo'}`;
    return {erro:r.status};
  }
  const j=await r.json();
  const lista=j.workflow_runs||[];
  const cand=lista.find(eCandidato);
  if(!cand) return {nao:true};
  return {ok:true,dados:cand};
}

function eCandidato(run){
  const tCriado=new Date(run.created_at).getTime();
  if(tCriado < startedAt-10000) return false;
  if(eventoEsperado && run.event!==eventoEsperado) return false;
  return true;
}

function irResultados(status){
  const p=new URLSearchParams({status,owner:dono,repo:repo,branch:ramo});
  location.href=`results.html?${p.toString()}`;
}

let idFixado=runIdInicial||null;
let t0=null;
let watchdog=null;
function watchdogIniciar(ms){clearTimeout(watchdog);watchdog=setTimeout(()=>{errBox.classList.remove('hidden');errBox.textContent='Tempo excedido. Abrindo resultados com status=timeout.';irResultados('timeout')},ms)}
watchdogIniciar(20*60*1000);

const prazoAparecer=120000;
const LENTO = 8000;   // antes do run aparecer
const NORMAL = 2000;  // após fixar run
const RAPIDO = 1500;  // acompanhamento do run

async function ciclo(){
  try{
    if(!idFixado){
      const delta=Date.now()-startedAt;
      const achado=await acharRunNovo();
      if(achado.ok){
        idFixado=String(achado.dados.id);
        t0=new Date(achado.dados.run_started_at||achado.dados.created_at).getTime();
        msgEl.textContent='Execução encontrada. Acompanhando…';
        return setTimeout(ciclo, nextDelay(NORMAL));
      }else if(achado.erro){
        throw new Error('HTTP '+achado.erro);
      }else{
        msgEl.textContent='Aguardando a execução iniciar… ('+fmt(delta)+')';
        return setTimeout(ciclo, nextDelay(LENTO));
      }
    }

    const info=await getRunById(idFixado);
    if(info.erro){ throw new Error('HTTP '+info.erro) }
    const run=info.dados;
    const st=run.status;
    const conc=(run.conclusion||'').toLowerCase();
    const tInicio=new Date(run.run_started_at||run.created_at).getTime();
    const dec=fmt(Date.now()-(t0||tInicio));

    if(st==='queued'){ msgEl.textContent='Em fila… ('+dec+')'; }
    else if(st==='in_progress'){ msgEl.textContent='Executando… ('+dec+')'; }
    else if(st==='completed'){
      msgEl.textContent='Concluído em '+fmt(new Date(run.updated_at).getTime()-tInicio);
      return irResultados(conc||'success');
    } else {
      msgEl.textContent='Aguardando… ('+dec+')';
    }
    setTimeout(ciclo, nextDelay(RAPIDO));
  }catch(e){
    errBox.classList.remove('hidden');
    errBox.textContent='Erro: '+(e?.message||e);
    setTimeout(ciclo, nextDelay(3000));
  }
}

(async()=>{
  const ok=await autoteste();
  if(!ok) return;
  msgEl.textContent='Preparando…';
  ciclo();
})();
</script>

</body>
</html>
