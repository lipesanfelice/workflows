<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Processando…</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
</head>
<body class="min-h-screen bg-gray-50 flex items-center justify-center">
  <div class="w-full max-w-md mx-4">
    <div class="bg-white shadow rounded-2xl p-8 text-center">
      <div class="flex items-center justify-center mb-4">
        <i data-feather="loader" class="w-10 h-10 animate-spin text-blue-600"></i>
      </div>
      <h1 class="text-xl font-semibold text-gray-800 mb-2">Estamos processando seu código…</h1>
      <p id="msg" class="text-gray-500">Aguarde enquanto a pipeline executa.</p>

      <div id="errBox" class="hidden mt-4 text-sm text-red-700 bg-red-50 border border-red-200 rounded p-3 text-left"></div>

      <div class="mt-6">
        <a href="index.html" class="text-sm text-gray-500 hover:underline">Voltar</a>
      </div>
    </div>
  </div>

<script>
feather.replace();

/**
 * ✅ Sem backend / sem execId
 * A página verifica periodicamente um arquivo "marcador" commitado pelo GitHub Actions:
 *   app/entrada-usuario/done.json  (conteúdo: { "done": true, "status": "success|failure|cancelled" })
 * Assim que o arquivo existir e tiver done=true → redireciona para results.html?status=...
 *
 * Você pode sobrescrever por query string:
 *   loading.html?owner=SEU_USER&repo=SEU_REPO&branch=BRANCH
 */

// === Ajuste padrão (pode sobrescrever via query) ===
let OWNER  = 'lipesanfelice';
let REPO   = 'workflows';
let BRANCH = 'main';

// Permite override por query string
const qs = new URLSearchParams(location.search);
OWNER  = qs.get('owner')  || OWNER;
REPO   = qs.get('repo')   || REPO;
BRANCH = qs.get('branch') || BRANCH;

// URL raw do arquivo marcador
const DONE_URL = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/app/entrada-usuario/done.json`;

const POLL_INTERVAL_MS = 1500;
const MAX_WAIT_MIN     = 20;  // fail-safe
const HARD_TIMEOUT_MS  = MAX_WAIT_MIN * 60 * 1000;

const msgEl  = document.getElementById('msg');
const errBox = document.getElementById('errBox');


function safeJson(s){ try { return JSON.parse(s); } catch { return null; } }

// Lê token opcional (?ght=...) ou sessionStorage
  const GHT = qs.get('ght') || sessionStorage.getItem('ght') || '';

  // NÃO codifique as barras do caminho:
  const API_URL = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${DONE_PATH}?ref=${encodeURIComponent(BRANCH)}`;
  const RAW_URL = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/${DONE_PATH}`;

  function headersGitHub(){
    const h = { 'Cache-Control':'no-store' };
    if (GHT) {
      h.Authorization = `Bearer ${GHT}`;
      h['X-GitHub-Api-Version'] = '2022-11-28';
    }
    return h;
  }

  async function getByAPI(){
    const r = await fetch(API_URL + `&t=${Date.now()}`, { cache:'no-store', headers: headersGitHub() });
    if (r.status===404) return {ok:false, notFound:true, src:'api'};
    if (!r.ok)        return {ok:false, code:r.status,  src:'api'};
    const j = await r.json();
    if (j && j.type==='file' && j.encoding==='base64' && j.content){
      const txt  = atob(j.content.replace(/\n/g,''));
      try { return { ok:true, data: JSON.parse(txt), src:'api' }; }
      catch { return { ok:false, badJson:true, src:'api' }; }
    }
    return { ok:false, notFile:true, src:'api' };
  }

  async function getByRAW(){
    const r = await fetch(RAW_URL + `?t=${Date.now()}`, { cache:'no-store' });
    if (r.status===404) return {ok:false, notFound:true, src:'raw'};
    if (!r.ok)        return {ok:false, code:r.status,  src:'raw'};
    try { return { ok:true, data: JSON.parse(await r.text()), src:'raw' }; }
    catch { return { ok:false, badJson:true, src:'raw' }; }
  }

async function checkDone(){
  // cache-busting + no-store para evitar cache do navegador/CDN
  const url = DONE_URL + `?t=${Date.now()}`;
  try {
    const r = await fetch(url, { cache: 'no-store' });
    if (r.status === 404) {
      // ainda não existe; segue aguardando
      setTimeout(checkDone, POLL_INTERVAL_MS);
      return;
    }
    if (!r.ok) {
      // erro temporário (ex.: 403 rate limit); mostra e continua tentando
      errBox.classList.remove('hidden');
      errBox.textContent = `Falha ao consultar marcador: HTTP ${r.status}`;
      setTimeout(checkDone, POLL_INTERVAL_MS + 1000);
      return;
    }
    const txt = await r.text();
    const j = safeJson(txt);
    if (j && j.done === true) {
      const status = (j.status || '').toLowerCase();
      location.href = `results.html?status=${encodeURIComponent(status)}`;
      return;
    }
    // arquivo existe mas ainda não marcou done=true
    setTimeout(checkDone, POLL_INTERVAL_MS);
  } catch (e) {
    errBox.classList.remove('hidden');
    errBox.textContent = 'Erro de rede ao consultar marcador: ' + e.message;
    setTimeout(checkDone, POLL_INTERVAL_MS + 1000);
  }
}

// Mensagem padrão
msgEl.textContent = 'Aguarde enquanto a pipeline executa…';

// Fail-safe: se demorar "demais", segue para results com status=timeout
setTimeout(() => {
  location.href = 'results.html?status=timeout';
}, HARD_TIMEOUT_MS);

// inicia o polling
checkDone();
</script>
</body>
</html>
