# ci.yml

name: Java CI with Gradle

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: gen-tests-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    paths:
      - 'app/entrada-usuario/**'
  pull_request:
    paths:
      - 'app/entrada-usuario/**'

jobs:
  build:
    runs-on: ubuntu-latest

    env:
      # Ajustes do loop de autofix:
      MAX_LOOPS: "3"            # máximo de iterações
      MIN_COVERAGE: "0.60"      # 60%
      ENFORCE_COVERAGE: "false" # gradle não falha; o loop decide
      # Provedor IA (Groq) e modelo padrão:
      IA_PROVEDOR: "groq"
      GROQ_MODEL: "llama-3.1-8b-instant"

    steps:
    - name: Checkout do código
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        persist-credentials: true

    - name: Configurar Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '21'

    - name: Cache do Gradle
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Conceder permissão para o wrapper
      run: chmod +x gradlew

    - name: SonarQube
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: |
        ./gradlew clean build
        ./gradlew -p app -Dsonar.token=$SONAR_TOKEN sonar

    - name: Extrair métricas Sonar → relatorio-sonar.json
      working-directory: app
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_PROJECT_KEY: lipesanfelice_workflows
        SONAR_OUTPUT_DIR: ${{ github.workspace }}/app/entrada-usuario
      run: ../gradlew bootRun --args='--acao=extrair-sonar --spring.main.web-application-type=none'

    - name: Conferir e imprimir conteúdo
      env:
        ARQ: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
      run: |
        set -euo pipefail
        ls -la "$(dirname "$ARQ")" || true
        test -s "$ARQ"
        echo "OK: arquivo presente"
        echo "Tamanho (bytes): $(wc -c < "$ARQ")"
        python3 - <<'PY'
        import os, json
        p = os.environ["ARQ"]
        t = open(p,'r',encoding='utf-8').read()
        try:
          j = json.loads(t)
          print(json.dumps(j, ensure_ascii=False, indent=2))
        except Exception:
          print(t)
        PY

    - name: Backup fora do repo
      env:
        ARQ: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
        BKP: ${{ runner.temp }}/relatorio-sonar.json
      run: |
        set -euo pipefail
        cp -f "$ARQ" "$BKP"
        echo "SONAR_JSON=$ARQ" >> $GITHUB_ENV
        echo "SONAR_JSON_BKP=$BKP" >> $GITHUB_ENV

    - name: Restaurar se arquivo sumir
      if: always()
      run: |
        set -euo pipefail
        if [ ! -s "$SONAR_JSON" ] && [ -s "$SONAR_JSON_BKP" ]; then
          mkdir -p "$(dirname "$SONAR_JSON")"
          cp -f "$SONAR_JSON_BKP" "$SONAR_JSON"
          echo "Restaurado a partir do backup"
        fi
        ls -la "$(dirname "$SONAR_JSON")" || true

    - name: Publicar relatorio-sonar.json
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: relatorio-sonar
        path: ${{ env.SONAR_JSON }}
        if-no-files-found: error
        retention-days: 30

    - name: Conferir entradas
      run: |
        test -f "${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json" || (echo "faltando relatorio-sonar.json" && exit 1)
        test -d "${{ github.workspace }}/app/entrada-usuario" || (echo "faltando pasta de código entrada-usuario/java" && exit 1)

    - name: Garantir e limpar pasta de testes gerados
      run: |
        TESTS_DIR="${{ github.workspace }}/app/entrada-usuario/testes_explicações"
        mkdir -p "$TESTS_DIR/tests" "$TESTS_DIR/explicacoes"
        find "$TESTS_DIR" -mindepth 1 -maxdepth 1 -exec rm -rf {} +
        echo "Pasta preparada: $TESTS_DIR"

    - name: Gerar testes via IA (Groq)
      env:
        IA_PROVEDOR: groq
        GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        GROQ_MODELO: llama-3.1-8b-instant
        SONAR_RELATORIO_JSON: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
        CODIGO_FONTE_DIR: ${{ github.workspace }}/app/entrada-usuario
        IA_SLEEP_MS: '8000'
        IA_CODE_MAX_CHARS: '3000'
        IA_SONAR_MAX_CHARS: '2000'
      run: |
        ./gradlew -p app bootRun --args='--acao=gerar-testes --spring.main.web-application-type=none --app.entrada.diretorio=${{ github.workspace }}/app/entrada-usuario'

    - name: Conferir testes gerados
      run: |
        echo "Arquivos gerados:"
        find "${{ github.workspace }}/app/entrada-usuario/testes_explicações/tests" -type f -name "*.java" | sed -n '1,200p'
        echo "Relatório:"
        cat "${{ github.workspace }}/app/entrada-usuario/testes_explicações/relatorio.txt" || true

    - name: Verificar presença de fontes e testes do usuário
      id: check_usuario
      shell: bash
      run: |
        shopt -s globstar nullglob
        fontes=(app/entrada-usuario/**/*.java)
        testes=(app/entrada-usuario/testes_explicações/tests/**/*.java)
        if [[ ${#fontes[@]} -gt 0 && ${#testes[@]} -gt 0 ]]; then
          echo "tem=true" >> "$GITHUB_OUTPUT"
        else
          echo "tem=false" >> "$GITHUB_OUTPUT"
        fi

    - name: 'Loop: testes + cobertura + auto-ajuste (Groq)'
      env:
        GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        GROQ_MODELO: llama-3.1-8b-instant
        MAX_TRIES: '3'
        MIN_COVERAGE: '0.40'          # opcional: exija >1% de linhas cobertas
      run: |
        set -euo pipefail
        tries=1
        while [ $tries -le ${MAX_TRIES} ]; do
          echo "== Tentativa $tries/${MAX_TRIES} =="

          # roda cobertura (ConsoleLauncher + JaCoCo)
          if ./gradlew --no-daemon --no-configuration-cache -p app clean covUsuario --info; then
            ok_exec=1
          else
            ok_exec=0
          fi

          XML="${{ github.workspace }}/app/entrada-usuario/jacoco-relatorio/jacoco.xml"
          EXEC="${{ github.workspace }}/app/build/jacoco/testUsuarioConsole.exec"

          have_exec=0; have_xml_good=0; pct_ok=0
          [ -s "$EXEC" ] && have_exec=1

          if [ -s "$XML" ]; then
            # rejeita xml "empty"
            if ! grep -q 'report name="empty"' "$XML"; then
              have_xml_good=1
              # (opcional) calcula % de linhas cobertas e compara com MIN_COVERAGE
              # extrai counters LINE missed/covered via awk
              covered=$(grep '<counter type="LINE"' "$XML" | sed -E 's/.*covered="([0-9]+)".*/\1/' | paste -sd+ - | bc || echo 0)
              missed=$(grep  '<counter type="LINE"' "$XML" | sed -E 's/.*missed="([0-9]+)".*/\1/'  | paste -sd+ - | bc || echo 0)
              total=$((covered + missed))
              if [ "$total" -gt 0 ]; then
                # escala fixa com 4 decimais para comparação
                pct=$(python - <<PY
        covered = $covered
        total   = $total
        print(f"{(covered/total):.4f}")
        PY
        )
                    # compara como string numérica
                    if python - <<PY
        import sys
        print(float("$pct") >= float("${MIN_COVERAGE}"))
        PY
                    then
                      pct_ok=1
                    fi
                    echo "Cobertura de linhas: $(python - <<PY
        print(f"{(float('$pct')*100):.2f}%")
        PY
        )"
                  fi
                fi
              fi

              if [ $ok_exec -eq 1 ] && [ $have_exec -eq 1 ] && [ $have_xml_good -eq 1 ] && [ $pct_ok -eq 1 ]; then
                echo "✅ cobertura OK e jacoco.xml válido (não-empty)."
                break
              fi

              echo "❌ Falha/sem cobertura útil; gerando payload e pedindo patches à IA…"
              ./gradlew --no-daemon --no-configuration-cache -p app gerarPacoteParaIA --info || true

              # pedir patches; se der 429, faz backoff exponencial leve
              set +e
              ./gradlew --no-daemon --no-configuration-cache -p app ajustarTestesIa --info
              rc=$?
              set -e
              if [ $rc -ne 0 ]; then
                echo "ajustarTestesIa retornou $rc; tentando tratamento de rate-limit (se aplicável)…"
                sleep $(( 2 * tries ))
              fi

              # se a IA não gerou nada, pare (não adianta insistir)
              if ! ls "${{ github.workspace }}/app/entrada-usuario/testes_ai_patches"/*.java >/dev/null 2>&1; then
                echo "⚠️ IA não produziu patches; encerrando loop."
                break
              fi

              tries=$((tries+1))
            done

            echo "JACOCO_XML=${{ github.workspace }}/app/entrada-usuario/jacoco-relatorio/jacoco.xml" >> $GITHUB_ENV
            echo "JACOCO_EXEC=${{ github.workspace }}/app/build/jacoco/testUsuarioConsole.exec" >> $GITHUB_ENV

    - name: Passe final JaCoCo (sem IA)
      run: |
        ./gradlew --no-daemon --no-configuration-cache -p app jacocoFinalSolo --info
      env:
        MIN_COVERAGE: '0.40'   # ou o que preferir; aqui não impede rodar, só informa as tasks


    - name: Upload Jacoco HTML
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: jacoco-html
        path: app/entrada-usuario/jacoco-relatorio/html/

    - name: Upload Jacoco XML
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: jacoco-xml
        path: app/entrada-usuario/jacoco-relatorio/jacoco.xml



    - name: Debug cobertura
      run: |
        set -xe
        ls -la $GITHUB_WORKSPACE/app/build/jacoco || true
        ls -la $GITHUB_WORKSPACE/app/entrada-usuario/jacoco-relatorio || true
        head -n 20 "$JACOCO_XML" || true

    - name: Publicar cobertura (artefatos)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: cobertura-usuario
        path: |
          app/build/jacoco/testUsuarioConsole.exec
          app/entrada-usuario/jacoco-relatorio/jacoco.xml
          app/entrada-usuario/jacoco-relatorio/html
        retention-days: 7

    - name: Inspecionar artefatos de cobertura
      if: always()
      run: |
        echo "== .exec =="
        ls -la app/build/jacoco || true
        echo "== jacoco.xml destino =="
        ls -la app/entrada-usuario/jacoco-relatorio || true

    - name: Conferir jacoco.exec e jacoco.xml
      id: check_cov
      run: |
        set -euo pipefail
        XML="${{ env.JACOCO_XML }}"
        EXEC="${{ env.JACOCO_EXEC }}"
        ok=1
        if [ ! -s "$EXEC" ]; then
          echo "::warning::testUsuarioConsole.exec ausente ou vazio: $EXEC"
          ok=0
        fi
        if [ ! -s "$XML" ]; then
          echo "::warning::jacoco.xml ausente ou vazio: $XML"
          ok=0
        fi
        if [ "$ok" = "1" ]; then
          echo "tem_cov=true" >> "$GITHUB_OUTPUT"
          echo "Primeiras linhas do jacoco.xml:"
          head -n 20 "$XML" || true
        else
          echo "tem_cov=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Commit e push dos arquivos gerados (na main)
      if: ${{ github.event_name != 'pull_request' }}
      env:
        BRANCH: main
      run: |
        set -euo pipefail
        git config user.name  "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config --global --add safe.directory "$GITHUB_WORKSPACE"

        git stash push --include-untracked --all -m "ci-autostash" || true
        git fetch origin "$BRANCH" --prune
        if git rev-parse --verify "$BRANCH" >/dev/null 2>&1; then
          git checkout "$BRANCH"
        else
          git checkout -b "$BRANCH"
        fi
        git reset --hard "origin/$BRANCH"
        git stash pop || true

        # Preferir o que foi gerado nesta execução
        if git diff --name-only --diff-filter=U | grep -q .; then
          echo "Resolvendo conflitos preferindo as alterações geradas (stash/theirs)…"
          git checkout --theirs -- .
          git add -A
        fi

        git add -A app/entrada-usuario

        if git diff --cached --quiet; then
          echo "Sem mudanças para commit."
        else
          msg="chore: atualizar entrada-usuario e testes gerados (incl. patches IA Groq) [skip ci] - run ${{ github.run_number }} @ ${{ github.sha }}"
          git commit -m "$msg"
          if ! git push origin HEAD:"$BRANCH"; then
            git pull --rebase --autostash origin "$BRANCH" || true
            git push --force-with-lease origin HEAD:"$BRANCH"
          fi
        fi

        echo "COV_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV

    - name: Upload para Codecov (uploader CLI)
      if: steps.check_cov.outputs.tem_cov == 'true'
      run: |
        set -euo pipefail
        curl -Os https://uploader.codecov.io/latest/linux/codecov
        chmod +x codecov
        ./codecov \
          -t "$CODECOV_TOKEN" \
          -f "$JACOCO_XML" \
          -F usuario \
          -n cobertura-entrada-usuario \
          -C "$COV_SHA" \
          -v
      env:
        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

    - name: Escreve marcador de sucesso
      if: ${{ success() }}
      run: |
        mkdir -p app/entrada-usuario
        node -e "const fs=require('fs'); const now=Date.now(); const j={done:true,status:'success',endedAt:now}; fs.writeFileSync('app/entrada-usuario/done.json', JSON.stringify(j,null,2));"

    - name: Escreve marcador de falha
      if: ${{ failure() }}
      run: |
        mkdir -p app/entrada-usuario
        node -e "const fs=require('fs'); const now=Date.now(); const j={done:true,status:'failure',endedAt:now}; fs.writeFileSync('app/entrada-usuario/done.json', JSON.stringify(j,null,2));"

    - name: Commit do marcador
      if: ${{ success() || failure() || cancelled() }}
      run: |
        git config user.name  "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git add app/entrada-usuario/done.json
        git commit -m "mark: done [skip ci]" || echo "nada a commitar"
        git push
