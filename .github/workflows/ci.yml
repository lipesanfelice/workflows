# ci.yml

name: Java CI with Gradle

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: gen-tests-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    paths:
      - 'app/entrada-usuario/**'
  pull_request:
    paths:
      - 'app/entrada-usuario/**'

jobs:
  build:
    runs-on: ubuntu-latest

    env:
      JAVA_VERSION: '21'
      GRADLE_OPTS: "-Dorg.gradle.daemon=false -Dorg.gradle.jvmargs='-Xmx2g -Dfile.encoding=UTF-8'"
      # Caminhos de artefatos importantes
      JACOCO_XML: ${{ github.workspace }}/app/entrada-usuario/jacoco-relatorio/jacoco.xml
      JACOCO_HTML_DIR: ${{ github.workspace }}/app/entrada-usuario/jacoco-relatorio/html
      JACOCO_EXEC: ${{ github.workspace }}/app/build/jacoco/testUsuarioConsole.exec
      TESTES_DIR: ${{ github.workspace }}/app/entrada-usuario/testes_explicações
      ENTRADA_DIR: ${{ github.workspace }}/app/entrada-usuario
      SONAR_JSON: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json

    steps:
    - name: Checkout do código
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        persist-credentials: true

    - name: Configurar Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '21'

    - name: Cache do Gradle
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Conceder permissão para o wrapper
      run: chmod +x gradlew

    - name: SonarQube
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: |
        ./gradlew clean build
        ./gradlew -p app -Dsonar.token=$SONAR_TOKEN sonar

    - name: Extrair métricas Sonar → relatorio-sonar.json
      working-directory: app
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_PROJECT_KEY: lipesanfelice_workflows
        SONAR_OUTPUT_DIR: ${{ github.workspace }}/app/entrada-usuario
      run: ../gradlew bootRun --args='--acao=extrair-sonar --spring.main.web-application-type=none'

    - name: Conferir e imprimir conteúdo
      env:
        ARQ: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
      run: |
        set -euo pipefail
        ls -la "$(dirname "$ARQ")" || true
        test -s "$ARQ"
        echo "OK: arquivo presente"
        echo "Tamanho (bytes): $(wc -c < "$ARQ")"
        python3 - <<'PY'
        import os, json
        p = os.environ["ARQ"]
        t = open(p,'r',encoding='utf-8').read()
        try:
          j = json.loads(t)
          print(json.dumps(j, ensure_ascii=False, indent=2))
        except Exception:
          print(t)
        PY

    - name: Backup fora do repo
      env:
        ARQ: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
        BKP: ${{ runner.temp }}/relatorio-sonar.json
      run: |
        set -euo pipefail
        cp -f "$ARQ" "$BKP"
        echo "SONAR_JSON=$ARQ" >> $GITHUB_ENV
        echo "SONAR_JSON_BKP=$BKP" >> $GITHUB_ENV

    - name: Restaurar se arquivo sumir
      if: always()
      run: |
        set -euo pipefail
        if [ ! -s "$SONAR_JSON" ] && [ -s "$SONAR_JSON_BKP" ]; then
          mkdir -p "$(dirname "$SONAR_JSON")"
          cp -f "$SONAR_JSON_BKP" "$SONAR_JSON"
          echo "Restaurado a partir do backup"
        fi
        ls -la "$(dirname "$SONAR_JSON")" || true

    - name: Publicar relatorio-sonar.json
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: relatorio-sonar
        path: ${{ env.SONAR_JSON }}
        if-no-files-found: error
        retention-days: 30

    - name: Conferir entradas
      run: |
        test -f "${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json" || (echo "faltando relatorio-sonar.json" && exit 1)
        test -d "${{ github.workspace }}/app/entrada-usuario" || (echo "faltando pasta de código entrada-usuario/java" && exit 1)

    - name: Garantir e limpar pasta de testes gerados
      run: |
        TESTS_DIR="${{ github.workspace }}/app/entrada-usuario/testes_explicações"
        mkdir -p "$TESTS_DIR/tests" "$TESTS_DIR/explicacoes"
        find "$TESTS_DIR" -mindepth 1 -maxdepth 1 -exec rm -rf {} +
        echo "Pasta preparada: $TESTS_DIR"

    - name: Gerar testes via IA (Groq)
      env:
        IA_PROVEDOR: groq
        GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        GROQ_MODELO: llama-3.1-8b-instant
        SONAR_RELATORIO_JSON: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
        CODIGO_FONTE_DIR: ${{ github.workspace }}/app/entrada-usuario
        IA_SLEEP_MS: '8000'
        IA_CODE_MAX_CHARS: '3000'
        IA_SONAR_MAX_CHARS: '2000'
      run: |
        ./gradlew -p app bootRun --args='--acao=gerar-testes --spring.main.web-application-type=none --app.entrada.diretorio=${{ github.workspace }}/app/entrada-usuario'

    - name: Conferir testes gerados
      run: |
        echo "Arquivos gerados:"
        find "${{ github.workspace }}/app/entrada-usuario/testes_explicações/tests" -type f -name "*.java" | sed -n '1,200p'
        echo "Relatório:"
        cat "${{ github.workspace }}/app/entrada-usuario/testes_explicações/relatorio.txt" || true

    - name: Verificar presença de fontes e testes do usuário
      id: check_usuario
      shell: bash
      run: |
        shopt -s globstar nullglob
        fontes=(app/entrada-usuario/**/*.java)
        testes=(app/entrada-usuario/testes_explicações/tests/**/*.java)
        if [[ ${#fontes[@]} -gt 0 && ${#testes[@]} -gt 0 ]]; then
          echo "tem=true" >> "$GITHUB_OUTPUT"
        else
          echo "tem=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Executar JaCoCo (uma única vez)
      run: |
          ./gradlew --no-daemon -Dorg.gradle.configuration-cache=false -p app clean covUsuario --info


    - name: Upload de artefatos (testes + jacoco)
      uses: actions/upload-artifact@v4
      with:
          name: resultados-${{ github.run_id }}
          path: |
            app/entrada-usuario/testes_explicações
            app/entrada-usuario/jacoco-relatorio/jacoco.xml
            app/entrada-usuario/jacoco-relatorio/html
          retention-days: 7

    - name: Debug cobertura
      run: |
        set -xe
        ls -la $GITHUB_WORKSPACE/app/build/jacoco || true
        ls -la $GITHUB_WORKSPACE/app/entrada-usuario/jacoco-relatorio || true
        head -n 20 "$JACOCO_XML" || true

    - name: Publicar cobertura (artefatos)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: cobertura-usuario
        path: |
          app/build/jacoco/testUsuarioConsole.exec
          app/entrada-usuario/jacoco-relatorio/jacoco.xml
          app/entrada-usuario/jacoco-relatorio/html
        retention-days: 7

    - name: Inspecionar artefatos de cobertura
      if: always()
      run: |
        echo "== .exec =="
        ls -la app/build/jacoco || true
        echo "== jacoco.xml destino =="
        ls -la app/entrada-usuario/jacoco-relatorio || true

    - name: Conferir jacoco.exec e jacoco.xml
      id: check_cov
      run: |
        set -euo pipefail
        XML="${{ env.JACOCO_XML }}"
        EXEC="${{ env.JACOCO_EXEC }}"
        ok=1
        if [ ! -s "$EXEC" ]; then
          echo "::warning::testUsuarioConsole.exec ausente ou vazio: $EXEC"
          ok=0
        fi
        if [ ! -s "$XML" ]; then
          echo "::warning::jacoco.xml ausente ou vazio: $XML"
          ok=0
        fi
        if [ "$ok" = "1" ]; then
          echo "tem_cov=true" >> "$GITHUB_OUTPUT"
          echo "Primeiras linhas do jacoco.xml:"
          head -n 20 "$XML" || true
        else
          echo "tem_cov=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Refinar explicações dos testes com IA (Groq)
      if: always()
      env:
        GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        GROQ_MODELO: llama-3.1-8b-instant
        ROOT: ${{ github.workspace }}
        TESTS_DIR: ${{ github.workspace }}/app/entrada-usuario/testes_explicações
        SAIDA_MD: ${{ github.workspace }}/app/entrada-usuario/testes_explicações/explicacoes_refatoradas.md
      shell: bash
      run: |
        set -euo pipefail

        # Garante diretório
        mkdir -p "$TESTS_DIR"

        # Coleta entradas (testes .java e relatorio.txt, se existir)
        node - <<'NODE'
        const fs = require('fs');
        const path = require('path');

        const TESTS_DIR = process.env.TESTS_DIR;
        const SAIDA_MD  = process.env.SAIDA_MD;

        function walk(dir, out=[]) {
          for (const entry of fs.readdirSync(dir, {withFileTypes:true})) {
            const p = path.join(dir, entry.name);
            if (entry.isDirectory()) walk(p, out);
            else out.push(p);
          }
          return out;
        }

        const allFiles = fs.existsSync(TESTS_DIR) ? walk(TESTS_DIR, []) : [];
        const javaTests = allFiles.filter(f => f.endsWith('.java') && f.includes(path.sep + 'tests' + path.sep));
        const relatorio = allFiles.find(f => path.basename(f) === 'relatorio.txt');

        const testsPayload = javaTests.map(f => ({
          nome: path.basename(f),
          caminho: f,
          conteudo: fs.readFileSync(f, 'utf-8')
        }));

        const relatorioTxt = relatorio && fs.existsSync(relatorio) ? fs.readFileSync(relatorio, 'utf-8') : '';

        const systemPrompt = [
          'Você é um assistente que escreve documentação técnica curta e objetiva sobre testes JUnit.',
          'Saída OBRIGATÓRIA: Markdown em PT-BR com o título "Explicações dos Testes".',
          'Para cada arquivo de teste receba: nome, conteúdo.',
          'Para CADA teste, escreva uma seção nível 3 "### <NOME_DO_ARQUIVO>".',
          'Em 1–3 parágrafos por seção: o que valida, quais métodos/funções cobre, cenários principais/limites, mocks/exceções.',
          'Se houver um relatorio.txt de apoio, use apenas como contexto; não o reproduza integralmente.',
          'NÃO inclua JSON bruto, nem caminhos do filesystem, nem metadados internos.'
        ].join(' ');

        const userPrompt = {
          relatorio_suporte: relatorioTxt,
          testes: testsPayload
        };

        // Salva prompt para debug opcional
        try {
          fs.writeFileSync(path.join(TESTS_DIR, 'explicacoes_prompt_debug.json'), JSON.stringify(userPrompt, null, 2));
        } catch(e){}

        // Chamada Groq (compat OpenAI)
        const modelo = process.env.GROQ_MODELO || 'llama-3.1-8b-instant';
        const apiKey = process.env.GROQ_API_KEY;

        if (!apiKey) {
          console.log('GROQ_API_KEY ausente — gerando um esqueleto mínimo…');
          const empty = [
            '# Explicações dos Testes',
            '',
            testsPayload.length === 0
              ? '- Nenhum teste gerado.'
              : testsPayload.map(t => `### ${t.nome}\nResumo: valida cenários principais do código.\nFunções cobertas: inferidas a partir do conteúdo.\n`).join('\n')
          ].join('\n');
          fs.writeFileSync(SAIDA_MD, empty, 'utf-8');
          process.exit(0);
        }

        // Usa fetch do Node 18+
        async function main() {
          const resp = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${apiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              model: modelo,
              messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: 'Gere o Markdown solicitado baseado no JSON a seguir:' },
                { role: 'user', content: JSON.stringify(userPrompt) }
              ],
              temperature: 0.2,
              max_tokens: 1200
            })
          });

          if (!resp.ok) {
            const txt = await resp.text();
            throw new Error(`Groq API falhou: ${resp.status} - ${txt}`);
          }
          const data = await resp.json();
          const md = data.choices?.[0]?.message?.content?.trim() || '# Explicações dos Testes\n\n(Não foi possível gerar conteúdo.)';
          fs.writeFileSync(SAIDA_MD, md, 'utf-8');
          console.log('Gerado:', SAIDA_MD, '(', md.length, 'bytes )');
        }

        main().catch(err => {
          console.error('Falha ao gerar explicações IA:', err.message);
          const fallback = [
            '# Explicações dos Testes',
            '',
            testsPayload.map(t => `### ${t.nome}\n(Explicação não pôde ser gerada automaticamente nesta execução.)\n`).join('\n')
          ].join('\n');
          fs.writeFileSync(SAIDA_MD, fallback, 'utf-8');
          process.exit(0); // não falha o job
        });
        NODE


    - name: Commit e push dos arquivos gerados (na main)
      if: ${{ github.event_name != 'pull_request' }}
      env:
        BRANCH: main
      run: |
        set -euo pipefail
        git config user.name  "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config --global --add safe.directory "$GITHUB_WORKSPACE"

        git stash push --include-untracked --all -m "ci-autostash" || true
        git fetch origin "$BRANCH" --prune
        if git rev-parse --verify "$BRANCH" >/dev/null 2>&1; then
          git checkout "$BRANCH"
        else
          git checkout -b "$BRANCH"
        fi
        git reset --hard "origin/$BRANCH"
        git stash pop || true

        # Preferir o que foi gerado nesta execução
        if git diff --name-only --diff-filter=U | grep -q .; then
          echo "Resolvendo conflitos preferindo as alterações geradas (stash/theirs)…"
          git checkout --theirs -- .
          git add -A
        fi

        git add -A app/entrada-usuario

        if git diff --cached --quiet; then
          echo "Sem mudanças para commit."
        else
          msg="chore: atualizar entrada-usuario e testes gerados (incl. patches IA Groq) [skip ci] - run ${{ github.run_number }} @ ${{ github.sha }}"
          git commit -m "$msg"
          if ! git push origin HEAD:"$BRANCH"; then
            git pull --rebase --autostash origin "$BRANCH" || true
            git push --force-with-lease origin HEAD:"$BRANCH"
          fi
        fi

        echo "COV_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV

    - name: Upload para Codecov (uploader CLI)
      if: steps.check_cov.outputs.tem_cov == 'true'
      run: |
        set -euo pipefail
        curl -Os https://uploader.codecov.io/latest/linux/codecov
        chmod +x codecov
        ./codecov \
          -t "$CODECOV_TOKEN" \
          -f "$JACOCO_XML" \
          -F usuario \
          -n cobertura-entrada-usuario \
          -C "$COV_SHA" \
          -v
      env:
        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

    - name: Escreve marcador de sucesso
      if: ${{ success() }}
      run: |
        mkdir -p app/entrada-usuario
        node -e "const fs=require('fs'); const now=Date.now(); const j={done:true,status:'success',endedAt:now}; fs.writeFileSync('app/entrada-usuario/done.json', JSON.stringify(j,null,2));"

    - name: Escreve marcador de falha
      if: ${{ failure() }}
      run: |
        mkdir -p app/entrada-usuario
        node -e "const fs=require('fs'); const now=Date.now(); const j={done:true,status:'failure',endedAt:now}; fs.writeFileSync('app/entrada-usuario/done.json', JSON.stringify(j,null,2));"

    - name: Commit do marcador
      if: ${{ success() || failure() || cancelled() }}
      run: |
        git config user.name  "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git add app/entrada-usuario/done.json
        git commit -m "mark: done [skip ci]" || echo "nada a commitar"
        git push
