# ci.yml

name: Java CI with Gradle

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: gen-tests-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    paths:
      - 'app/entrada-usuario/**'
  pull_request:
    paths:
      - 'app/entrada-usuario/**'

jobs:
  build:
    runs-on: ubuntu-latest

    env:
      JAVA_VERSION: '21'
      GRADLE_OPTS: "-Dorg.gradle.daemon=false -Dorg.gradle.jvmargs='-Xmx2g -Dfile.encoding=UTF-8'"
      # Caminhos de artefatos importantes
      JACOCO_XML: ${{ github.workspace }}/app/entrada-usuario/jacoco-relatorio/jacoco.xml
      JACOCO_HTML_DIR: ${{ github.workspace }}/app/entrada-usuario/jacoco-relatorio/html
      JACOCO_EXEC: ${{ github.workspace }}/app/build/jacoco/testUsuarioConsole.exec
      TESTES_DIR: ${{ github.workspace }}/app/entrada-usuario/testes_explicações
      ENTRADA_DIR: ${{ github.workspace }}/app/entrada-usuario
      SONAR_JSON: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json

    steps:
    - name: Checkout do código
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        persist-credentials: true

    - name: Configurar Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '21'

    - name: Cache do Gradle
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Conceder permissão para o wrapper
      run: chmod +x gradlew

    # - name: SonarQube
    #   env:
    #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    #   run: |
    #     ./gradlew clean build
    #     ./gradlew -p app -Dsonar.token=$SONAR_TOKEN sonar

    # - name: Extrair métricas Sonar → relatorio-sonar.json
    #   working-directory: app
    #   env:
    #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    #     SONAR_PROJECT_KEY: lipesanfelice_workflows
    #     SONAR_OUTPUT_DIR: ${{ github.workspace }}/app/entrada-usuario
    #   run: ../gradlew bootRun --args='--acao=extrair-sonar --spring.main.web-application-type=none'

    - name: SonarQube
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: |
        ./gradlew clean build
        ./gradlew -p app -Dsonar.token=$SONAR_TOKEN sonar

    - name: Extrair relatório do Sonar (foco 5 métricas + robusto)
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST: https://sonarcloud.io
        SONAR_PROJECT_KEY: lipesanfelice_workflows
        SONAR_BRANCH: main
        SONAR_OUTPUT: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
      shell: bash
      run: |
        set -euo pipefail

        h="${SONAR_HOST:-https://sonarcloud.io}"
        key="${SONAR_PROJECT_KEY:?Defina SONAR_PROJECT_KEY}"
        branch="${SONAR_BRANCH:-main}"
        OUT="${SONAR_OUTPUT:-$GITHUB_WORKSPACE/app/entrada-usuario/relatorio-sonar.json}"

        mkdir -p "$(dirname "$OUT")"
        TMP="$(mktemp -d)"

        # Somente as 5 métricas desejadas
        DESIRED_KEYS="bugs,vulnerabilities,code_smells,complexity,duplicated_lines_density"

        # Helper: GET com retry
        cf() {
          local url="$1"
          echo "GET $url" >&2
          curl -sfL --retry 3 --retry-delay 2 -u "${SONAR_TOKEN}:" "$url"
        }

        # Helper: grava e valida JSON; se inválido, grava {}
        get_json_to() {
          local url="$1" dest="$2"
          local body
          if ! body="$(cf "$url")"; then
            printf '{}' > "$dest"
            return 0
          fi
          # valida
          if jq -e . >/dev/null 2>&1 <<<"$body"; then
            printf '%s' "$body" > "$dest"
          else
            printf '{}' > "$dest"
          fi
        }

        # ===== 1) Catálogo de métricas (para pegar definições legíveis)
        get_json_to "$h/api/metrics/search?ps=500" "$TMP/metrics_all.json"

        # Filtra só as desejadas e monta dicionário key -> definição
        jq --arg keys "$DESIRED_KEYS" '
          (.metrics // [])
          | map(select((.key) as $k | ($keys|split(",")|index($k)) != null))
          | map({ ( .key ): { name, type, domain, direction, description } })
          | add
        ' "$TMP/metrics_all.json" > "$TMP/metrics_def.json"

        # ===== 2) Medidas no projeto (apenas as 5)
        KEYS_URI="$(jq -rn --arg s "$DESIRED_KEYS" '$s|@uri')"
        BR_URI="$(jq -rn --arg b "$branch" '$b|@uri')"

        get_json_to \
          "$h/api/measures/component?component=$key&metricKeys=$KEYS_URI&branch=$BR_URI" \
          "$TMP/comp.json"

        # ===== 3) Medidas por arquivos e diretórios (árvore)
        get_json_to \
          "$h/api/measures/component_tree?component=$key&metricKeys=$KEYS_URI&branch=$BR_URI&qualifiers=FIL,DIR&ps=500" \
          "$TMP/tree.json"

        # ===== 4) Issues (BUG, VULNERABILITY, CODE_SMELL) — paginação segura
        page=1
        ps=500
        files=()
        while : ; do
          URL="$h/api/issues/search?componentKeys=$key&branch=$BR_URI&ps=$ps&p=$page&types=BUG,VULNERABILITY,CODE_SMELL"
          f="$TMP/issues_p${page}.json"
          get_json_to "$URL" "$f"
          files+=("$f")

          tot="$(jq -r '.paging.total // .total // 0' "$f" 2>/dev/null || echo 0)"
          # Se não houver a chave paging/total, para na 1ª página
          [[ "$tot" =~ ^[0-9]+$ ]] || break
          (( page*ps >= tot )) && break
          page=$((page+1))
        done

        # Merge das páginas (lendo de arquivo; evita --argjson gigante)
        if ((${#files[@]})); then
          jq -s '
            def last: .[-1];
            def first: .[0];
            {
              total: ( first.paging.total // first.total // (map(.issues|length)|add) // 0 ),
              ps:    ( last.ps // last.paging.pageSize // 500 ),
              issues: ( map(.issues // []) | add )
            }
          ' "${files[@]}" > "$TMP/issues_merged.json"
        else
          echo '{"total":0,"ps":500,"issues":[]}' > "$TMP/issues_merged.json"
        fi

        # ===== 5) (Opcional) Quality Gate — útil para contexto do projeto
        get_json_to \
          "$h/api/qualitygates/project_status?projectKey=$key&branch=$BR_URI" \
          "$TMP/qg.json"

        # ===== 6) Montagem final do relatório
        jq -n \
          --arg projectKey "$key" \
          --arg branch "$branch" \
          --arg host "$h" \
          --arg metric_keys "$DESIRED_KEYS" \
          --slurpfile metrics_def   "$TMP/metrics_def.json" \
          --slurpfile measures_proj "$TMP/comp.json" \
          --slurpfile measures_tree "$TMP/tree.json" \
          --slurpfile issues        "$TMP/issues_merged.json" \
          --slurpfile quality_gate  "$TMP/qg.json" '
          {
            project: { key: $projectKey, branch: $branch, host: $host },

            # Métricas solicitadas
            metric_keys_used: ($metric_keys|split(",")),

            # "O que permeia": definições detalhadas das métricas usadas
            metrics_definitions: ($metrics_def[0] // {}),

            # Medidas (projeto + árvore FIL/DIR) somente dessas métricas
            measures: {
              project: ($measures_proj[0].component.measures // []),
              tree:    ($measures_tree[0] // {})
            },

            # Issues relevantes a essas métricas (tipos BUG/VULN/CODE_SMELL)
            issues: ($issues[0] // {}),

            # Contexto de qualidade (opcional)
            quality_gate: ($quality_gate[0] // {})
          }
        ' > "$OUT"

        echo "Relatório salvo em: $OUT"
        echo "Bytes: $(wc -c < "$OUT")"




    - name: Conferir e imprimir conteúdo
      env:
        ARQ: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
      run: |
        set -euo pipefail
        ls -la "$(dirname "$ARQ")" || true
        test -s "$ARQ"
        echo "OK: arquivo presente"
        echo "Tamanho (bytes): $(wc -c < "$ARQ")"
        python3 - <<'PY'
        import os, json
        p = os.environ["ARQ"]
        t = open(p,'r',encoding='utf-8').read()
        try:
          j = json.loads(t)
          print(json.dumps(j, ensure_ascii=False, indent=2))
        except Exception:
          print(t)
        PY

    - name: Backup fora do repo
      env:
        ARQ: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
        BKP: ${{ runner.temp }}/relatorio-sonar.json
      run: |
        set -euo pipefail
        cp -f "$ARQ" "$BKP"
        echo "SONAR_JSON=$ARQ" >> $GITHUB_ENV
        echo "SONAR_JSON_BKP=$BKP" >> $GITHUB_ENV

    - name: Restaurar se arquivo sumir
      if: always()
      run: |
        set -euo pipefail
        if [ ! -s "$SONAR_JSON" ] && [ -s "$SONAR_JSON_BKP" ]; then
          mkdir -p "$(dirname "$SONAR_JSON")"
          cp -f "$SONAR_JSON_BKP" "$SONAR_JSON"
          echo "Restaurado a partir do backup"
        fi
        ls -la "$(dirname "$SONAR_JSON")" || true

    - name: Publicar relatorio-sonar.json
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: relatorio-sonar
        path: ${{ env.SONAR_JSON }}
        if-no-files-found: error
        retention-days: 30

    - name: Conferir entradas
      run: |
        test -f "${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json" || (echo "faltando relatorio-sonar.json" && exit 1)
        test -d "${{ github.workspace }}/app/entrada-usuario" || (echo "faltando pasta de código entrada-usuario/java" && exit 1)

    - name: Garantir e limpar pasta de testes gerados
      run: |
        TESTS_DIR="${{ github.workspace }}/app/entrada-usuario/testes_explicações"
        mkdir -p "$TESTS_DIR/tests" "$TESTS_DIR/explicacoes"
        find "$TESTS_DIR" -mindepth 1 -maxdepth 1 -exec rm -rf {} +
        echo "Pasta preparada: $TESTS_DIR"

    - name: Gerar testes via IA (Groq)
      env:
        IA_PROVEDOR: groq
        GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        GROQ_MODELO: llama-3.1-8b-instant
        SONAR_RELATORIO_JSON: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
        CODIGO_FONTE_DIR: ${{ github.workspace }}/app/entrada-usuario
        IA_SLEEP_MS: '8000'
        IA_CODE_MAX_CHARS: '3000'
        IA_SONAR_MAX_CHARS: '2000'
      run: |
        ./gradlew -p app bootRun --args='--acao=gerar-testes --spring.main.web-application-type=none --app.entrada.diretorio=${{ github.workspace }}/app/entrada-usuario'

    - name: Conferir testes gerados
      run: |
        echo "Arquivos gerados:"
        find "${{ github.workspace }}/app/entrada-usuario/testes_explicações/tests" -type f -name "*.java" | sed -n '1,200p'
        echo "Relatório:"
        cat "${{ github.workspace }}/app/entrada-usuario/testes_explicações/relatorio.txt" || true

    - name: Verificar presença de fontes e testes do usuário
      id: check_usuario
      shell: bash
      run: |
        shopt -s globstar nullglob
        fontes=(app/entrada-usuario/**/*.java)
        testes=(app/entrada-usuario/testes_explicações/tests/**/*.java)
        if [[ ${#fontes[@]} -gt 0 && ${#testes[@]} -gt 0 ]]; then
          echo "tem=true" >> "$GITHUB_OUTPUT"
        else
          echo "tem=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Executar JaCoCo (uma única vez)
      run: |
          ./gradlew --no-daemon -Dorg.gradle.configuration-cache=false -p app clean covUsuario --info


    - name: Upload de artefatos (testes + jacoco)
      uses: actions/upload-artifact@v4
      with:
          name: resultados-${{ github.run_id }}
          path: |
            app/entrada-usuario/testes_explicações
            app/entrada-usuario/jacoco-relatorio/jacoco.xml
            app/entrada-usuario/jacoco-relatorio/html
          retention-days: 7

    - name: Debug cobertura
      run: |
        set -xe
        ls -la $GITHUB_WORKSPACE/app/build/jacoco || true
        ls -la $GITHUB_WORKSPACE/app/entrada-usuario/jacoco-relatorio || true
        head -n 20 "$JACOCO_XML" || true

    - name: Publicar cobertura (artefatos)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: cobertura-usuario
        path: |
          app/build/jacoco/testUsuarioConsole.exec
          app/entrada-usuario/jacoco-relatorio/jacoco.xml
          app/entrada-usuario/jacoco-relatorio/html
        retention-days: 7

    - name: Inspecionar artefatos de cobertura
      if: always()
      run: |
        echo "== .exec =="
        ls -la app/build/jacoco || true
        echo "== jacoco.xml destino =="
        ls -la app/entrada-usuario/jacoco-relatorio || true

    - name: Conferir jacoco.exec e jacoco.xml
      id: check_cov
      run: |
        set -euo pipefail
        XML="${{ env.JACOCO_XML }}"
        EXEC="${{ env.JACOCO_EXEC }}"
        ok=1
        if [ ! -s "$EXEC" ]; then
          echo "::warning::testUsuarioConsole.exec ausente ou vazio: $EXEC"
          ok=0
        fi
        if [ ! -s "$XML" ]; then
          echo "::warning::jacoco.xml ausente ou vazio: $XML"
          ok=0
        fi
        if [ "$ok" = "1" ]; then
          echo "tem_cov=true" >> "$GITHUB_OUTPUT"
          echo "Primeiras linhas do jacoco.xml:"
          head -n 20 "$XML" || true
        else
          echo "tem_cov=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Refinar explicações dos testes com IA (Groq) — TXT
      if: always()
      env:
        GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        GROQ_MODELO: llama-3.1-8b-instant
        ROOT: ${{ github.workspace }}
        TESTS_DIR: ${{ github.workspace }}/app/entrada-usuario/testes_explicações
        EXPL_DIR: ${{ github.workspace }}/app/entrada-usuario/testes_explicações/explicacoes
        SAIDA_TXT: ${{ github.workspace }}/app/entrada-usuario/testes_explicações/explicacoes/explicacoes_refatoradas.txt
      shell: bash
      run: |
        set -euo pipefail

        mkdir -p "$TESTS_DIR/tests" "$EXPL_DIR"

        node - <<'NODE'
        const fs = require('fs');
        const path = require('path');

        const TESTS_DIR = process.env.TESTS_DIR;
        const EXPL_DIR  = process.env.EXPL_DIR;
        const SAIDA_TXT = process.env.SAIDA_TXT;
        const modelo    = process.env.GROQ_MODELO || 'llama-3.1-8b-instant';
        const apiKey    = process.env.GROQ_API_KEY;

        function walk(dir, out=[]) {
          if (!fs.existsSync(dir)) return out;
          for (const entry of fs.readdirSync(dir, {withFileTypes:true})) {
            const p = path.join(dir, entry.name);
            if (entry.isDirectory()) walk(p, out); else out.push(p);
          }
          return out;
        }

        // Coleta: testes .java e relatorio.txt (antigo)
        const all = walk(TESTS_DIR);
        const javaTests = all.filter(f => f.endsWith('.java') && f.includes(path.sep + 'tests' + path.sep));
        const relatorioAntigo = all.find(f => path.basename(f) === 'relatorio.txt');

        const testesPayload = javaTests.map(f => ({
          nome: path.basename(f),
          conteudo: fs.readFileSync(f, 'utf-8')
        }));

        const apoio = relatorioAntigo && fs.existsSync(relatorioAntigo) ? fs.readFileSync(relatorioAntigo, 'utf-8') : '';

        const systemPrompt = [
          'Você é um assistente que escreve documentação técnica curta, objetiva e EM TEXTO PLANO (sem Markdown) sobre testes JUnit.',
          'A saída deve ser um arquivo .txt com o título na primeira linha: "Explicações dos Testes".',
          'Para cada ARQUIVO DE TESTE, crie uma seção iniciando com "=== <NOME_DO_ARQUIVO> ===".',
          'Em 3-8 linhas por seção, explique: o que o teste valida, quais funções/métodos do código ele cobre, cenários principais/borda, uso de mocks e exceções.',
          'Se houver texto de apoio, use apenas como contexto. Não repita o arquivo inteiro nem paths de filesystem.',
          'Não use bullet points com símbolos especiais; apenas texto plano com quebras de linha.'
        ].join(' ');

        const userPayload = {
          relatorio_suporte: apoio,
          testes: testesPayload
        };

        // Função que grava fallback básico
        function writeFallback(motivo) {
          const linhas = [];
          linhas.push('Explicações dos Testes');
          linhas.push('');
          if (testesPayload.length === 0) {
            linhas.push('(Nenhum teste encontrado.)');
          } else {
            for (const t of testesPayload) {
              linhas.push(`=== ${t.nome} ===`);
              linhas.push('Resumo: valida cenários principais do código e cobre os métodos relacionados.');
              linhas.push('');
            }
          }
          const out = linhas.join('\n');
          fs.mkdirSync(path.dirname(SAIDA_TXT), { recursive: true });
          fs.writeFileSync(SAIDA_TXT, out, 'utf-8');
          // também substituir o antigo relatorio.txt na raiz por compat
          fs.writeFileSync(path.join(TESTS_DIR, 'relatorio.txt'), out, 'utf-8');
          console.log('Gerado fallback (', motivo, '):', SAIDA_TXT);
        }

        (async () => {
          if (!apiKey) {
            console.log('GROQ_API_KEY ausente. Gerando fallback…');
            writeFallback('sem API key');
            return;
          }

          const resp = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({
              model: modelo,
              messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: 'Gere o texto plano solicitado com base no JSON a seguir.' },
                { role: 'user', content: JSON.stringify(userPayload) }
              ],
              temperature: 0.2,
              max_tokens: 1400
            })
          });

          if (!resp.ok) {
            const txt = await resp.text();
            console.error('Groq API falhou:', resp.status, txt);
            writeFallback('erro API');
            return;
          }
          const data = await resp.json();
          let saida = (data.choices?.[0]?.message?.content || '').trim();

          if (!saida) {
            writeFallback('vazio');
            return;
          }

          // Garante título correto na 1ª linha
          const lines = saida.split(/\r?\n/);
          if (!/^Explicações dos Testes\s*$/i.test(lines[0] || '')) {
            saida = 'Explicações dos Testes\n\n' + saida;
          }

          fs.mkdirSync(path.dirname(SAIDA_TXT), { recursive: true });
          fs.writeFileSync(SAIDA_TXT, saida, 'utf-8');

          // Substitui o antigo relatorio.txt (compatibilidade com tela antiga/artefatos)
          fs.writeFileSync(path.join(TESTS_DIR, 'relatorio.txt'), saida, 'utf-8');

          console.log('Gerado .txt refatorado:', SAIDA_TXT, '(', saida.length, 'bytes )');
        })().catch(err => {
          console.error('Falha inesperada:', err);
          writeFallback('exceção');
        });
        NODE


    - name: Commit e push dos arquivos gerados (na main)
      if: ${{ github.event_name != 'pull_request' }}
      env:
        BRANCH: main
      run: |
        set -euo pipefail
        git config user.name  "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config --global --add safe.directory "$GITHUB_WORKSPACE"

        git stash push --include-untracked --all -m "ci-autostash" || true
        git fetch origin "$BRANCH" --prune
        if git rev-parse --verify "$BRANCH" >/dev/null 2>&1; then
          git checkout "$BRANCH"
        else
          git checkout -b "$BRANCH"
        fi
        git reset --hard "origin/$BRANCH"
        git stash pop || true

        # Preferir o que foi gerado nesta execução
        if git diff --name-only --diff-filter=U | grep -q .; then
          echo "Resolvendo conflitos preferindo as alterações geradas (stash/theirs)…"
          git checkout --theirs -- .
          git add -A
        fi

        git add -A app/entrada-usuario

        if git diff --cached --quiet; then
          echo "Sem mudanças para commit."
        else
          msg="chore: atualizar entrada-usuario e testes gerados (incl. patches IA Groq) [skip ci] - run ${{ github.run_number }} @ ${{ github.sha }}"
          git commit -m "$msg"
          if ! git push origin HEAD:"$BRANCH"; then
            git pull --rebase --autostash origin "$BRANCH" || true
            git push --force-with-lease origin HEAD:"$BRANCH"
          fi
        fi

        echo "COV_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV

    - name: Upload para Codecov (uploader CLI)
      if: steps.check_cov.outputs.tem_cov == 'true'
      run: |
        set -euo pipefail
        curl -Os https://uploader.codecov.io/latest/linux/codecov
        chmod +x codecov
        ./codecov \
          -t "$CODECOV_TOKEN" \
          -f "$JACOCO_XML" \
          -F usuario \
          -n cobertura-entrada-usuario \
          -C "$COV_SHA" \
          -v
      env:
        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

    - name: Escreve marcador de sucesso
      if: ${{ success() }}
      run: |
        mkdir -p app/entrada-usuario
        node -e "const fs=require('fs'); const now=Date.now(); const j={done:true,status:'success',endedAt:now}; fs.writeFileSync('app/entrada-usuario/done.json', JSON.stringify(j,null,2));"

    - name: Escreve marcador de falha
      if: ${{ failure() }}
      run: |
        mkdir -p app/entrada-usuario
        node -e "const fs=require('fs'); const now=Date.now(); const j={done:true,status:'failure',endedAt:now}; fs.writeFileSync('app/entrada-usuario/done.json', JSON.stringify(j,null,2));"

    - name: Commit do marcador
      if: ${{ success() || failure() || cancelled() }}
      run: |
        git config user.name  "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git add app/entrada-usuario/done.json
        git commit -m "mark: done [skip ci]" || echo "nada a commitar"
        git push
