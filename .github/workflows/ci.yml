# ci.yml

name: Java CI with Gradle

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: gen-tests-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    paths:
      - 'app/entrada-usuario/**'
  pull_request:
    paths:
      - 'app/entrada-usuario/**'

jobs:
  build:
    runs-on: ubuntu-latest

    env:
      JAVA_VERSION: '21'
      GRADLE_OPTS: "-Dorg.gradle.daemon=false -Dorg.gradle.jvmargs='-Xmx2g -Dfile.encoding=UTF-8'"
      # Caminhos de artefatos importantes
      JACOCO_XML: ${{ github.workspace }}/app/entrada-usuario/jacoco-relatorio/jacoco.xml
      JACOCO_HTML_DIR: ${{ github.workspace }}/app/entrada-usuario/jacoco-relatorio/html
      JACOCO_EXEC: ${{ github.workspace }}/app/build/jacoco/testUsuarioConsole.exec
      TESTES_DIR: ${{ github.workspace }}/app/entrada-usuario/testes_explicações
      ENTRADA_DIR: ${{ github.workspace }}/app/entrada-usuario
      SONAR_JSON: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json

    steps:
    - name: Checkout do código
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        persist-credentials: true

    - name: Configurar Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '21'

    - name: Cache do Gradle
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Conceder permissão para o wrapper
      run: chmod +x gradlew

    # - name: SonarQube
    #   env:
    #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    #   run: |
    #     ./gradlew clean build
    #     ./gradlew -p app -Dsonar.token=$SONAR_TOKEN sonar

    # - name: Extrair métricas Sonar → relatorio-sonar.json
    #   working-directory: app
    #   env:
    #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    #     SONAR_PROJECT_KEY: lipesanfelice_workflows
    #     SONAR_OUTPUT_DIR: ${{ github.workspace }}/app/entrada-usuario
    #   run: ../gradlew bootRun --args='--acao=extrair-sonar --spring.main.web-application-type=none'

    - name: SonarQube
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: |
        ./gradlew clean build
        ./gradlew -p app -Dsonar.token=$SONAR_TOKEN sonar

    - name: Extrair relatório completo do Sonar (metrics + measures + issues + hotspots + QG)
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST: https://sonarcloud.io                 # troque se for servidor próprio
        SONAR_PROJECT_KEY: lipesanfelice_workflows        # CONFIRA esse key no Sonar!
        BRANCH: ${{ github.head_ref || github.ref_name }}
        OUT: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
      shell: bash
      run: |
        set -euo pipefail
        sudo apt-get update -y >/dev/null && sudo apt-get install -y jq >/dev/null

        h="$SONAR_HOST"
        key="$SONAR_PROJECT_KEY"
        branch="${BRANCH:-main}"
        auth_header="Authorization: Bearer $SONAR_TOKEN"
        KEYS="bugs,vulnerabilities,code_smells,coverage,lines,ncloc,duplicated_lines_density,complexity,cognitive_complexity,security_hotspots,security_rating,reliability_rating,maintainability_rating,tests,test_success_density"

        call() {
          local path="$1"
          local url="$h$path"
          echo "GET $url" >&2
          # retorna JSON e código HTTP separados
          resp=$(curl -sS -w "\n%{http_code}" -H "$auth_header" "$url")
          code=$(echo "$resp" | tail -n1)
          body=$(echo "$resp" | sed '$d')
          echo "$code"
          printf '%s' "$body" > /tmp/resp.json
        }

        must() {
          local path="$1"
          code=$(call "$path")
          if [ "$code" != "200" ]; then
            echo "::warning::Falha $code em $path — corpo: $(tr -d '\n' </tmp/resp.json | cut -c1-400)" >&2
            return 1
          fi
          cat /tmp/resp.json
        }

        try_or_empty() {
          local path="$1"
          if body=$(must "$path"); then
            echo "$body"
          else
            echo "{}"
          fi
        }

        # 1) definições de métricas
        METRICS=$(try_or_empty "/api/metrics/search?ps=500")

        # 2) medidas do projeto + árvore (arquivos/diretórios)
        COMP=$(try_or_empty "/api/measures/component?component=$(jq -rn --arg v "$key" '$v|@uri')&metricKeys=$(jq -rn --arg v "$KEYS" '$v|@uri')&branch=$(jq -rn --arg v "$branch" '$v|@uri')")
        TREE=$(try_or_empty "/api/measures/component_tree?component=$(jq -rn --arg v "$key" '$v|@uri')&metricKeys=$(jq -rn --arg v "$KEYS" '$v|@uri')&branch=$(jq -rn --arg v "$branch" '$v|@uri')&qualifiers=FIL,DIR&ps=500")

        # 3) issues (pagina em loop)
        ALL_ISSUES='{"total":0,"issues":[]}'
        page=1
        while :; do
          code=$(call "/api/issues/search?componentKeys=$(jq -rn --arg v "$key" '$v|@uri')&branch=$(jq -rn --arg v "$branch" '$v|@uri')&ps=500&p=$page&types=BUG,VULNERABILITY,CODE_SMELL&additionalFields=_all")
          if [ "$code" != "200" ]; then
            echo "::warning::Issues página $page falhou ($code); interrompendo paginação." >&2
            break
          fi
          COUNT=$(jq -r '.issues | length' </tmp/resp.json 2>/dev/null || echo 0)
          [ "${COUNT:-0}" -eq 0 ] && break
          ALL_ISSUES=$(jq -n --argjson A "$ALL_ISSUES" --argjson B "$(cat /tmp/resp.json)" \
            '{ total: ($A.total + ($B.total//0)), issues: ($A.issues + ($B.issues//[])) }')
          page=$((page+1))
        done

        # 4) security hotspots — tenta endpoint novo e antigo
        HOTSPOTS=$(try_or_empty "/api/security_hotspots/search?projectKey=$(jq -rn --arg v "$key" '$v|@uri')&branch=$(jq -rn --arg v "$branch" '$v|@uri')&ps=500")
        if [ "$(echo "$HOTSPOTS" | jq -r 'keys[0] // empty')" = "" ]; then
          HOTSPOTS=$(try_or_empty "/api/hotspots/search?projectKey=$(jq -rn --arg v "$key" '$v|@uri')&branch=$(jq -rn --arg v "$branch" '$v|@uri')&ps=500")
        fi

        # 5) quality gate
        QG=$(try_or_empty "/api/qualitygates/project_status?projectKey=$(jq -rn --arg v "$key" '$v|@uri')&branch=$(jq -rn --arg v "$branch" '$v|@uri')")

        # 6) histórico de métricas
        HIST=$(try_or_empty "/api/measures/search_history?component=$(jq -rn --arg v "$key" '$v|@uri')&metrics=coverage,bugs,code_smells&branch=$(jq -rn --arg v "$branch" '$v|@uri')&ps=500")

        # mapeia definições de métricas p/ consulta amigável
        METRICS_MAP=$(echo "$METRICS" | jq '(.metrics // []) | map({key, name, type, domain, direction, description}) | map({( .key ): del(.key)}) | add')

        jq -n \
          --arg projectKey "$key" \
          --arg branch "$branch" \
          --arg host "$h" \
          --argjson metrics_def "$METRICS_MAP" \
          --argjson measures_project "$COMP" \
          --argjson measures_tree "$TREE" \
          --argjson issues "$ALL_ISSUES" \
          --argjson hotspots "$HOTSPOTS" \
          --argjson quality_gate "$QG" \
          --argjson history "$HIST" '
          {
            project: { key: $projectKey, branch: $branch, host: $host },
            metrics_definitions: ($metrics_def // {}),
            measures: {
              project: ($measures_project.component.measures // []),
              tree:    $measures_tree
            },
            issues: $issues,
            security_hotspots: $hotspots,
            quality_gate: $quality_gate,
            trends: $history
          }' >"$OUT"

        echo "Relatório salvo em: $OUT (bytes: $(wc -c < "$OUT"))"



    - name: Conferir e imprimir conteúdo
      env:
        ARQ: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
      run: |
        set -euo pipefail
        ls -la "$(dirname "$ARQ")" || true
        test -s "$ARQ"
        echo "OK: arquivo presente"
        echo "Tamanho (bytes): $(wc -c < "$ARQ")"
        python3 - <<'PY'
        import os, json
        p = os.environ["ARQ"]
        t = open(p,'r',encoding='utf-8').read()
        try:
          j = json.loads(t)
          print(json.dumps(j, ensure_ascii=False, indent=2))
        except Exception:
          print(t)
        PY

    - name: Backup fora do repo
      env:
        ARQ: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
        BKP: ${{ runner.temp }}/relatorio-sonar.json
      run: |
        set -euo pipefail
        cp -f "$ARQ" "$BKP"
        echo "SONAR_JSON=$ARQ" >> $GITHUB_ENV
        echo "SONAR_JSON_BKP=$BKP" >> $GITHUB_ENV

    - name: Restaurar se arquivo sumir
      if: always()
      run: |
        set -euo pipefail
        if [ ! -s "$SONAR_JSON" ] && [ -s "$SONAR_JSON_BKP" ]; then
          mkdir -p "$(dirname "$SONAR_JSON")"
          cp -f "$SONAR_JSON_BKP" "$SONAR_JSON"
          echo "Restaurado a partir do backup"
        fi
        ls -la "$(dirname "$SONAR_JSON")" || true

    - name: Publicar relatorio-sonar.json
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: relatorio-sonar
        path: ${{ env.SONAR_JSON }}
        if-no-files-found: error
        retention-days: 30

    - name: Conferir entradas
      run: |
        test -f "${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json" || (echo "faltando relatorio-sonar.json" && exit 1)
        test -d "${{ github.workspace }}/app/entrada-usuario" || (echo "faltando pasta de código entrada-usuario/java" && exit 1)

    - name: Garantir e limpar pasta de testes gerados
      run: |
        TESTS_DIR="${{ github.workspace }}/app/entrada-usuario/testes_explicações"
        mkdir -p "$TESTS_DIR/tests" "$TESTS_DIR/explicacoes"
        find "$TESTS_DIR" -mindepth 1 -maxdepth 1 -exec rm -rf {} +
        echo "Pasta preparada: $TESTS_DIR"

    - name: Gerar testes via IA (Groq)
      env:
        IA_PROVEDOR: groq
        GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        GROQ_MODELO: llama-3.1-8b-instant
        SONAR_RELATORIO_JSON: ${{ github.workspace }}/app/entrada-usuario/relatorio-sonar.json
        CODIGO_FONTE_DIR: ${{ github.workspace }}/app/entrada-usuario
        IA_SLEEP_MS: '8000'
        IA_CODE_MAX_CHARS: '3000'
        IA_SONAR_MAX_CHARS: '2000'
      run: |
        ./gradlew -p app bootRun --args='--acao=gerar-testes --spring.main.web-application-type=none --app.entrada.diretorio=${{ github.workspace }}/app/entrada-usuario'

    - name: Conferir testes gerados
      run: |
        echo "Arquivos gerados:"
        find "${{ github.workspace }}/app/entrada-usuario/testes_explicações/tests" -type f -name "*.java" | sed -n '1,200p'
        echo "Relatório:"
        cat "${{ github.workspace }}/app/entrada-usuario/testes_explicações/relatorio.txt" || true

    - name: Verificar presença de fontes e testes do usuário
      id: check_usuario
      shell: bash
      run: |
        shopt -s globstar nullglob
        fontes=(app/entrada-usuario/**/*.java)
        testes=(app/entrada-usuario/testes_explicações/tests/**/*.java)
        if [[ ${#fontes[@]} -gt 0 && ${#testes[@]} -gt 0 ]]; then
          echo "tem=true" >> "$GITHUB_OUTPUT"
        else
          echo "tem=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Executar JaCoCo (uma única vez)
      run: |
          ./gradlew --no-daemon -Dorg.gradle.configuration-cache=false -p app clean covUsuario --info


    - name: Upload de artefatos (testes + jacoco)
      uses: actions/upload-artifact@v4
      with:
          name: resultados-${{ github.run_id }}
          path: |
            app/entrada-usuario/testes_explicações
            app/entrada-usuario/jacoco-relatorio/jacoco.xml
            app/entrada-usuario/jacoco-relatorio/html
          retention-days: 7

    - name: Debug cobertura
      run: |
        set -xe
        ls -la $GITHUB_WORKSPACE/app/build/jacoco || true
        ls -la $GITHUB_WORKSPACE/app/entrada-usuario/jacoco-relatorio || true
        head -n 20 "$JACOCO_XML" || true

    - name: Publicar cobertura (artefatos)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: cobertura-usuario
        path: |
          app/build/jacoco/testUsuarioConsole.exec
          app/entrada-usuario/jacoco-relatorio/jacoco.xml
          app/entrada-usuario/jacoco-relatorio/html
        retention-days: 7

    - name: Inspecionar artefatos de cobertura
      if: always()
      run: |
        echo "== .exec =="
        ls -la app/build/jacoco || true
        echo "== jacoco.xml destino =="
        ls -la app/entrada-usuario/jacoco-relatorio || true

    - name: Conferir jacoco.exec e jacoco.xml
      id: check_cov
      run: |
        set -euo pipefail
        XML="${{ env.JACOCO_XML }}"
        EXEC="${{ env.JACOCO_EXEC }}"
        ok=1
        if [ ! -s "$EXEC" ]; then
          echo "::warning::testUsuarioConsole.exec ausente ou vazio: $EXEC"
          ok=0
        fi
        if [ ! -s "$XML" ]; then
          echo "::warning::jacoco.xml ausente ou vazio: $XML"
          ok=0
        fi
        if [ "$ok" = "1" ]; then
          echo "tem_cov=true" >> "$GITHUB_OUTPUT"
          echo "Primeiras linhas do jacoco.xml:"
          head -n 20 "$XML" || true
        else
          echo "tem_cov=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Refinar explicações dos testes com IA (Groq) — TXT
      if: always()
      env:
        GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        GROQ_MODELO: llama-3.1-8b-instant
        ROOT: ${{ github.workspace }}
        TESTS_DIR: ${{ github.workspace }}/app/entrada-usuario/testes_explicações
        EXPL_DIR: ${{ github.workspace }}/app/entrada-usuario/testes_explicações/explicacoes
        SAIDA_TXT: ${{ github.workspace }}/app/entrada-usuario/testes_explicações/explicacoes/explicacoes_refatoradas.txt
      shell: bash
      run: |
        set -euo pipefail

        mkdir -p "$TESTS_DIR/tests" "$EXPL_DIR"

        node - <<'NODE'
        const fs = require('fs');
        const path = require('path');

        const TESTS_DIR = process.env.TESTS_DIR;
        const EXPL_DIR  = process.env.EXPL_DIR;
        const SAIDA_TXT = process.env.SAIDA_TXT;
        const modelo    = process.env.GROQ_MODELO || 'llama-3.1-8b-instant';
        const apiKey    = process.env.GROQ_API_KEY;

        function walk(dir, out=[]) {
          if (!fs.existsSync(dir)) return out;
          for (const entry of fs.readdirSync(dir, {withFileTypes:true})) {
            const p = path.join(dir, entry.name);
            if (entry.isDirectory()) walk(p, out); else out.push(p);
          }
          return out;
        }

        // Coleta: testes .java e relatorio.txt (antigo)
        const all = walk(TESTS_DIR);
        const javaTests = all.filter(f => f.endsWith('.java') && f.includes(path.sep + 'tests' + path.sep));
        const relatorioAntigo = all.find(f => path.basename(f) === 'relatorio.txt');

        const testesPayload = javaTests.map(f => ({
          nome: path.basename(f),
          conteudo: fs.readFileSync(f, 'utf-8')
        }));

        const apoio = relatorioAntigo && fs.existsSync(relatorioAntigo) ? fs.readFileSync(relatorioAntigo, 'utf-8') : '';

        const systemPrompt = [
          'Você é um assistente que escreve documentação técnica curta, objetiva e EM TEXTO PLANO (sem Markdown) sobre testes JUnit.',
          'A saída deve ser um arquivo .txt com o título na primeira linha: "Explicações dos Testes".',
          'Para cada ARQUIVO DE TESTE, crie uma seção iniciando com "=== <NOME_DO_ARQUIVO> ===".',
          'Em 3-8 linhas por seção, explique: o que o teste valida, quais funções/métodos do código ele cobre, cenários principais/borda, uso de mocks e exceções.',
          'Se houver texto de apoio, use apenas como contexto. Não repita o arquivo inteiro nem paths de filesystem.',
          'Não use bullet points com símbolos especiais; apenas texto plano com quebras de linha.'
        ].join(' ');

        const userPayload = {
          relatorio_suporte: apoio,
          testes: testesPayload
        };

        // Função que grava fallback básico
        function writeFallback(motivo) {
          const linhas = [];
          linhas.push('Explicações dos Testes');
          linhas.push('');
          if (testesPayload.length === 0) {
            linhas.push('(Nenhum teste encontrado.)');
          } else {
            for (const t of testesPayload) {
              linhas.push(`=== ${t.nome} ===`);
              linhas.push('Resumo: valida cenários principais do código e cobre os métodos relacionados.');
              linhas.push('');
            }
          }
          const out = linhas.join('\n');
          fs.mkdirSync(path.dirname(SAIDA_TXT), { recursive: true });
          fs.writeFileSync(SAIDA_TXT, out, 'utf-8');
          // também substituir o antigo relatorio.txt na raiz por compat
          fs.writeFileSync(path.join(TESTS_DIR, 'relatorio.txt'), out, 'utf-8');
          console.log('Gerado fallback (', motivo, '):', SAIDA_TXT);
        }

        (async () => {
          if (!apiKey) {
            console.log('GROQ_API_KEY ausente. Gerando fallback…');
            writeFallback('sem API key');
            return;
          }

          const resp = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({
              model: modelo,
              messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: 'Gere o texto plano solicitado com base no JSON a seguir.' },
                { role: 'user', content: JSON.stringify(userPayload) }
              ],
              temperature: 0.2,
              max_tokens: 1400
            })
          });

          if (!resp.ok) {
            const txt = await resp.text();
            console.error('Groq API falhou:', resp.status, txt);
            writeFallback('erro API');
            return;
          }
          const data = await resp.json();
          let saida = (data.choices?.[0]?.message?.content || '').trim();

          if (!saida) {
            writeFallback('vazio');
            return;
          }

          // Garante título correto na 1ª linha
          const lines = saida.split(/\r?\n/);
          if (!/^Explicações dos Testes\s*$/i.test(lines[0] || '')) {
            saida = 'Explicações dos Testes\n\n' + saida;
          }

          fs.mkdirSync(path.dirname(SAIDA_TXT), { recursive: true });
          fs.writeFileSync(SAIDA_TXT, saida, 'utf-8');

          // Substitui o antigo relatorio.txt (compatibilidade com tela antiga/artefatos)
          fs.writeFileSync(path.join(TESTS_DIR, 'relatorio.txt'), saida, 'utf-8');

          console.log('Gerado .txt refatorado:', SAIDA_TXT, '(', saida.length, 'bytes )');
        })().catch(err => {
          console.error('Falha inesperada:', err);
          writeFallback('exceção');
        });
        NODE


    - name: Commit e push dos arquivos gerados (na main)
      if: ${{ github.event_name != 'pull_request' }}
      env:
        BRANCH: main
      run: |
        set -euo pipefail
        git config user.name  "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config --global --add safe.directory "$GITHUB_WORKSPACE"

        git stash push --include-untracked --all -m "ci-autostash" || true
        git fetch origin "$BRANCH" --prune
        if git rev-parse --verify "$BRANCH" >/dev/null 2>&1; then
          git checkout "$BRANCH"
        else
          git checkout -b "$BRANCH"
        fi
        git reset --hard "origin/$BRANCH"
        git stash pop || true

        # Preferir o que foi gerado nesta execução
        if git diff --name-only --diff-filter=U | grep -q .; then
          echo "Resolvendo conflitos preferindo as alterações geradas (stash/theirs)…"
          git checkout --theirs -- .
          git add -A
        fi

        git add -A app/entrada-usuario

        if git diff --cached --quiet; then
          echo "Sem mudanças para commit."
        else
          msg="chore: atualizar entrada-usuario e testes gerados (incl. patches IA Groq) [skip ci] - run ${{ github.run_number }} @ ${{ github.sha }}"
          git commit -m "$msg"
          if ! git push origin HEAD:"$BRANCH"; then
            git pull --rebase --autostash origin "$BRANCH" || true
            git push --force-with-lease origin HEAD:"$BRANCH"
          fi
        fi

        echo "COV_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV

    - name: Upload para Codecov (uploader CLI)
      if: steps.check_cov.outputs.tem_cov == 'true'
      run: |
        set -euo pipefail
        curl -Os https://uploader.codecov.io/latest/linux/codecov
        chmod +x codecov
        ./codecov \
          -t "$CODECOV_TOKEN" \
          -f "$JACOCO_XML" \
          -F usuario \
          -n cobertura-entrada-usuario \
          -C "$COV_SHA" \
          -v
      env:
        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

    - name: Escreve marcador de sucesso
      if: ${{ success() }}
      run: |
        mkdir -p app/entrada-usuario
        node -e "const fs=require('fs'); const now=Date.now(); const j={done:true,status:'success',endedAt:now}; fs.writeFileSync('app/entrada-usuario/done.json', JSON.stringify(j,null,2));"

    - name: Escreve marcador de falha
      if: ${{ failure() }}
      run: |
        mkdir -p app/entrada-usuario
        node -e "const fs=require('fs'); const now=Date.now(); const j={done:true,status:'failure',endedAt:now}; fs.writeFileSync('app/entrada-usuario/done.json', JSON.stringify(j,null,2));"

    - name: Commit do marcador
      if: ${{ success() || failure() || cancelled() }}
      run: |
        git config user.name  "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git add app/entrada-usuario/done.json
        git commit -m "mark: done [skip ci]" || echo "nada a commitar"
        git push
